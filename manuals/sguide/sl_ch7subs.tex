\module{addhist}%
\noindent Add history to a dataset
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsetio.for
\newline \abox{Keywords:} history, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE addhist( file , progname, message)

        CHARACTER  file*(*), progname*(*), message*(*)

       input:
           file        filename of the dataset
           progname    program name which does the work
           message     message to be added (appended) to history
\endtt}
\par}
\module{addpoly}%
\noindent Add a polynomial to the database of polynomials
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calpoly.for
\newline \abox{Keywords:} calibration, polynomials
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        INTEGER FUNCTION addpoly( code, bl, porder, ppoly, valid)
        IMPLICIT NONE

        CHARACTER code*(*)
        INTEGER   bl, porder
        REAL      ppoly(*), valid(2)

   Add new polynomial to database: insert & delete such that no
   gaps exist and they are still time sorted.....
   This code could perhaps also be used to DELETE a polynomial 
   from the database, but we don't have any use for that yet.

   Input:
       code      associated phase/amp code
       bl        associated baseline [b=findbase(bl); b=1..nbl]
       porder    order to fit (0..MAXORDER)
       ppoly     poly(0..porder) coefficients for polynomial
       valid     validity of new polynomial
   Output:
\endtt}
\par}
\module{amphase}%
\noindent Compute amplitude and phase.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/amphase.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} complex-data, uv-data
\par{\tenpoint
{\eightpoint\begintt
      subroutine amphase (data, amp, phase)
      implicit none

      complex data
      real amp, phase

  Compute amplitude and phase from one complex correlation

  Input:
    data       The complex data.
  Output:
    amp        The amplitude.
    phase      The phase (degrees).
\endtt}
\par}
\module{ampscal}%
\noindent Scale amplitudes of a calibrator
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Keywords:} calibration
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE ampscal(amp, jyflux, scalmode)

        REAL    amp, jyflux
        INTEGER scalmode

   AmpScal scales the amplitude (in K) of a source according
   to a specified flux(in Jy). The input is usually in K,
   the output amplitude is either K, K/Jy or Jy/K etc.
   depending on the scalmode (see scalunit for valid scalmode's)

   Input:
       amp      --  amplitude in K
       jyflux   --  flux in Jansky's
       scalmode --  scaling mode (see FUNCTION scalunit)
   Output:
       amp      --  amplitude in K, K/Jy, Jy/K etc.
\endtt}
\par}
\module{angles}%
\noindent Convert angle in degrees/hours to a string
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvsubs.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} units, conversion, utilities
\par{\tenpoint
{\eightpoint\begintt
        character*13 function angles(angle)

        implicit none
        double precision angle

  Convert an angle expressed in degrees or hours into a string.

  Input:
    angle      Angle in floating point format.
\endtt}
\par}
\module{arctan}%
\noindent Arctangent function
\newline \ 
\newline \abox{File:} \$MIR/src/subs/utilities.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} utilities
\par{\tenpoint
{\eightpoint\begintt
      real   function arctan( y, x )
      real   y, x

 This is like the atan2 intrinsic function, except that it gives the proper
 answer if x=0 (pi/2 for y>0 and 3pi/2 for y<0)

 Input:
   x,y:     x and y coordinates
\endtt}
\par}
\module{aricomp}%
\noindent Parse a Fortran-like expression.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ari.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} mathematics
\par{\tenpoint
{\eightpoint\begintt
        subroutine ariComp(exp,paction,type,Buf,Buflen,RBuf,RBufLen)

        implicit none
        character exp*(*)
        integer type,BufLen,RBuflen
        integer Buf(Buflen)
        real    RBuf(RBufLen)
        external paction

  AriComp parses a FORTRAN-like expression, breaking it up into
  a sequence of reverse Polish tokens. The Fortran expression (given
  as a character string) can contain all normal FORTRAN numeric operators
  and functions, as well as constants and variables.

  AriComp calls a user written action routine, to determine information
  about "variables".

  See AriExec to see how to evaluate the expression after it has been
  parsed.

  Inputs:
    exp        The expression to parse. This should be a FORTRAN-like
               real expression.
    paction    Routine called to determine what each variable represents.
    buflen     Length of integer buffer.
    rbuflen    Length of real buffer.

  Outputs:
    type       Indicates status, and whether a scalar or vector expression
               was parsed. This can take a value of error, scalar or
               vector.
    buf        Sequence of tokens in reverse polish. The first four locations
               of buf are special, however (used by ariExec, caller
               will not be interested):
                 Buf(1)  Reserved.
                 Buf(2)  Reserved.
                 Buf(3)  Number of constants held at start of RBUF.
                 Buf(4)  Number of tokens held in BUF, including these 4.
    rbuf       Constants.

  This routine returns with a parsing error is found. However it aborts
  on buffer overflows. It has some internal buffers, which hopefully are
  big enough, but BUF and RBUF can also be too small.
\endtt}
\par}
\module{ariexec}%
\noindent Evalute an expression, previously parsed by AriComp.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ari.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} mathematics
\par{\tenpoint
{\eightpoint\begintt
        subroutine ariExec(vaction,N,Buf,BufLen,RBuf,RBufLen,Index)

        implicit none
        integer N,BufLen,RBufLen,Index
        integer Buf(BufLen)
        real RBuf(RBufLen)
        external vaction

  AriExec evaluates a FORTRAN-like expression, which has been parsed
  by AriComp.

  AriExec takes the reverse polish list of tokens in Buf, and proceeds
  to evaluate the expression. VACTION is called to get the values of
  any scalars or vectors. The result of the expression is returned to
  the caller starting at RBUF(INDEX).

  Inputs:
    VACTION    Action routine called to get the vaslue of scalars or vectors.
    N          Vector length. Any value can be used here if there is
               no vector processing.
    BUF        List of tokens, determined by ariComp.
    BUFLEN     Total length of BUF. Its not really used.
    RBUFLEN    Total length of RBUF.

  Input/Output/Scratch:
    RBUF       RBUF contains some constants at the head of the
               array, used by AriExec. These are unchanged on exit.
               The result of the evaluation is returned to the caller
               starting at RBUF(INDEX). Otherwise RBUF is used to hold
               intermediate results.

  Output:
    INDEX      Index into RBUF of the result of the expression.
\endtt}
\par}
\module{assert}%
\noindent Assert a condition, otherwise bug out
\newline \ 
\newline \abox{File:} \$MIR/src/subs/assert.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} error-handling
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE assert (cond,mesg)

        CHARACTER mesg*(*)
        LOGICAL   cond

   Assert that 'cond' is .TRUE., otherwise bail out by calling
   'bug' with 'f' and the mesg as provided in the arguments.
   Although an IF-statement will often do just as well, this makes
   the code a bit mode readable:
   Example:
       CALL assert(file.NE.' ','No filename specified')

   Input:
       cond    -- logical to test, if FALSE bail out
       mesg    -- message passed to bug
\endtt}
\par}
\module{assertf}%
\noindent Assert a file existence condition, otherwise bug out
\newline \ 
\newline \abox{File:} \$MIR/src/subs/assert.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} error-handling, file i/o
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE assertf (name,cond,mesg)

        CHARACTER name*(*), mesg*(*)
        LOGICAL   cond

   Assert that a file exists or does not. Useful to check after
   the keyroutines are called, to prevent lot's of CPU burning
   before program decides it couldn't write it's information.

   Example:
       CALL keya('in',fin,' ')
       CALL assertf(fin,.TRUE.,'File not present')
       CALL keya('out',fout,' ')
       CALL assertf(fout,.FALSE.,'File present')

   Input:
       name  -- name of file to test for
       cond  -- if TRUE file must exist, if FALSE file must not exist
       mesg  -- message passed to bug
\endtt}
\par}
\module{asserti2}%
\noindent Assert a condition, otherwise bug out
\newline \ 
\newline \abox{File:} \$MIR/src/subs/assert.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} error-handling
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE asserti2 (i1,i2,mesg)

        INTEGER   i1, i2
        CHARACTER mesg*(*)

   Assert that I1 >= I2, otherwise bail out by calling
   'bug' with the type 'f' and mesg as provided in the arguments.
   Is often used to check if enough memory in arrays for operations
   Example:
       CALL asserti2(MAXBUF,naxis1*naxis2,'MAXBUF vs. naxis1*naxis2')

   Input:
       i1      -- first integer, often an available size (of an array)
       i2      -- second integer, often size needed (for the array)
       mesg    -- message passed to bug
\endtt}
\par}
\module{atod}%
\noindent Convert a string into a double precision.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        subroutine atod(string,d,ok)

        implicit none
        character string*(*)
        double precision d
        logical ok

  Convert a string into its corresponding double precision.

  Input:
    string     The ascii string, containing the integer.
  Output:
    result     The double precision value.
    ok         This will be true if the decoding succeeded.
\endtt}
\par}
\module{atoi}%
\noindent Convert a string into an integer.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        subroutine atoi(string,result,ok)

        implicit none
        character string*(*)
        integer result
        logical ok

  Convert a string into its corresponding integer.

  Input:
    string     The ascii string, containing the integer.
  Output:
    result     The integer value.
    ok         This will be true if the decoding succeeded.
\endtt}
\par}
\module{axistype}%
\noindent Find the axis label and plane value in user friendly units
\newline \ 
\newline \abox{File:} \$MIR/src/subs/axistype.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} plotting
\par{\tenpoint
{\eightpoint\begintt
        subroutine AxisType(lIn,axis,plane,ctype,label,value,units)

        implicit none
        integer lIn,axis,plane
        character ctype*9,label*13,units*13
        double precision value

 Find the axis label and plane value in user friendly units.

  Inputs:
    lIn        The handle of the image.
    axis       The image axis.
    plane      The image plane along this axis.
  Output:
    ctype      The official ctype for the input axis.
    label      A nice label for this axis.
    value      The value at the plane along this axis.
    units      User friendly units for this axis.
\endtt}
\par}
\module{basant}%
\noindent Routine to determine antennas from baseline number.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/basant.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} calibration, uv-i/o, uv-data, utilities
\par{\tenpoint
{\eightpoint\begintt
      subroutine basant(baseline, ant1, ant2)
      implicit none
      integer ant1, ant2
      double precision baseline

  BasAnt is a Miriad routine that returns the antenna numbers that are
  required to produce the input baseline number.  According to the
  Miriad programming manual, the relationship between the baseline
  and the antenna numbers is defined as
           $$``baseline'' = (``ant1'' * 256) + ``ant2''$$.

  Note:   ``ant1'' is ALWAYS less than ``ant2''.

  Input:
    baseline The baseline number.  This value is usually obtained
             as the fourth element in the double precision array
             ``preamble'' (for example, see ``uvread'').

  Output:
    ant1     The first (smaller) antenna number.
    ant2     The second (larger) antenna number.
\endtt}
\par}
\module{binfid}%
\noindent Adjust window size and fiddle bin sizes for spacial avg'ing
\newline \ 
\newline \abox{File:} \$MIR/src/subs/zeebin.for
\newline \abox{Responsible:} Neil Killeen
\newline \abox{Keywords:} profile analysis
\par{\tenpoint
{\eightpoint\begintt
      subroutine binfid (iwin, aveop, size, axis, bin, blc, trc, nbin)
      integer size, axis, bin, blc, trc, nbin, iwin
      character aveop*1

 Adjust the size of the window so that the bin width fits
 an integer number of times and fiddle the bin sizes for
 spatial averaging

     Input:
        iwin     i    Window number
        aveop    c   'a' or 's' for averaging or summing
        size     i    Size of axis in (unbinned) image
        axis     i    Axis number 
     Input/output:
        bin      i    Bin width.  On output, for averaging, equal to
                      the window size for spatial axes
        blc,trc  i    Window corners.
     Output:
        nbin     i    Number of binned pixels in window
\endtt}
\par}
\module{binrd2}%
\noindent For vxy images, apply specified binning criterion
\newline \ 
\newline \abox{File:} \$MIR/src/subs/zeebin.for
\newline \abox{Responsible:} Neil Killeen
\newline \abox{Keywords:} profile analysis
\par{\tenpoint
{\eightpoint\begintt
      subroutine binrd2 (h1, h2, rowdim, datdim, bin, blc, trc, nbin, 
     *                   row, data1, data2)
      integer h1, h2, bin(3), blc(3), trc(3), nbin(3), rowdim, datdim
      real row(rowdim), data1(datdim), data2(datdim)

 Read one region from two 3-D images, applying binning criterion 
 as specified.   Output arrays are one dimensional, with 
 successively binned rows joined end to end.  Designed for
 images that are in vxy order, so that binned spectra follow
 each other in output

     Input:
       h1,h2    i    Handles for input images
       rowdim   i    SIze of ROW
       datdim   i    Size of DATA*
       bin      i    Binning size for three axes (v,x,y).  For the x 
                     and y axes, these binning sizes must fit an
                     integral number of times into the window. For
                     the spectral dimension (first) this is not vital
       blc,trc  i    Window describing region to read in (v,x,y)
       nbin     i    Number of binned pixels in window (v,x,y)
     Input/output:
       row      r    Scratch array to hold one full row of data 
       data1,2  r    Output binned data. All locations likely to
                     be used must be initialized to 0.0
                     Binned spectra stacked end to end.
\endtt}
\par}
\module{binup}%
\noindent Bin up data in array
\newline \ 
\newline \abox{File:} \$MIR/src/subs/zeebin.for
\newline \abox{Responsible:} Neil Killeen
\newline \abox{Keywords:} profile analysis
\par{\tenpoint
{\eightpoint\begintt
      subroutine binup (datdim, bindim, data, blc, trc, bin, norm, 
     *                  ipt, binned, wrt)
      integer blc, trc, ipt, bin, datdim, bindim
      real data(datdim), norm, binned(bindim)
      logical wrt

 Bin up data in array

     Input:
        datdim   i   Size of DATA
        bindim   i   Size of BINNED
        data     r   Full array of data (starting at location 1)
        blc,trc  i   Array window to binup
        bin      i   Number of pixels to bin together
        norm     r   Additional multiplicative normalization factor
                     Binned data are normalized by BIN*NORM
     Input/output:
        ipt      i   On input, first location in output array to use
                     On output, last location in output array used
        binned   r   Output binned spectrum.  Normalization
                     of each output point is by the product of the
                     number of binned points and NORM
                     Deals with non-integral number of bins in array

                     BINNED must be initialized to 0.0 on first entry
\endtt}
\par}
\module{blname}%
\noindent Returns baseline name
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Keywords:} baselines
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        CHARACTER*5 FUNCTION blname(bl)
        INTEGER bl

       returns a human readable string of the form 'A1-A2' for
       a baseline number A1*256+A2

       Input:
           bl      integer
\endtt}
\par}
\module{boxes}%
\noindent Summary of region of interest routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/boxes.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} region-of-interest
\par{\tenpoint
{\eightpoint\begintt
  These routines are a collection which allow the user to specify a
  fairly arbitrary region of interest, and for the programmer to retrieve
  these specifications in a reasonably convenient form. There are six
  programmer callable routines:

       subroutine BoxInput(key,file,boxes,maxboxes)
       subroutine BoxMask(tno,boxes,maxboxes)
       subroutine BoxSet(boxes,naxis,nsize,flags)
       subroutine BoxInfo(boxes,naxis,blc,trc)
       logical function BoxRect(boxes)
       subroutine BoxRuns(naxis,plane,flags,boxes,
    *                  runs,maxruns,nruns,xminv,xmaxv,yminv,ymaxv)

  BoxInput     This reads the region of interest from the task parameters.
  BoxMask      "AND" in a mask from a data file.
  BoxSet       The programmer calls this to indicate the size of the
               image of interest.
  BoxInfo      Returns information about the region currently selected.
  BoxRect      This returns .true. if the selected region is purely
               rectangular (i.e. describable by blc and trc).
  BoxRuns      The programmer calls this to retrieve the region-of-interest
               selected for a particular plane.

  The BOX routines work by reading the region sepcified on the command line
  and breaking it into an intermediate form, stored in the "boxes" array.
  This intermeidate form consists of a number of subregion specifications
  which are ANDed and ORed together to produce the output region. The
  subregions can consist of IMAGE (a rectangular subregion of a range of
  planes), BOX (a number of rectangular subregions of a range of planes),
  POLY (a polygonal region of a range of planes) and MASK (an arbitrary
  region, specified by a mask file). A positive value (the norm) indicates
  the subregion is "ORed", whereas a negative value (rare) indicates it
  is "ANDed". Each shape is described by XMIN,XMAX,YMIN,YMAX,ZMIN,ZMAX
  which gives the cube which bounds the shape. In some cases these are
  unknown, In this case, they are set to zero.

  Some shapes require extra DATA (the size of which is given by SIZE):
    BOX  This requires the blc and trc for the corners of the boxes,
         stored as (xmin,ymin),(xmax,ymax). For N boxes, SIZE=4*N.
         The boxes are sorted in increasing order of xmin.
    POLY This also gives the (x1,y1),(x2,y2) coordinate pair of each of
         the line segments which make the polygon (except horizontal segments
         are discarded). For a poly made of N (non-horizontal) line segments,
         SIZE=4*N. The line segments are sorted in increasing order of
         min(x1,x2).
    MASK Additional info is the handle of the mask file.

  The routine BoxRuns returns the region of a particular plane that was
  selected. This is returned in "runs", which is a table of entries of
  (j,xmin,xmax). One entry indicates that
  pixels (xmin,j) to (xmax,j) are selected. There may be multiple (or
  zero) entries for a particular value of j, though all entries are
  non-overlapping. The table is in increasing j and xmin.
\endtt}
\par}
\module{boxinfo}%
\noindent Determine bounding box of the region of interest.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/boxes.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} region-of-interest
\par{\tenpoint
{\eightpoint\begintt
        subroutine BoxInfo(boxes,naxis,blc,trc)

        implicit none
        integer boxes(*),naxis,blc(naxis),trc(naxis)

  This returns the bounding box of the region of interest.

  Input:
    boxes      This contains an intermediate form of the subregion
               specified by the user.

  Output:
    blc,trc    Min and max values of the region selected along each axis.
\endtt}
\par}
\module{boxinput}%
\noindent Read command line box specification.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/boxes.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} region-of-interest
\par{\tenpoint
{\eightpoint\begintt
        subroutine BoxInput(key,file,boxes,maxboxes)

        implicit none
        character key*(*),file*(*)
        integer maxboxes,boxes(maxboxes)

  Read the box specification from the command line.

  Input:
    key        The keyword associated with the parameter, generally
               "region". If this is a blank string, then the user
               input routines are not called, and the default region
               of interest is used.
    file       Name of the Miriad data-set used to extrac coordinate
               transformation info (in particular crval,crpix and cdelt).
    maxboxes   The size of the boxes array.
  Output:
    boxes      An intermediate form of the boxes specification. This is
               used by subsequent BOX routines to
\endtt}
\par}
\module{boxmask}%
\noindent AND in a mask to the region of interest.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/boxes.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} region-of-interest
\par{\tenpoint
{\eightpoint\begintt
        subroutine BoxMask(tno,boxes,maxboxes)

        implicit none
        integer tno,maxboxes,boxes(maxboxes)

  Indicate that a mask is to be applied to the data.

  Input:
    tno        The handle of the input mask.
    maxboxes   Size of the boxes array.
  Input/Output:
    boxes      The boxes specification.
\endtt}
\par}
\module{boxnr}%
\noindent Find in which box the input value lies.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/utilities.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} utilities
\par{\tenpoint
{\eightpoint\begintt
      integer          function boxnri ( i, iedges, nedges )
      real             function boxnrr ( r, redges, nedges )
      double precision function boxnrd ( d, dedges, nedges )
      integer          i, iedges(nedges)
      real             r, redges(nedges)
      double precision d, dedges(nedges)
      integer          nedges

 The array i/r/dedges defines a set of boxes. Boxnr then returns the index of
 the box in which i/r/d lies. For example, if iedges has the values 0, 2, 5,
 10, 50 then boxnr becomes 1 if i=1, 2 if i=2, 2 if i=4, 4 if i=45 etc. Values
 on the edges are supposed to lie in the box above the value. Values below the
 first edge are supposed to lie in box 0, values above the last edge are in
 box nedges.
\endtt}
\par}
\module{boxrect}%
\noindent Determine in a region-of-interest is rectangular.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/boxes.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} region-of-interest
\par{\tenpoint
{\eightpoint\begintt
        logical function BoxRect(boxes)

        implicit none
        integer boxes(*)

  This returns .true. if the region described by the boxes array is purely
  rectangular (i.e. describable by blc and trc).

  Input:
    boxes      Integer array describing intermediate form of the region
               selected.
  Output:
    BoxRect    True if the region is rectangular.
\endtt}
\par}
\module{boxruns}%
\noindent Return region of interest in "runs" form.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/boxes.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} region-of-interest
\par{\tenpoint
{\eightpoint\begintt
        subroutine BoxRuns(naxis,plane,flags,boxes,
     *                  runs,maxruns,nruns,xminv,xmaxv,yminv,ymaxv)

        implicit none
        character flags*(*)
        integer naxis,plane(naxis)
        integer boxes(*),maxruns,nruns,runs(3,maxruns)
        integer xminv,xmaxv,yminv,ymaxv

  This returns the caller a runs specification for the particular plane
  that the user is currently interested in.

  Input:
    naxis      The dimension of "plane".
    plane      The index, along the third, fourth, etc dimension of the
               cube to be accessed.
    boxes      Some intermediate form of the boxes specified by the user.
    maxruns    Max number of runs that this program can cope with.

  Output:
    runs       Runs specifications.
    nruns      Number of runs.
    xmin,ymin) Minimum regions containing the area selected.
    xmax,ymax)
\endtt}
\par}
\module{boxset}%
\noindent Set default region of interest.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/boxes.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} region-of-interest
\par{\tenpoint
{\eightpoint\begintt
        subroutine BoxSet(boxes,naxis,nsize,flags)

        implicit none
        integer naxis,nsize(naxis),boxes(*)
        character flags*(*)

  This checks the box specification given by the user, and applies
  defaults.

  Input:
    naxis      The dimension of nsize, minv and maxv.
    nsize      The dimensions of the data set.
    flags      Character string giving some extra options. Flags are:
                 'q'   Default region is the inner quarter.
                 '1'   Default region is the first image.
                 's'   Give warning if region-of-interest is not a regular
                       shape.
  Input/Output:
    boxes      This contains an intermediate form of the subregion
               specified by the user. On output, certain defaults are
               filled in.
\endtt}
\par}
\module{bselect}%
\noindent Find if given antenna is in given baseline code
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvsubs.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} uv-data, uv-selection, antennas, baselines
\par{\tenpoint
{\eightpoint\begintt
        logical function bselect(base,ants)
        implicit none
        double precision base
        character*(*) ants
                                       !256*ant1 + ant2
                                       !ants in config (string)

  Compares the variable 'baseline' attached to each baseline with
  the string 'ants' which describes the baseline configuration
  that is being selected.  BSELECT returns true if base(from uvread)
  is one of ants. The baseline configuration is described in the
  VLA format:
     antennas  WITH  antennas  (if WITH is missing, both sides are equal)
      where antennas is a list of antenna numbers  ant1 ant2 ...  antn
      or    antennas can be  *   which means all antennas
      or    antennas can be  * - antn antm  which means all ants - some
  Inputs:
    base       baseline selector from uvread.
    ants       antenna description string.
\endtt}
\par}
\module{bsrcha}%
\noindent Search a list of strings for a particular string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/bsrch.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} search, binary-search
\par{\tenpoint
{\eightpoint\begintt
        integer function BSrcha(key,keys,nkeys)

        implicit none
        integer nkeys
        character key*(*),keys(nkeys)*(*)

  Search for a particular string in a list of strings. Return the
  index of the string. If the string is not found, return 0.
  A binary search is used.

  Input:
    key        The string to search for.
    keys       A list of strings. These are assumed to be in alphabetic
               order to allow a binary search.
    nkeys      The number of strings.

  Output:
    bsrcha     Either the index of the string (if it is found in the
               list), or zero.
\endtt}
\par}
\module{bsrchi}%
\noindent Search a list of integers for a particular integer.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/bsrch.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} search, binary-search
\par{\tenpoint
{\eightpoint\begintt
        integer function BSrchi(key,keys,nkeys)

        implicit none
        integer nkeys
        integer key,keys(nkeys)

  Search for a particular integer in a list of integers. Return the
  index of the integer. If the integer is not found, return 0.
  A binary search is used.

  Input:
    key        The integer to search for.
    keys       A list of integers. These are assumed to be in alphabetic
               order to allow a binary search.
    nkeys      The number of integers.

  Output:
    bsrchi     Either the index of the integer (if it is found in the
               list), or zero.
\endtt}
\par}
\module{bug}%
\noindent Give an error message, and abort if needed.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/bug.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} error-handling
\par{\tenpoint
{\eightpoint\begintt
        subroutine bug(severity,message)

        implicit none
        character severity*1,message*(*)

  Give an error message, and optionally abort.
  For fatal errors (severity='f') the programname is also listed.

  Input:
    severity   A single character. This can be 'i' (informational),
               'w' (warning), 'e' (error) or 'f' (fatal). 
               With a warning, the program just notes an
               unusual or possibly dangerous situation. With an error,
               some error is noted, and corrected. With a fatal error,
               not corrective action is possible, and the program aborts.
               If bug is called with a fatal error, it never returns.
    message    The error message to give.
\endtt}
\par}
\module{bugno}%
\noindent Give a error message associated with a particular error number.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/bug.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} error-handling
\par{\tenpoint
{\eightpoint\begintt
        subroutine bugno(severity,errno)

        implicit none
        character severity*1
        integer errno

  Output the error message associated with the particular error number.

  Input:
    severity   Error severity. Can be 'i', 'w', 'e' or 'f'.
    errno      The error number.
\endtt}
\par}
\module{caclose}%
\noindent Close a calibration set
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE caclose(tno)

        INTEGER tno

    CAclose closes a previously opened calibration set.  Omitting this
    call can result in chaos.

       inputs:
           tno -- the calibration set handle
\endtt}
\par}
\module{cadread}%
\noindent Read data from a calibration set
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE cadread(tno, i, Rtime, Rdata, Rflag, Sindex, err)

        INTEGER tno, i, err
        REAL Rtime, Rdata(*)
        INTEGER Rflag(*), Sindex(*)

    CAdread reads raw uncalibrated data points from a calibration data
    set.  Arguments are:

  Inputs:
       tno     -- calibration set
       i       -- data slot

  Outputs:
       Rtime   -- sampling time
       Rdata   -- correlation data
       Rflag   -- flagging data
       Sindex  -- index name of associated source (0 if not used)
       err     -- error output

       err = 0 --> nonexistent slot
       err = 1 --> no errors detected
\endtt}
\par}
\module{cadwrite}%
\noindent Write data into a calibration set
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE cadwrite(tno, i, Rtime, Rdata, Rflag, Sindex)

        INTEGER tno, i
        REAL    rtime, rdata(*)
        INTEGER rflag(*), sindex(*)

    CAdwrite writes raw uncalibrated data points to a calibration data
    set.  It also writes an index to the source name of the associated
    data poin. Time ordering is not required.  Arguments are:

  Inputs:
       tno     -- calibration set
       i       -- data slot
       Rtime   -- sampling time
       Rdata   -- correlation data
       Rflag   -- flagging data
       Sindex  -- index name of associated source (0 if not used)
\endtt}
\par}
\module{caerror}%
\noindent Write a calibration I/O error
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        subroutine CAerror(iostat, string)

        integer iostat
        character*(*) string

   CAerror calls the error routine 'bug'

   inputs:
       iostat      -- error number, obtained from previous i/o operation
       string      -- error message string
\endtt}
\par}
\module{caflag}%
\noindent Flag data in a calibration set
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        subroutine CAflag(tno, i, Rflag)

        integer tno, i
        integer Rflag(*)

    CAflag writes only the flagging information.

  Inputs:
       tno     -- calibration set
       i       -- data slot
       Rflag   -- flagging data
\endtt}
\par}
\module{calget}%
\noindent Routine to retrieve an interpolated calibrator flux.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tabflux.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} calibration, flux
\par{\tenpoint
{\eightpoint\begintt
      subroutine calget(FileName, source, freq, delfreq, day, deldate,
     *  flux, iostat)

      implicit none
      character FileName*(*), source*(*)
      integer iostat
      real freq, delfreq, deldate, flux
      double precision day

 Input:
   FileName The name of the calibration file.  Default is
            MIRCAT/cals.fluxes.
   source   The name of the calibrator source to match.  No default.
   freq     The observation frequency (GHz) (default of 0.0 means
            that a match occurs at any frequency).
   delfreq  A range of frequency (in GHz) to bracket the freq
            parameter.  If ``freq'' is 0.0, then this term is ignored.
            The value of ``delfreq'' is used to range matching
            frequencies such that a match occurs when
            [freq-(delfreq/2) <= freq[table] <= freq+(delfreq/2)].
   day      The date of the observation to match (default is the
            current date).  If day is = 0, then the current date is
            used; if the date is less than the earliest matching date
            or later than the latest matching date, then the nearest
            matching date is used.  If neither of these apply, than the
            two nearest observation dates are used to interpolate the
            flux over time.  Day MUST be a Julian day number.
   deldate  A range of time (in Julian days) to bracket the date input.
            The value of ``deldate'' is used to range matching dates
            such that a match occurs when
            [day-(deldate/2) <= day[table] <= day+(deldate/2)].
   flux     The lower limit of fluxes to consider as a match
            (default is 0.0 and implies all matching fluxes).

 Output:
   source   The name of the first matched source.  This may not have
            the same value as on input.
   freq     The freq of the matched observation.  This may not
            have the same value as on input and has no relation to
            the determined flux value.  If the flux is interpolated
            over time between two values, then freq is set to 0.0 on
            output.
   day      The day of the matched observation.  This will not have
            the same value as on input, unless the flux is the
            interpolation between two values.
   flux     The flux of the matched observation.
   iostat   An error integer.  Iostat = 0 means no error;
            -1 if there are no data found in the file FileName;
            -2 if an EOF; -3 if no source name match; -4 if no flux at
            desired frequency; and -5 if the date of the latest flux
            measurement is longer than 4 years.
\endtt}
\par}
\module{caopen}%
\noindent Open a calibration set
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE caopen(tno,dataname,time0,nbl,base,
     -                    version,status)

        INTEGER          tno, base(*), nbl, version
        CHARACTER*(*)    dataname, status
        DOUBLE PRECISION time0

    inputs (always)
       dataname -- the name of the data set to be opened
       status   -- either 'old', 'new' or 'append'
    outputs/inputs (depending on 'new'/'append' or 'old' in status)
       tno      -- the calibration set handle
       time0    -- time offset
       nbl      -- the number of baselines
       base     -- an array of nbl baseline pairs (see findbase)
       version  -- version as read/write from/to disk

    If any items in the data set are read and then written (or the other
    way around) then either the data set must be closed and reopened in
    between, or the data set must be opened twice.  This should be fixed
    someday.

  Rdata is opened iff Rtime is opened, and a few others too.
\endtt}
\par}
\module{casread}%
\noindent Read source index data
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        subroutine CAsread(tno, i, name, plstuff, err)

        integer   tno, i
        character name*(*)
        real      plstuff(4)
        integer   err

       CAsread reads the multiple source names, and some source
       associated values

   Inputs:
       tno     -- calibration set handle
       i       -- index slot
   Output:
       name    -- name of source
       plstuff -- associate source stuff
       err     -- error code
\endtt}
\par}
\module{caswrite}%
\noindent Write source index data
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        subroutine CAswrite(tno, i, name, plstuff)

        integer   tno, i
        character name*(*)
        real      plstuff(4)

       CAswrite writes the multiple source names, and a few 
       variables associated with each source. Mainly used for
       planets (size,temp) or unresolved calibrators (flux scale)

   Inputs:
       tno     -- calibration set handle
       i       -- index slot
   Output:
       name    -- name of source
       plstuff -- 4 numbers for each source name
\endtt}
\par}
\module{chkpoly}%
\noindent Check if the current polynomial is set
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calpoly.for
\newline \abox{Keywords:} calibration, polynomials
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        LOGICAL FUNCTION chkpoly(code)

        IMPLICIT NONE
        CHARACTER  code*(*)

   Input:
       code    -- 4-character slot code
\endtt}
\par}
\module{code2s}%
\noindent Convert ascii code to integer slot code
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} calibration, slotcoden
\par{\tenpoint
{\eightpoint\begintt
        INTEGER FUNCTION code2s (code)

        CHARACTER code*(*)

   Converts the 4 character slot code to integer slotcode
   Note that the code must be in UPPER CASE.
   Whenever the third character is a digit (1 thru 8 are allowed)
   the second character (legal are U or L) is ignored.

   Input:
       code   -- 4 character code ($,$$,W$$$)
                 Legal values for $, $$, and $$$ are:
                 $ ..... A, P
                 $$ .... U, L
                 $$$ ... 1, 2, 3, 4, 5, 6, 7, 8
   Output:
       code2s -- integer (1..20)
\endtt}
\par}
\module{convl}%
\noindent Performs the convolution of the image with the beam.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/convl.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} convolution, fft
\par{\tenpoint
{\eightpoint\begintt
        subroutine Convl(in,out,n,nx,ny,Runs,nRuns,Beam,n1,n2)

        implicit none
        integer n,nx,ny,n1,n2,nRuns,Runs(3,nRuns)
        real in(n),out(n),Beam(n2,n1/2+1)

  Convolve the input by the beam, returning it in the output. Both the
  input and output are only those portions of the image that are of
  interest. These are described by "runs" arrays, as produced by
  BoxRuns.

  Input:
    in         The input image. Only the pixels within the
               region-of-interest are included.
    n          Total number of pixels in the region-of-interest.
    nx,ny      The bounding size of the input image.
    Runs       The runs describing the region-of-interest in the input
               image.
    nRuns      The total number of runs.
    Beam       The FFT of the beam, as produced by ConvlIni.
    n1,n2      The size of the beam, in x and y.
  Output:
    out        The resultant convolved image.
\endtt}
\par}
\module{convlini}%
\noindent Initialize the convolution routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/convl.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} convolution, fft
\par{\tenpoint
{\eightpoint\begintt
        subroutine ConvlIni(lu,Out,n1,n2,phat,ic,jc)

        implicit none
        integer lu,n1,n2,ic,jc
        real Out(n2,n1/2+1),phat

  The Convolution routines perform an FFT-based convolution of two
  images (usually a map and a beam). This routine initializes the 
  convolution routines, and performs an FFT of the beam.

  Input:
    n1,n2      Size of the input beam. Must be a power of 2.
    ic,jc      Reference pixel of the input beam.
    lu         Handle of the MIRIAD file containing the beam. The beam
               is assumed to be even, i.e.
                 Beam(ic+i,jc+j) .eq. Beam(ic-i,jc-j)
    phat       Prussian hat parameter.

  Output:
    Out        The output, transformed, transposed version of the input.
\endtt}
\par}
\module{corrfun}%
\noindent Generate the gridding convolution correction function.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/grid.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} gridding, interpolation
\par{\tenpoint
{\eightpoint\begintt
        subroutine corrfun(func,phi,n,width,alpha)

        implicit none
        integer n
        character func*(*)
        integer width
        real phi(n),alpha

  Calculate the gridding correction function.

  Inputs:
    func       Gridding function used. Currently this can only be
               'spheroidal'.
    n          Width of image.
    width      Width of gridding function used.
    alpha      An extra parameter specifying the gridding function.

  Output:
    phi        Gridding correction function.

  References:
    F.R. Schwab "Optimal gridding of visibility data in radio interferometry",
      Indirect Imaging, J.A. Roberts, ed., Cambridge Univ. Press, 1984.
\endtt}
\par}
\module{ctrl}%
\noindent Manipulating a control panel.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ctrl.for
\newline \abox{Responsible:} Jim Morgan
\par{\tenpoint
{\eightpoint\begintt
  The control panel routines (all with names starting with Ctrl) are used
  to open up a connection to a control panel server (possibly on a remote
  machine), allow the caller to define a number of buttons, cursors and
  sliders, that the caller wants the user to control, and then lets the
  caller and the user interact with each other. Associated with each
  button, etc, is its current value (or state).
  A button can have several states -- the control panel will show the current
  state as the label on the button. For example "ON" and "OFF". The value
  of a button is the number of the state. These vary from 0 to n-1 (for
  a button with n states), as defined by CtrlDef.
  A slider takes on a value from 0 to 100, which the user can change.
  A cursor takes on two values, both from 0 to 100.
  Each button, cursor or slider has a caller-defined name, which the caller
  uses for identification. The caller can inquire if a button, slider or
  cursor has change its value.
\endtt}
\par}
\module{ctrlchck}%
\noindent Check if a particular buttons has been pushed.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ctrl.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} user-interaction, control-panel
\par{\tenpoint
{\eightpoint\begintt
        subroutine CtrlChck(name,changes,val1,val2)

        implicit none
        character name*(*)
        integer changes,val1,val2

  This checks if a particular button has been pressed, and returns
  its current value.

  Input:
    name       The name of the item.
  Output:
    changes    The number of times the item has been changed.
    val1,val2  Two values associated with the item.
\endtt}
\par}
\module{ctrlclr}%
\noindent Clear any memory in the control panel of buttons being pressed.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ctrl.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} control-panel, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine CtrlClr

        implicit none

  CtrlClr causes the control panel to forget about any buttons or sliders
  that have changed their value.
\endtt}
\par}
\module{ctrldef}%
\noindent Define a control panel button, etc.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ctrl.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} user-interaction, control-panel
\par{\tenpoint
{\eightpoint\begintt
        subroutine CtrlDef(name,type,values,nvalues)

        implicit none
        integer nvalues
        character name*(*),type*(*),values(nvalues)*(*)

  CtrlDef defines a particular button, etc, that is to appear on the
  control panel.

  Inputs:
    Name       The name of the item.
    type       The type. This can be 'button','slider','cursor'.
    values     The values that the think can take on.
    nvalues    Number of values.
\endtt}
\par}
\module{ctrlfin}%
\noindent Close down the control panel.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ctrl.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} user-interaction, control-panel
\par{\tenpoint
{\eightpoint\begintt
        subroutine CtrlFin
        implicit none

  CtrlFin closes down the control panel, releasing any resources allocated
  by the control panel routines.
\endtt}
\par}
\module{ctrlinit}%
\noindent Initialise the panel panel.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ctrl.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} control-panel, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine CtrlInit(name,status)

        implicit none
        character name*(*)
        integer status

  This opens up a connection to the "control panel". Currently this is
  a TCP/IP socket to a "panel" server.

  Input:
    name       Name of the host running the panel server.
  Output:
    status     Completion status. Zero indicates success. Other values
               indicate some failure in attempted to connect to the server.
\endtt}
\par}
\module{ctrlopen}%
\noindent Open the panel panel.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ctrl.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} control-panel, user-interaction
\par{\tenpoint
{\eightpoint\begintt
      subroutine ctrlopen(name, ctrl)

      implicit none
      character name*(*)
      logical ctrl

  This opens up a connection to the "control panel" used by a device.
  Currently this is a TCP/IP socket to a "panel" server accessed
  through the routine called ``panel'' in MIRIAD.

  Input:
    name       Name of the device used in TVOPEN.  This contains
               the name of the host running the panel server.
               This has the form:
                 type@name1  or  type@name1/name2
               Here ``name1'' and ``name2'' are the physical device
               names, or the name of the server (for network display
               servers).  ``Type'' is the device or server type.
               These are described in detail in the User's manual.
               If ``name2'' exists, this is used as the panel name;
               otherwise, ``name1'' is used.
  Output:
    ctrl       A logical flag that is true if the input device can
               drive a ctrl panel; otherwise, ctrl is false.
\endtt}
\par}
\module{ctrlset}%
\noindent Set the value of a control panel button, etc.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ctrl.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} user-interaction, control-panel
\par{\tenpoint
{\eightpoint\begintt
      subroutine ctrlset(name, values, nvalues)

      implicit none
      integer nvalues
      integer values(nvalues)
      character name*(*)

  CtrlSet changes the value for a particular button, etc, that appears
  on the control panel.  If the item type associated with name is a
  BUTTON, then only one value is accepted and represents the offset
  from the first BUTTON entry in the list for that name (ie.
  value(1) = 0 is the first entry for that BUTTON, value(1) = 1
  is the second entry, etc.).  The list entry pointed to by the offset
  will be moved to the current BUTTON.  If the item type is a CURSOR,
  then up to two values will be accepted and represent the X and Y
  positions of the CURSOR.  If only one value is present, then both
  X and Y will be set to that value.  Finally, if the item type is a
  SLIDER and only one value is present, then the current value of the
  SLIDER will be set to that value.  If two values are present, then
  these values represent the new lower and upper limits of the SLIDER.

  NOTE: This routine ONLY is useful AFTER a call to CtrlView!!
  If CtrlView has not yet been called, no action will be performed.

  Inputs:
    Name     The name of the previously defined control panel item.
             This is the same name (including case) of the panel item
             defined in CtrlDef.
    values   An integer array of values used for setting the item.
    nvalues  The size of the values array.
\endtt}
\par}
\module{ctrlview}%
\noindent Pop up the control panel on the workstation screen.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ctrl.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} control-panel, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine CtrlView

        implicit none

  Cause the control panel to be visible.
\endtt}
\par}
\module{ctrlwait}%
\noindent Wait for a button to be pressed.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ctrl.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} user-interaction, control-panel
\par{\tenpoint
{\eightpoint\begintt
        subroutine CtrlWait(name,changes,val1,val2)

        implicit none
        character name*(*)
        integer changes,val1,val2

  CtrlWait waits for a button, slider or cursor to change its value. If
  one or several buttons, etc, has previously changed, CtrlWait returns
  immediately, passing back the first button that it happens to find
  has changed.

  Output:
    name       The name of the item that changed.
    changes    The number of times the item has been changed.
    val1,val2  Two values associated with the item.
\endtt}
\par}
\module{dangle}%
\noindent Convert degrees/hours value into a formatted string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/angles.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} utility
\par{\tenpoint
{\eightpoint\begintt
      character*(*) function dangle(theta)

      implicit none
      double precision theta

  Converts an angle expressed in degrees or hours into a string.

  Inputs:
    theta    Angle in decimal degrees or hours.

  Output:
    dangle   Angle formated into a string with format:
               [+/-]DD:MM:SS.SS
\endtt}
\par}
\module{dayjul}%
\noindent Format a conventional calendar day into a Julian day.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/julday.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} julian-day, date, utilities
\par{\tenpoint
{\eightpoint\begintt
      subroutine dayjul(calday, julian)

      implicit none
      character calday*(*)
      double precision julian

  Convert to Julian date from calendar date. This is not to high
  accuracy, but it achieves the accuracy required. See "Astronomical
  Formulae for Calculators", Jean Meeus (Wiillmann-Bell Inc).
  The day is assumed to begin at 0 hours UT.

  Input:
    calday   (Gregorian) Calendar day (UT time).
             The input must be either of the form:
                     ``yymmmdd.dd''
             or:
                     ``yymmmdd:hh:mm:ss.s''
             The presence (or lack of) a colon (``:'') determines
             which format to decode.  In addition, the input string
             can be abbreviated with the missing entries internally
             filled with a value of zero.  In this case, the input
             date string MUST include at least one colon.  The
             presence (or lack) of the month string determines
             which end of the string is most significant.  For
             example: ``hh:mm:ss.s'' will return a value between
             0.0 and 1.0 days; ``mm:ss'' will return a value
             between 0.0 and 0.04 days; and an input of ``yymmmdd:hh''
             will return the same julian day as if the input was
             ``yymmmdd:hh:00:00.0''.
             Note that ``ss.s'' and ``:hh:mm:ss.s'' are INCORRECT
             input strings and may cause this routine to fail.

  Output:
    julian   Julian date.
\endtt}
\par}
\module{deghms}%
\noindent Write out ra and dec in hms/dms from input in degrees
\newline \ 
\newline \abox{File:} \$MIR/src/subs/deghms.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} coordinates
\par{\tenpoint
{\eightpoint\begintt
      subroutine deghms ( a, d, radec )
      real          a, d
      character*(*) radec

 deghms takes as input the right ascension and declination in degrees and
 constructs the string 'hh mm ss.ss sdd mm ss.ss'.
 characters 1 through 12 correspond to ra, 13 through 24 to dec.
 Care is taken that hours are between 0 and 24, minutes and seconds between
 0 and 60. I.e. ra=0 60 00.0 can not occur.
 Further, if minutes or seconds are less than 10, an extra 0 is added, i.e.
 9 minutes is written as 09 minutes.
 Finally, if hours or degrees are less than 10, there is no extra space, i.e.
 1 hours comes out as 'ra=1 00 00.0', not 'ra= 1 00 00.0' and -1 degree comes
 out as 'dec=-1 00 00.0', not 'dec=- 1 00 00.0'.

 Input:
   a:     right ascension in degrees
   d:     declination in degrees

 Output:
   radec: resulting output string
\endtt}
\par}
\module{delay}%
\noindent Delay a specified length of time.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/delay.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} terminal-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine delay(secs)
        implicit none
        real secs

  This delays a specified number of seconds before returning.

  Input:
    secs       The number of seconds to delay. It can be fractional.
\endtt}
\par}
\module{delim}%
\noindent Make sure value is between limits
\newline \ 
\newline \abox{File:} \$MIR/src/subs/utilities.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} utilities
\par{\tenpoint
{\eightpoint\begintt
      integer          function delimi ( ivalue, iminvalue, imaxvalue )
      real             function delimr ( rvalue, rminvalue, rmaxvalue )
      double precision function delimd ( dvalue, dminvalue, dmaxvalue )
      integer          iminvalue, imaxvalue, ivalue
      real             rminvalue, rmaxvalue, rvalue
      double precision dminvalue, dmaxvalue, dvalue

 This returns minvalue if value<minvalue, maxvalue if value>maxvalue and value
 otherwise.

 Input:
   value:     value to check
   minvalue:  minimum delimiting value
   maxvalue:  maximum delimiting value
\endtt}
\par}
\module{display}%
\noindent Load a map onto a TV device with user specified ranges.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tvsubs.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} image-data, tv, display
\par{\tenpoint
{\eightpoint\begintt
      subroutine display(map, Mx, Nx, Ny, chan, x0, y0, pmin, pmax)

      implicit none
      integer Mx, Nx, Ny, chan, x0, y0
      real map(Mx, Ny), pmin, pmax

  Displays an array of real numbers on the TV device scaled to the
  limits of the device.  An internal integer array is used to hold
  the scaled data and quietly accounts for very large array
  dimensions.

  Input:
    map(Nx,Ny)   Input real array of values.
    Mx           The maximum (or declared) X dimension of the array.
    Nx, Ny       X/Y working dimensions of the map array.
    chan         The TV channel to load the image.
    x0, y0       The lower left corner to start loading the image.
    pmin         The minimum value of the array.
    pmax         The maximum value of the array.

  Output:
    none
\endtt}
\par}
\module{dtoa}%
\noindent Convert a double precision value into a string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      character*(*) function dtoa(value, form, nsf)

      implicit none
      double precision value
      integer form, nsf

  Format a double precision value into a string using pgplot's pgnumb.

  Inputs:
    value         The value (double precision)
    form          How the number is formatted:
                    form = 0 - uses either decimal or
                               exponential notation
                    form = 1 - uses decimal notation
                    form = 2 - uses exponential notation
    nsf           Number of significant figures for output
                    (best range is between 1 and 6)
\endtt}
\par}
\module{enuff}%
\noindent Page output.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/txtio.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} text-i/o
\par{\tenpoint
{\eightpoint\begintt
      subroutine enuff (inc, nlines, iline, quit)

      implicit none
      integer nlines, iline, inc
      logical quit

     Ask the user every NLINES of output if he/she/it would like to
     see more output, or go home for the evening.

     Input:
       inc     i      Increment line counter by INC
       nlines  i      Number of lines per page
     Input/output:
       iline   i      Number of lines printed in current page, reset
                      after every NLINES
     Output:
       quit    l      .true. if user had enough
\endtt}
\par}
\module{equals}%
\noindent Check if input equals of a number of possible strings
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      logical function equals ( input, valid_strings )
      character*(*) input
      character*(*) valid_strings
      character*80  to_match

 Equals checks if the input string occurs in the comma-separated list of
 strings given by valid_strings. This effectively replaces a statement like
 "if(x.eq.'a'.or.x.eq.'b'.or.x.eq.'c'.or.x.eq.'d')" with
 "if(equals(x,'a,b,c,d'))".

 Input:
   input:         the string of which it has to be checked if it matches
   valid_strings: a comma-separated list of valid input strings
\endtt}
\par}
\module{evalpoly}%
\noindent Evaluate a polynomial
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calpoly.for
\newline \abox{Keywords:} calibration, polynomials
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        REAL FUNCTION evalpoly( t, code, bl, valid)
        IMPLICIT NONE

        INTEGER   bl, valid
        CHARACTER code*(*)
        REAL      t

   Evaluate a polynomial (assumed to have been read in using
   getpoly):

   Input:
       t         ordinate (time, freq)
       code      phase/amp code ('ALW?' etc.)
       bl        baseline [b=findbase(bl,base,nbl); b=1..nbl]
   Output:
       valid     validity; (0=ok  1=extrp. 2=extrp. across break)
                            -1 no pol present (P,A=1,0 returned)
       evalpoly  value of polynomial
\endtt}
\par}
\module{expi}%
\noindent Extract complex exponent of input in radians
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvsubs.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} complex-data, uv-data, visibility
\par{\tenpoint
{\eightpoint\begintt
      complex function expi(x)

  Return the complex exponent of input in radians.

  Input:
    x          real input (radians).
\endtt}
\par}
\module{fatpoint}%
\noindent Draw fat, visible points
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine fatpoint(n, x, y)
        implicit none
        integer n
        real x(*), y(*)

    FatPoint draw a set of points which can be seen on the screen.
\endtt}
\par}
\module{fftcc}%
\noindent Complex to complex 1D FFT routine.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fft.for
\newline \abox{Keywords:} fourier-transform, fft
\newline \abox{Responsible:} Robert Sault
\par{\tenpoint
{\eightpoint\begintt
        subroutine fftcc(in,out,isn,n)

        implicit none
        integer isn,n
        complex in(n),out(n)

  This performs a 1D Fourier transform of a complex sequence. There is no
  1/N scaling, and the "phase center" of the transform is the first
  element of the input array.

  Input:
    in         The input complex array.
    isn        The sign of the exponent in the transform, This can be
               either 1 or -1.
    n          The number of elements to transform. This must be a power
               of 2.
  Output:
    out        The output complex array.
\endtt}
\par}
\module{fftcr}%
\noindent Complex to real 1D FFT routine.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fft.for
\newline \abox{Keywords:} fourier-transform, fft
\newline \abox{Responsible:} Robert Sault
\par{\tenpoint
{\eightpoint\begintt
        subroutine fftcr(in,out,isn,n)

        implicit none
        integer n,isn
        real in(n+2),out(n)

  This performs a 1D Fourier transform of a complex sequence (with
  conjugate symmetry), to produce a real output. There is no
  1/N scaling, and the "phase center" of the transform is the first
  element of the input array.

  Input:
    in         The input complex array. This will normally be dimensioned
               as N/2+1 complex elements. Because the sequence is assumed
               to have conjugate symmetry, only half the input array is
               needed. The first element corresponds to the "DC" term.
               This array could also be declared to be a real array of
               size N+2 elements.
    isn        The sign of the exponent in the transform, This can be
               either 1 or -1.
    n          The number of elements to transform. This must be a power
               of 2.
  Output:
    out        The output real array.
\endtt}
\par}
\module{fftrc}%
\noindent Real to complex 1D FFT
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fft.for
\newline \abox{Keywords:} fourier-transform, fft
\newline \abox{Responsible:} Robert Sault
\par{\tenpoint
{\eightpoint\begintt
        subroutine fftrc(in,out,isn,n)

        implicit none
        integer isn,n
        real in(n),out(n+2)

  This performs a 1D Fourier transform of a real sequence. There is no
  1/N scaling, and the "phase center" of the transform is the first
  element of the input array.

  Input:
    in         The input real array.
    isn        The sign of the exponent in the transform, This can be
               either 1 or -1.
    n          The number of elements to transform. This must be a power
               of 2.
  Output:
    out        The output array. Because of the conjugate symmetry of the
               FFT of a real sequence, only half of the full complex sequence
               is returned. Normally this array will be dimensioned of size
               N/2+1 complex elements. Element 1 corresponds to the "DC" term,
               element N/2+1 corresponding to the "folding frequency" term.
               This array could alternately be dimensioned as N+2 real
               elements.
\endtt}
\par}
\module{filedel}%
\noindent Delete a file
\newline \ 
\newline \abox{File:} \$MIR/src/subs/filedel.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} files, delete
\par{\tenpoint
{\eightpoint\begintt
      subroutine filedel (name, iostat)

      character*(*) name
      integer iostat

     Inputs:     
       name      Name of the file to be deleted
     Outputs:
       iostat    Error Status of deletio. Will be non-zero in case
                 of an error
\endtt}
\par}
\module{findbase}%
\noindent Returns the baseline number
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Keywords:} calibration, baselines
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        INTEGER FUNCTION findbase(b, base, nbl)

        INTEGER b, nbl, base(*)

       Find index into an integer array, see also findsrc for
       its string equivalent

       Note: this routine could become a more general purpose function
\endtt}
\par}
\module{findname}%
\noindent Return the expanded name of a file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/findname.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} files, utilities
\par{\tenpoint
{\eightpoint\begintt
      subroutine findname(inname, outname)

      implicit none
      character inname*(*), outname*(*)

 Input:
   inname   The input name of the file.  This name may have
            environment/logical descriptors proceeding the file name.
            If there is a descriptor in the string, it is separated
            from the file name by a ':' symbol.

 Output:
   outname  The expanded name (descriptor translated and ':' removed).
\endtt}
\par}
\module{findsrc}%
\noindent Find index of word in a list of words
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Keywords:} calibration, baselines
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        INTEGER FUNCTION findsrc(n,list,name)

   return index of name in an array of name's in list(n):
       input:   n      lenght of list
                list   array of sources
                name   source to look for in array
       output:
       0       not found
       1..n    found match in this one, name(findsrc)

        INTEGER   n
        CHARACTER list(*)*(*), name*(*)

        INTEGER i

        findsrc = 0
        i = 0
        DO WHILE(i.LT.n .AND. findsrc.EQ.0)
            i = i+1
            IF (name.EQ.list(i)) findsrc = i
        ENDDO

        END
\endtt}
\par}
\module{fitcdio}%
\noindent Sequential read or write of a FITS header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitcdio(lu,value)

        implicit none
        integer lu
        character value*(*)

  This reads or writes a card at the current card pointer. For an old
  file, the current pointer is the last card accessed using one of
  the FITRDHD routines, or the FITSRCH routine. For a new file, the
  current pointer is always the current end of the header.

  Inputs:
    lu         File descriptor.

  Input or Output:
    value      This is the card at the current pointer. If it is a new
               file, this is an input. If it is an old file, this is an
               output.
\endtt}
\par}
\module{fitpoly}%
\noindent Fit a polynomial
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calpoly.for
\newline \abox{Keywords:} calibration, polynomials
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        INTEGER FUNCTION fitpoly( n, x, y, code, bl, porder)
        IMPLICIT NONE

        INTEGER   bl, porder, n
        REAL      x(*), y(*)
        CHARACTER code*(*)

   Fit a polynomial of certain order to data - the polynomial coefficients
   are merged into the /calpoly/ common data. This does not guarantee
   that evalpoly returns the correct value is previous fits for this
   'window' (code,bl) existed. [BUG or FEATURE - FIX OR NOT TO FIX].
   <<some redundant code exists in calfit now>>

   Fitpoly returns the ranking index of the new poly in the (code,bl) 
   interval. If there are breakpoints and/or multiple sources the data 
   may be only valid over a subinterval. 

   In case of multiple calls to FITPOLY with
   non-overlapping intervals FITPOLY will keep track of more than
   one polynomial per interval and tell you it's current ranking.

   When n-1 < porder, a fit is done to order n-1, and the remaining
   coefficients are set to 0

   Input:
       n         number of points
       x         x-ordinates
       y         y-data to fit
       bl        associated baseline [b=findbase(bl); b=1..nbl]
       code      associated phase/amp code
       porder    order to fit (0..MAXORDER)
   Output:
       fitpoly   index 'IPOL' of current data in poly(i,IPOL,s,b)
\endtt}
\par}
\module{fitrdhda}%
\noindent Read a character value from a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitrdhda(lu,key,out,default)

        implicit none
        integer lu
        character key*(*)
        character out*(*),default*(*)

  Read a character valued FITS card.

  Input:
    lu         File descriptor.
    key        Keyword to be read from header.
    default    The default value if the keyword is not found in the header.

  Output:
    out        Value of the keyword (this will be the default if the
               keyword was not found).
\endtt}
\par}
\module{fitrdhdd}%
\noindent Read a double precision value from a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitrdhdd(lu,key,out,default)

        implicit none
        integer lu
        character key*(*)
        double precision out,default

  Search for a double precision keyword. If found,decode it, otherwise
  use the default.

  Input:
    lu         File descriptor.
    key        Keyword to be read from header.
    default    The default value if the keyword is not found in the header.

  Output:
    out        Value of the keyword (this will be the default if the
               keyword was not found).
\endtt}
\par}
\module{fitrdhdi}%
\noindent Read an integer value from a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitrdhdi(lu,key,out,default)

        implicit none
        integer lu
        character key*(*)
        integer out,default

  Read an integer valued FITS card.

  Input:
    lu         File descriptor.
    key        Keyword to be read from header.
    default    The default value if the keyword is not found in the header.

  Output:
    out        Value of the keyword (this will be the default if the
               keyword was not found).
\endtt}
\par}
\module{fitrdhdl}%
\noindent Read a logical value from a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitrdhdl(lu,key,out,default)

        implicit none
        integer lu
        character key*(*)
        logical out,default

  Read a logical valued FITS card.

  Input:
    lu         File descriptor.
    key        Keyword to be read from header.
    default    The default value if the keyword is not found in the header.

  Output:
    out        Value of the keyword (this will be the default if the
               keyword was not found).
\endtt}
\par}
\module{fitrdhdr}%
\noindent Read a real value from a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitrdhdr(lu,key,out,default)

        implicit none
        integer lu
        character key*(*)
        real out,default

  Read a real valued FITS card.

  Input:
    lu         File descriptor.
    key        Keyword to be read from header.
    default    The default value if the keyword is not found in the header.

  Output:
    out        Value of the keyword (this will be the default if the
               keyword was not found).
\endtt}
\par}
\module{fitsrch}%
\noindent Search for a keyword in the header of an old FITS file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitsrch(lu,key,found)

        implicit none
        integer lu
        character key*(*)
        logical found

  This searches for a keyword in the file header, and leaves the
  card pointer pointing at the card. If it is not found
  the pointer points at the END card, and FOUND is returned .false.

  Inputs:
    lu         File descriptor.
    key        Keyword to search for.

  Outputs:
    found      This will be true if the card was found.
\endtt}
\par}
\module{fitwrhda}%
\noindent Write a string to a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitwrhda(lu,key,value)

        implicit none
        integer lu
        character key*(*)
        character value*(*)

  Write an ascii valued fits card.

  Input:
    lu         File descriptor.
    key        FITS keyword.
    value      Value of the keyword.
\endtt}
\par}
\module{fitwrhdd}%
\noindent Write a double precision keyword to a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitwrhdd(lu,key,value)

        implicit none
        integer lu
        character key*(*)
        double precision value

  Write a real valued FITS card out.

  Input:
    lu         File descriptor.
    key        FITS keyword.
    value      Value of the keyword.
\endtt}
\par}
\module{fitwrhdh}%
\noindent Write a string to a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitwrhdh(lu,key,value)

        implicit none
        integer lu
        character key*(*),value*(*)

  Write a comment or history card.

  Input:
    lu         File descriptor.
    key        FITS keyword (usually HISTORY).
    value      The comment to write.
\endtt}
\par}
\module{fitwrhdi}%
\noindent Write an integer value to a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitwrhdi(lu,key,value)

        implicit none
        integer lu
        character key*(*)
        integer value

  Write an integer valued fits card.

  Input:
    lu         File descriptor.
    key        FITS keyword.
    value      Value of the keyword.
\endtt}
\par}
\module{fitwrhdl}%
\noindent Write a logical value to a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitwrhdl(lu,key,value)

        implicit none
        integer lu
        character key*(*)
        logical value

  Write a logical valued fits cards.

  Input:
    lu         File descriptor.
    key        FITS keyword.
    value      Value of the keyword.
\endtt}
\par}
\module{fitwrhdr}%
\noindent Write a real value to a FITS file header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fitwrhdr(lu,key,value)

        implicit none
        integer lu
        character key*(*)
        real value

  Write a real valued FITS card out.

  Input:
    lu         File descriptor.
    key        FITS keyword.
    value      Value of the keyword.
\endtt}
\par}
\module{flipper}%
\noindent Flip phases into a continuous string
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calphase.for
\newline \abox{Keywords:} calibration, line up phases
\newline \abox{Responsible:} Lee Mundy
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE flipper(timave,timmax,basediff)

        REAL    timave,timmax
        INTEGER basediff(2,*)

   Input:
       timave    max time interval allowed between data points within
                     a group of points to be vector averaged
                     if timave=0, it is set to 4 minutes
       timmax    max time interval over which to vector average data
                     if timmax=0, it is set to 20 minutes

   Output:
       basediff  dummy array output for compatability - all zeros

   Flipper attempts to correct the phases for phase wrapping
   It uses vector averaging, and hence needs to be supplied
   with an array specifiying how vector averaging is done.
   The source code is full of witty comments how it really
   works.
\endtt}
\par}
\module{freelun}%
\noindent Release a logical unit, previously allocated with GetLun.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/luns.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} logical-units, utilities
\par{\tenpoint
{\eightpoint\begintt
        subroutine freelun(lun)

        implicit none
        integer lun

  Free a logical unit, previously allocated with GetLun.

  Input:
    lun        The logical unit to free up.
\endtt}
\par}
\module{fullname}%
\noindent Expand an environment variable in front of a filename
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fullname.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} files
\par{\tenpoint
{\eightpoint\begintt
      character*(*) function fullname(filename)
      character*(*) filename

 This takes a filename consisting of two parts separated by a ':' and expands
 the environment variable indicated by the first half. If no ':' occurs, it
 checks for the occurrence of a '$' and tries to expand the environment
 variable indicated by that (the characters between "$" and "/"). If still
 nothing is found the original input is returned.

 Input:
   filename:    name of a file containing an environment variable
\endtt}
\par}
\module{fuvclose}%
\noindent Close a UV FITS file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fuvclose(lu)

        implicit none
        integer lu

  Close up a UV file. Good night.

  Input:
    lu         Handle of the UV FITS file.
\endtt}
\par}
\module{fuvopen}%
\noindent Open a FITS uv file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fuvopen(lu,name,status,nvis,npol,nfreq)

        implicit none
        integer lu,nvis,npol,nfreq
        character name*(*),status*(*)

  Open a FITS uv file and ready it for i/o.

  Inputs:
    name       The name of the file to be opened.
    status     Either 'old' or 'new'.

  Inputs or Outputs:
    These are input when status='new', and output when status='old'.
    nvis       The number of visibilities in the file.
    npol       The number of polarizations (from 1 to 4).
    nfreq      The number of frequency channels.

  Output:
    lu         File descriptor.
\endtt}
\par}
\module{fuvrdhd}%
\noindent Get coordinate information about a UV FITS file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fuvrdhd(lu,coord)

        implicit none
        integer lu
        double precision coord(2,4)

  Get coordinate information about a UV file.

  Input:
    lu         Handle of the uv FITS file.
  Output:
    coord      Coordinate information.

  Though this could be done by an "ordinary" subroutine, put it here because
  its so commonly done, and requires a bit of fiddling around.
\endtt}
\par}
\module{fuvread}%
\noindent Read visibility data from UV FITS file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fuvread(lu,visdat,number,count)

        implicit none
        integer lu,number,count
        real visdat(*)

  Read some uv data.
  The loops in this subroutine feel unusual because are inside out,
  so that vectorization can be increased.

  Inputs:
    lu         Logical unit of file.
    number     Number of the first visibility to read.
    count      The number of visibilities to read.

  Output:
    Visdat     Output buffer containing the visibilities.
\endtt}
\par}
\module{fuvsetlm}%
\noindent Set the ranges of parameters for a FITS UV file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fuvsetlm(lu,limits)

        implicit none
        integer lu
        real limits(10)

  This tells the i/o subsystem the maximum values that the various
  uv parameters can possibly be. Allow for the case of zero limits,
  and bomb out if we detect a negative limit.

  Inputs:
    lu         File descriptor.
    limits     Array containing the limiting values, as given below.
               1  UU-L
               2  VV-L
               3  WW-L
               4  BASELINE
               5  DATE
               6  Visibility
               7  Weight
               8  Reserved
               9  Base Time
               10 Reserved
\endtt}
\par}
\module{fuvtoff}%
\noindent Get time offset for a UV FITS file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        real function fuvToff(lu)

        implicit none
        integer lu

  This returns the offset that needs to be added to the time to get
  correct Julian time.

  Input:
    lu         The handle of the input uv file.
  Output:
    fuvToff    Time offset.
\endtt}
\par}
\module{fuvwrhd}%
\noindent Save UV FITS file coordinate information.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fuvwrhd(lu,coord)

        implicit none
        integer lu
        double precision coord(2,4)

  Save coord info about a UV file in the output.

  Inputs:
    lu         Handle of the UV FITS file.
    coord      Coordinate information
\endtt}
\par}
\module{fuvwrite}%
\noindent Write data to a UV FITS file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fuvwrite(lu,visdat,number,count)

        implicit none
        integer lu,number,count
        real visdat(*)

  Write some uv data. This performs a sequential write, starting at the
  current pointer.
  The loops in this subroutine feel unusual because are inside out,
  so that vectorization can be increased.

  Inputs:
    lu         Logical unit of file.
    number     Number of the first visibility to read.
    count      The number of visibilities to read.

  Output:
    Visdat     Output buffer containing the visibilities.
\endtt}
\par}
\module{fxyclose}%
\noindent Close a FITS image file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fxyclose(lu)
        implicit none
        integer lu

  Close up a fits file. Good night.

  Input:
    lu         File descriptor.
\endtt}
\par}
\module{fxyopen}%
\noindent Open a FITS image file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fxyopen(lu,name,status,naxis,nsize)

        implicit none
        integer lu,naxis,nsize(naxis)
        character name*(*),status*(*)

  Open a FITS image file and ready it for use.

  Inputs:
    name       Name of the map to be opened.
    status     Either 'old' or 'new', depending whether an old image
               is being read, or a new image is being written.
    naxis      Dimension of nsize.

  Input/Output:
    The following are input if creating a new image (i.e. status='new'),
    or output when reading an old image.

    nsize      An array containing dimension information. For an old
               file, this is filled with the values of NAXIS1, NAXIS2, ...
               If there are fewer than NAXIS dimensions, then it is 
               filled with ones.

  Output:
    lu         File descriptor of the image opened.
\endtt}
\par}
\module{fxyread}%
\noindent Read a row of data from a FITS image.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fxyread(lu,index,data)

        implicit none
        integer lu,index
        real data(*)

  Read a row of data from a FITS image.

  Input:
    lu         File descriptor.
    index      Index of the row to access.
    data       Array containing the pixel info.
\endtt}
\par}
\module{fxysetlm}%
\noindent Set the pixel range for scaling a FITS image.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fxysetlm(lu,bmin,bmax)

        implicit none
        integer lu
        real bmin,bmax

  Set the pixel range, before writing a FITS image.

  Inputs:
    lu         Handle of the output image.
    bmin,bmax  The image minimum and maximum values.
\endtt}
\par}
\module{fxysetpl}%
\noindent Select the plane of interest in a FITS image.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fxysetpl(lu,naxis,nsize)

        implicit none
        integer lu,naxis,nsize(naxis)

  This sets the plane of a multi-plane image that we wish to access.

  Inputs:
    lu         File descriptor.
    naxis      Dimension of nsize.
    nsize      Array containing the index of the plane to be accessed.
               NSIZE(1) corresponds to the index into the third dimension.
\endtt}
\par}
\module{fxywrite}%
\noindent Write a row of a FITS image.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fitsio.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} fits
\par{\tenpoint
{\eightpoint\begintt
        subroutine fxywrite(lu,index,data)

        implicit none
        integer lu,index
        real data(*)

  Write a row of data to the image file.

  Input:
    lu         File descriptor.
    index      Index of the row to access.
    data       Array containing the pixel info.
\endtt}
\par}
\module{gainfact}%
\noindent Determine the self-cal gain at a given time and baseline.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvdat.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} selfcal-gains, calibration
\par{\tenpoint
{\eightpoint\begintt
        subroutine GainFact(preamble,gain,flag)
        implicit none
        double precision preamble(4)
        complex gain
        logical flag
\endtt}
\par}
\module{gainfin}%
\noindent Close up the selfcal gains routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvdat.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} selfcal-gains, calibration
\par{\tenpoint
{\eightpoint\begintt
        subroutine GainFin
        implicit none

  Finish up processing by the gains routines. This is pretty trivial.
\endtt}
\par}
\module{gaininit}%
\noindent Initialise the "gains" routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvdat.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} selfcal-gains, calibration
\par{\tenpoint
{\eightpoint\begintt
        subroutine GainInit(tvis)
        implicit none
        integer tvis

  This initialises the "gains" routines, and readies it to start reading
  data.
\endtt}
\par}
\module{gaus}%
\noindent Generate gaussianly distributed random variables.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/noise.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} random-variables, noise
\par{\tenpoint
{\eightpoint\begintt
        subroutine gaus(data,n)

        implicit none
        integer n
        real data(n)

  Generate gaussian noise. This works on any machine, but the Gaussian
  noise it produces is system dependent and not extremely accurate.

  Gaussian noise is produced by adding 12 variates uniformly distributed
  in [0,1], then subtracting 6. This will have zero
  mean, and a variance of 1, and by the Central Limit Theorem, will
  approximate gaussian noise.

  Inputs:
    n          Number of gaussian numbers to produce.

  Output:
    data       An array of gaussian noise.
\endtt}
\par}
\module{gcffun}%
\noindent Generate the gridding convolution function.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/grid.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} gridding, interpolation
\par{\tenpoint
{\eightpoint\begintt
        subroutine gcffun(func,phi,n,width,alpha)

        implicit none
        integer n
        character func*(*)
        integer width
        real phi(n),alpha

  Calculate the gridding function. Calculate only half the function, and
  then use its evenness to reflect the rest.

  Inputs:
    func       The gridding function type. Currently only 'spheroidal'
               is supported.
    width      The function width, in pixels. Currently must be integral.
    alpha      Some gridding function specific parameter.
    n          Size of the table required.
  Outputs:
    phi        The output gridding table.

  References:
    F.R. Schwab "Optimal gridding of visibility data in radio interferometry",
      Indirect Imaging, J.A. Roberts, ed., Cambridge Univ. Press, 1984.
\endtt}
\par}
\module{getants}%
\noindent Returns the number of antennas and antenna pair
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Keywords:} calibration, baselines
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE getants( binp, nant, a1, a2 )

        INTEGER binp, nant, a1, a2

  The antennas are re-ordered from 1 to nant, where nant is the
  actual number of antennas, instead of the highest valued antenna.
  If an array has antennas [2,3,6], then binp = (256*2 + 6) will
  return nant = 3, a1 = 1, a2 = 3.

  Inputs:
       binp  -- baseline number
       nant -- if zero, then initialize and find nant

  Outputs:
       nant -- the number of antennas
       a1    -- ordinal value of lower antenna
       a2    -- ordinal value of upper antenna
\endtt}
\par}
\module{getbeam}%
\noindent Get beam from image header.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/getbeam.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} utilities
\par{\tenpoint
{\eightpoint\begintt
        subroutine GetBeam(lIn,naxis,bunit,bmaj,bmin,omega,cbof)
        implicit none
        integer lIn,naxis
        character*10 bunit
        real bmaj,bmin,omega,cbof

  Get beam from image header.

  Inputs:
    lIn        The handle of the Image.
    naxis      Number of image axes.
  Outputs:
    bunit      The pixel units.
    bmaj,bmin  Beam major and minor axes [radians].
    omega      Beam solid angle [steradians]
    cbof       Beam oversampling factor.
\endtt}
\par}
\module{getclo3}%
\noindent Return sign for closure calculation for 3 baselines
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calphase.for
\newline \abox{Keywords:} calibration, 
\newline \abox{Responsible:} Lee Mundy
\par{\tenpoint
{\eightpoint\begintt
        subroutine getclo3(nbl,base,signcl) 

   Returns sign for closure calculation for 3 baselines
   WARNING::: THIS ONLY WORKS FOR # ANTENNAS

   Input:
       nbl --   (integer)  lenght of base() array
       base --  (integer)  array containing A1*256+A2 baselines
   Output:
       signcl -- (real)    array filled with +/- 1.0 for closure such that 
                           $sum_{i=1}^{nbl}{signcl(i)*phi{i}}=0$

        real signcl(*)
        integer nbl, base(*)
\endtt}
\par}
\module{getfield}%
\noindent Extract a field from a string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        subroutine getfield(string,k1,k2,token,length)

        implicit none
        integer k1,k2,length
        character string*(*),token*(*)

  Extract a "field". This looks for a separator, which may be a comma
  or white character. It also worries about bracketing with () characters
  and strings enclosed within quotes.

  Input:
    string     The string containing the fields.
  Input/Output:
    k1,k2      These delimit the characters in the string that are
               to be processed. On output, k1 is incremented to point
               beyond the token just returned.
  Output:
    token      The returned token.
    length     The length of the token.
\endtt}
\par}
\module{getlun}%
\noindent Get a logical unit number.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/luns.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} logical-units, utilities
\par{\tenpoint
{\eightpoint\begintt
        subroutine getlun(lun)

        implicit none
        integer lun

  This returns a logical unit number which is currently free.

  Output:
    lun        The logical unit number.
\endtt}
\par}
\module{getparm}%
\noindent Extract a parameter from a string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        subroutine getparm(string,k1,k2,token,length)

        implicit none
        integer k1,k2,length
        character string*(*),token*(*)

  Extract a string surrounded by white characters. White space at the
  start of the string is first skipped.

  Input:
    string     The string containing the parameters.
  Input/Output:
    k1,k2      These delimit the characters in the string that are
               to be processed. On output, k1 is incremented to point
               beyond the token just returned.
  Output:
    token      The returned token.
    length     The length of the token.
\endtt}
\par}
\module{getpb}%
\noindent Determine the primary beam associated with a image.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/getpb.for
\newline \abox{Keywords:} image-data
\newline \abox{Responsible:} Mel Wright
\par{\tenpoint
{\eightpoint\begintt
        subroutine GetPB(tno,name,pbfwhm)

        implicit none
        integer tno
        character name*(*)
        real pbfwhm

  Determine the primary beam size of particular telescopes. This compares
  the header parameter 'telescop' with the list of known telescopes.
  The "size" array contains the primary beam size, in units of
  arcseconds * GHz. So we must divide this number by the sky freq.

  Input:
    tno        The file handle.
    name       Name of the input file. Used for error messages only.
  Output:
    pbfwhm     The primary beam size, in arcseconds. If it is a single
               dish telescope, this is set to zero.

  References:
    VLA beam size: From AIPS LTESS, which attributes the measurement to
       a test memo by Rots and Napier.
    Hat Ck size: From Bima Users Guide - Jan89, which claims this is the
       value corresponding to a 6 meter telescope. See caveats there.
\endtt}
\par}
\module{getplane}%
\noindent Read portion of a plane, specified by runs format.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/plane.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} region-of-interest, runs
\par{\tenpoint
{\eightpoint\begintt
        subroutine GetPlane(lu,Run,nRun,xoff,yoff,nx,ny,Out,MaxOut,nOut)

        implicit none
        integer lu,nRun,Run(3,nRun),MaxOut,nOut,xoff,yoff,nx,ny
        real Out(MaxOut)

  Read in the section of a plane that we are interested in.

  Inputs:
    lu         The handle of the input file.
    Run        The runs specifications.
    nRun       The number of runs.
    xoff,yoff  Offset to add to the runs before reading.
    nx,ny      The size of the plane.
    maxOut     The max number of pixels that can be returned.

  Output:
    Out        The output array to receive the selected pixels.
    nOut       The number of pixels in the output array.
\endtt}
\par}
\module{getpoly}%
\noindent Read in the phase-amplitude calibration fit
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calpoly.for
\newline \abox{Keywords:} calibration, polynomials, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE getpoly( dataset )
        IMPLICIT NONE

        CHARACTER dataset*(*)

  Inputs:
       dataset -- name of calibration data set
\endtt}
\par}
\module{getslot}%
\noindent Get all slots that match wildcard slotcode
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Keywords:} calibration, slotcode
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        INTEGER FUNCTION getslot(code,n,s)

        CHARACTER code*(*)
        INTEGER   n, s(*)

    Codes2S calculates for a given character slot code all
    integer slot codes that are matched. A wildcard can be
    given by a '*' in any of the first three positions of
    'code'

    Example: code='*LW' returns two slotcodes, 1 and 2.

    Input:
       code    3/4 character code
       n       available lenght of s() array
    Output
       s       array of slots that match wildcard code
       codes2s number of slots in s() that were matched

   NOTE: Routine has not been fully implemented yet!!!!
\endtt}
\par}
\module{gettok}%
\noindent Extract a token from a string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        subroutine gettok(string,k1,k2,token,length)

        implicit none
        integer k1,k2,length
        character string*(*),token*(*)

  Extract an alphanumeric token from the string. White space at the
  start of the string is first skipped.

  Input:
    string     The string containing the tokens.
  Input/Output:
    k1,k2      These delimit the characters in the string that are
               to be processed. On output, k1 is incremented to point
               beyond the token just returned.
  Output:
    token      The returned token.
    length     The length of the token.
\endtt}
\par}
\module{haccess}%
\noindent Open an item of a data set for access.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} low-level-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence
        subroutine haccess(tno,itno,keyword,status,iostat)
        integer tno,itno,iostat
        character keyword*(*),status*(*)

  Miriad data sets consist of a collection of items. Before an item within
  a data set can be read/written, etc, it must be "opened" with the haccess
  routine.

  Input:
    tno         The handle of the data set.
    keyword     The name of the item.
    status      This can be 'read', 'write', 'append' or 'scratch'.
  Output:
    itno        The handle of the opened item. Note that item handles are
                quite distinct from data-set handles.
   iostat       I/O status indicator. 0 indicates success. Other values
                are standard system error numbers.                      
\endtt}
\par}
\module{hangle}%
\noindent Convert hours value (in radians) into a formatted string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/angles.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} utility
\par{\tenpoint
{\eightpoint\begintt
      character*(*) function hangle(theta)

      implicit none
      double precision theta

  Converts an angle expressed in radians into a string.

  Inputs:
    theta    Angle in radians.

  Output:
    rangle   Angle formated into a string with format:
               [+/-]HH:MM:SS.SS
\endtt}
\par}
\module{hannsm}%
\noindent Hanning smooth a data array..
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hann.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} smoothing, convolution
\par{\tenpoint
{\eightpoint\begintt
      subroutine hannsm (nsmth, coeffs, npts, arr, arrs)

      implicit none
      integer npts, nsmth
      real arr(npts), arrs(npts), coeffs(nsmth)

  Hanning smooth an array.

  Input:
    nsmth    i    Smoothing length.
    coeffs   r    Weights.
    npts     i    Number of data points.
    arr      r    Data array.
  Output:
    arrs     r    Smoothed array.
\endtt}
\par}
\module{hclose}%
\noindent Close a Miriad data set.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} low-level-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence
        subroutine hclose(tno)
        integer tno

  This closes a Miriad data set. The data set cannot be accessed after the
  close.

  Input:
    tno         The handle of the Miriad data set.                      
\endtt}
\par}
\module{hcoeffs}%
\noindent Calculated coefficients for Hanning smoothing.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hann.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} smoothing, convolution
\par{\tenpoint
{\eightpoint\begintt
      subroutine hcoeffs (maxco, nsmth, coeffs)

      implicit none
      integer maxco, nsmth
      real coeffs(nsmth)

  Work out binomial weights or coefficients for Hanning smooth

  Input:
    maxco   i    Maximum size of smoothing length
    nsmth   i    Smoothing length
  Output:
    coeffs  r    Weights for data points
\endtt}
\par}
\module{hdaccess}%
\noindent Finish up access to an item.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} low-level-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence
        subroutine hdaccess(itno,iostat)
        integer itno,iostat

  This releases an item. It flushes buffers and waits for i/o to complete.
  For small items that are entirely in memory, these are saved until
  the whole tree is closed before they are written out.

  Input:
    itno        The handle of the item to close up.
    iostat      I/O status indicator. 0 indicates success. Other values
                are standard system error numbers.                      
\endtt}
\par}
\module{hdcopy}%
\noindent Copy a headfer variable from one data set to another.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine hdcopy(tin,tout,keyword)
        integer tin,tout
        character keyword*(*)

  Copy a header item from one data set to another.

  Input:
    tin         File handle of the input data set.
    tout        File handle of the output data set.
    keyword     Name of the header variable to be copied.               
\endtt}
\par}
\module{hdelete}%
\noindent Delete an item from a data-set.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} low-level-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence
        subroutine hdelete(tno,keyword,iostat)
        integer tno,iostat
        character keyword*(*)

  This deletes an item from a Miriad data-set. The item must not be "accessed"
  when the hdelete routine is called.

  Input:
    tno         The handle of the data set.
    keyword     The name of the item.
  Output:
   iostat       I/O status indicator. 0 indicates success. Other values
                are standard system error numbers.                      
\endtt}
\par}
\module{hdprobe}%
\noindent Determine characteristics of a header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine hdprobe(tno,keyword,descr,type,n)
        integer tno
        character keyword*(*),descr*(*),type*(*)
        integer n

  Determine characteristics of a particular header variable.
  Inputs:
    tno         Handle of the data set.
    keyword     Name of the header variable to probe.

  Outputs:
    descr       A formatted version of the item. For single numerics or
                short strings, this is the ascii encoding of the value. For
                large items, this is some message describing the item.
    type        One of:
                  'nonexistent'
                  'integer*2'
                  'integer'
                  'real'
                  'double'
                  'complex'
                  'character'
                  'text'
                  'binary'
    n           Number of elements in the item. Zero implies an error. One
                implies that "descr" is the ascii encoding of the value. 
\endtt}
\par}
\module{hdprsnt}%
\noindent Determine if a header variable is present.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        logical function hdprsnt(tno,keyword)
        integer tno
        character keyword*(*)

  Check if a particular header variable is present in a data set.

  Input:
    tno         File handle of the data set to check.
    keyword     Name of the header variable to check for.               
\endtt}
\par}
\module{hisappn}%
\noindent Append history from a file to an open dataset
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsetio.for
\newline \abox{Keywords:} history, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
      SUBROUTINE hisappn(tno,file)
      INTEGER   tno
      CHARACTER file*(*)

   Append the history from a file to an open dataset

   Input:
       tno        handle of the open dataset to append history to
       file       filename of dataset to append history from

   Warning: The history item in 'tno' must not be open, since an
       explicit hisopen() and hisclose() will be used.
\endtt}
\par}
\module{hisclose}%
\noindent This closes the history file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine hisclose(tno
        integer tno

  This closes the history file associated with a particular data set.
  Input:
    tno         The handle of the data set.                             
\endtt}
\par}
\module{hisinput}%
\noindent Copy task input parameters to a history file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hisinput.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} history, user-input
\par{\tenpoint
{\eightpoint\begintt
        subroutine HisInput(tno,name)

        implicit none
        integer tno
        character name*(*)

  This copies the task parameters on the command line and writes them
  to the history file.

  NOTE:  The history file must be currently open (via HisOpen) for 
  this routine to work properly.

  Inputs:
    tno        Handle of the history file.
    name       Program name. History comments are prepended with this
               name.
\endtt}
\par}
\module{hisopen}%
\noindent Open the history file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine hisopen(tno,status)
        integer tno
        character status

  This opens the history file, and readies it to be read or written.

  Inputs:
    tno         The handle of the open data set.
    status      Either "read", "write" or "append".                     
\endtt}
\par}
\module{hisread}%
\noindent Read a line of text from the history file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine hisread(tno,line,eof)
        integer tno
        character line*(*)
        logical eof

  This reads a line of text from the history file.

  Input:
    tno         The handle of the input data set.
  Output:
    line        The string to receive the read string.
    eof         This logical variable turns true when the end of the
                history file is reached.                                
\endtt}
\par}
\module{hiswrite}%
\noindent Write a line of text to the history file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine hiswrite(tno,line)
        integer tno
        character line*(*)

  This writes a text string to the history file associated with an open
  data set.

  Inputs:
    tno         The handle of the open data set.
    line        The string of text to be written to the history file.   
\endtt}
\par}
\module{hopen}%
\noindent Open a data set.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} low-level-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence
        subroutine hopen(tno,name,status,iostat)
        integer tno,iostat
        character name*(*),status*(*)

  This opens a Miriad data-set, and readies it to be read or written.

  Input:
    name        The name of the data set.
    status      Either 'old' or 'new'.
  Output:
    tno         The file handle of the opened data set.
   iostat       I/O status indicator. 0 indicates success. Other values
                are standard system error numbers.                      
\endtt}
\par}
\module{hread}%
\noindent Hwrite -- Read and write items.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} low-level-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence
        subroutine hreada(itno,abuf,iostat)
        subroutine hreadb(itno,bbuf,offset,length,iostat)
        subroutine hreadj(itno,jbuf,offset,length,iostat)
        subroutine hreadi(itno,ibuf,offset,length,iostat)
        subroutine hreadr(itno,rbuf,offset,length,iostat)
        subroutine hreadd(itno,dbuf,offset,length,iostat)
        subroutine hwritea(itno,abuf,iostat)
        subroutine hwriteb(itno,bbuf,offset,length,iostat)
        subroutine hwritej(itno,jbuf,offset,length,iostat)
        subroutine hwritei(itno,ibuf,offset,length,iostat)
        subroutine hwriter(itno,rbuf,offset,length,iostat)
        subroutine hwrited(itno,dbuf,offset,length,iostat)
        integer itno,offset,length,iostat
        character abuf*(*),bbuf*(length)
        integer jbuf(*),ibuf(*)
        real rbuf(*)
        double precision dbuf(*)

  These routines read and write items of a Miriad data set. They
  differ in the sort of element that they read or write.
        hreada,hwritea  I/O on ascii text data (terminated by newline char).
        hreadb,hwriteb  I/O on ascii data.
        hreadj,hwritej  I/O on data stored externally as 16 bit integers.
        hreadi,hwritei  I/O on data stored externally as 32 bit integers.
        hreadr,hwriter  I/O on data stored externally as IEEE 32 bit reals.
        hreadd,hwrited  I/O on data stored externally as IEEE 64 bit reals.

  Note that hreada and hreadb differ in that:
    * hreada reads sequentially, terminating a read on a newline character.
      The output buffer is blank padded.
    * hreadb performs random reads. Newline characters have no special
      meaning to it. A fixed number of bytes are read, and the buffer is
      not blank padded.
   Hwritea and hwriteb differ in similar ways.

  Inputs:
    itno        The handle of the item to perform I/O on.
    offset      The byte offset into the item, where I/O is to be
                performed.
    length      The number of bytes to be read.

  "Offset" and "length" are offsets and lengths into the external file, always
  given in bytes.

  Note that "offset" and "length" must obey an alignment requirement. Both
  must be a multiple of the size of the element they are performing I/O on.
  For eaxample, they must be a multiple of 2 for hreadj,hwritej; a multiple
  of 4 for hreadi,hwritei,hreadr,hwriter; a multiple of 8 for hreadd,hwrited.

  Inputs(hwrite) or Outputs(hread):
    abuf,bbuf,jbuf,ibuf,rbuf,dbuf The buffer containing, or to receive,
                the data.
  Outputs:
    iostat      I/O status indicator. 0 indicates success. -1 indicates
                end-of-file. Other values are standard system
                error numbers.                                          
\endtt}
\par}
\module{hsize}%
\noindent Determine the size (in bytes) of an item.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} low-level-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence
        integer function hsize(itno)
        integer itno

  This returns the size of an item, in bytes.

  Input:
    itno        The handle of the item of interest.
  Output:
    hsize       The size of the item in bytes.                          
\endtt}
\par}
\module{hsorta}%
\noindent Perform an index heapsort on a character string array.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hsort.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} sorting
\par{\tenpoint
{\eightpoint\begintt
      subroutine hsorta(n, array, indx)

      implicit undefined (a-z)
      integer n, indx(n)
      character*(*) array(n)

     Input:
       n        The number of elements in the character array.
       array    The character array on which to base the sort.
       indx     The integer index array used to point at array.

     Output:
       indx     Sorted integer index array such that array(indx(1)) is
                the smallest and array(indx(n)) is the largest string.
\endtt}
\par}
\module{hsortad}%
\noindent Perform a dual index heapsort on a character string array.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hsort.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} sorting
\par{\tenpoint
{\eightpoint\begintt
      subroutine hsortad(n, array, second, indx)

      implicit undefined (a-z)
      integer n, indx(n)
      character*(*) array(n)
      double precision second(n)

     Input:
       n        The number of elements in the character array.
       array    The character array on which to base the primary sort.
       second   The double precision array used for the secondary sort.
       indx     The integer index array used to point at array.

     Output:
       indx     Sorted integer index array such that array(indx(1)) is
                the smallest and array(indx(n)) is the largest string.
\endtt}
\par}
\module{hsortar}%
\noindent Perform a dual index heapsort on a character string array.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hsort.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} sorting
\par{\tenpoint
{\eightpoint\begintt
      subroutine hsortar(n, array, second, indx)

      implicit undefined (a-z)
      integer n, indx(n)
      character*(*) array(n)
      real second(n)

     Input:
       n        The number of elements in the character array.
       array    The character array on which to base the primary sort.
       second   The real array on which to base the secondary sort.
       indx     The integer index array used to point at array.

     Output:
       indx     Sorted integer index array such that array(indx(1)) is
                the smallest and array(indx(n)) is the largest string.
\endtt}
\par}
\module{hsortd}%
\noindent Perform an indexed heapsort on a double precision array.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hsort.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} sorting
\par{\tenpoint
{\eightpoint\begintt
      subroutine hsortd(n, array, indx)

      implicit undefined (a-z)
      integer n, indx(n)
      double precision array(n)

     Input:
       n        The number of elements in the array.
       array    The double precision array on which to base the sort.
       indx     The integer index array used to point at array.

     Output:
       indx     Sorted integer index array such that array(indx(1)) is
                the smallest and array(indx(n)) is the largest element.
\endtt}
\par}
\module{hsorti}%
\noindent Perform an indexed heapsort on a integer array.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hsort.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} sorting
\par{\tenpoint
{\eightpoint\begintt
      subroutine hsorti(n, array, indx)

      implicit undefined (a-z)
      integer n, indx(n)
      integer array(n)

     Input:
       n        The number of elements in the array.
       array    The integer array on which to base the sort.
       indx     The integer index array used to point at array.

     Output:
       indx     Sorted integer index array such that array(indx(1)) is
                the smallest and array(indx(n)) is the largest element.
\endtt}
\par}
\module{hsortr}%
\noindent Perform an indexed heapsort on a real array.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hsort.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} sorting
\par{\tenpoint
{\eightpoint\begintt
      subroutine hsortr(n, array, indx)

      implicit undefined (a-z)
      integer n, indx(n)
      real array(n)

     Input:
       n        The number of elements in the array.
       array    The real array on which to base the sort.
       indx     The integer index array used to point at array.

     Output:
       indx     Sorted integer index array such that array(indx(1)) is
                the smallest and array(indx(n)) is the largest element.
\endtt}
\par}
\module{hsortrr}%
\noindent Perform a dual index heapsort on a real array.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hsort.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} sorting
\par{\tenpoint
{\eightpoint\begintt
      subroutine hsortrr(n, array, second, indx)

      implicit undefined (a-z)
      integer n, indx(n)
      real array(n), second(n)

     Input:
       n        The number of elements in the array.
       array    The real array on which to base the primary sort.
       second   The real array on which to base the secondary sort.
       indx     The integer index array used to point at array.

     Output:
       indx     Sorted integer index array such that array(indx(1)) is
                the smallest and array(indx(n)) is the largest element.
\endtt}
\par}
\module{imminmax}%
\noindent Return Miriad image minimum and maximum value.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/imminmax.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} image-data, utilities
\par{\tenpoint
{\eightpoint\begintt
        subroutine ImMinMax(lun,naxis,nsize,rmin,rmax)

        implicit none
        integer lun,naxis,nsize(naxis)
        real rmin,rmax

  Determine the min and max values of a Miriad image. This first checks
  the image header for the information. If it is not present in the header,
  it calculates it directly from the data, and then stores it in the header.

  Input:
    lun        The handle of the input image.
    naxis      The number of axes.
    nsize      The length of each axis.

  Output:
    rmin,rmax  The min and max value of the image.
\endtt}
\par}
\module{imscale}%
\noindent Autoscale a map.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tvsubs.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} image-data, utilities
\par{\tenpoint
{\eightpoint\begintt
      subroutine imscale(map, Mx, Nx, Ny, pmin, pmax)

      implicit none
      integer Mx, Nx, Ny
      real map(Mx, Ny), pmin, pmax

  Finds the minimum and maximum of the real array map(x,y).

  Input:
    map(Nx,Ny)   Input real array of values.
    Mx           The maximum (or declared) X dimension of the array.
    Nx, Ny       X/Y working dimensions of the map array.

  Output:
    pmin, pmax   The minimum (pmin) and maximum (pmax) of the array.
\endtt}
\par}
\module{indek}%
\noindent Get position of substring in a string, returning length if not found
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      integer function indek ( string, substring )
      character*(*) string, substring

 Indek works basically the same as the intrinsic function index, but if the
 substring is not found, it does not return 0, but the length of the string
 plus 1.
 Example of use:
 filename = dir(:nelc(dir)) // name( : indek(name,'.')-1 ) // ' '
 Now only one statement is needed instead of three (find index(name,'.'); test'
 if ok; the above)

 Input:
   string:      the string to search in
   substring:   the substring to search for
\endtt}
\par}
\module{inipoly}%
\noindent Forced initialize polynomials
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calpoly.for
\newline \abox{Keywords:} calibration, polynomials, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE inipoly
        IMPLICIT NONE

       Calling IniPoly clears all polynomials from memory, and fakes
       the order of the polynomials to -1 for consistency.
       It is normally not called by the user, but getpoly calls it
       on its first call.
\endtt}
\par}
\module{intpini}%
\noindent Initialize the interpolation i/o routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/intpio.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} interpolation, regridding
\par{\tenpoint
{\eightpoint\begintt
        subroutine IntpIni(n1,n2,BlcTrc)

        implicit none
        integer n1,n2
        real BlcTrc(4)

  Initialize the interpolation routines.

  Input:
    n1,n2      Size of the output image.
    BlcTrc     A real array of 4 elements, giving xlo,ylo,xhi,xhi,
               in the coord. system of the input, of the pixels which
               correspond to (1,1) and (n1,n2) in the output.
\endtt}
\par}
\module{intprd}%
\noindent Read a row of interpolated data
\newline \ 
\newline \abox{File:} \$MIR/src/subs/intpio.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} interpolation, regridding
\par{\tenpoint
{\eightpoint\begintt
        subroutine IntpRd(lu,jj,Out,IntpGet)

        implicit none
        integer lu,jj
        real Out(*)
        external IntpGet

  The user-called routine to return a row of interpolated data.

  Input:
    lu         Some user-defined value for its action routine.
    jj         The row of the output that we want.
    IntpGet    The action routine to return a row of the input.
  Output:
    Out        The interpolated output.
\endtt}
\par}
\module{intprini}%
\noindent Reinitialize the interpolation i/o routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/intpio.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} interpolation, regridding
\par{\tenpoint
{\eightpoint\begintt
        subroutine IntpRIni
        implicit none

  Reinitialize the interpolation routines. This effectively empties the
  internal buffers of the interpolation routine, but does not change
  the interpolation mapping.
\endtt}
\par}
\module{isalnum}%
\noindent Return true if char is an alphanumeric character
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      logical function isalnum ( char )
      character*1 char

 Isalnum checks if the character char is an alphanumeric character (letter or
 digit) and returns .true. if so, .false. if otherwise

 Input:
   char:    character to check
\endtt}
\par}
\module{isalpha}%
\noindent Return true if char is a letter (a-z, A-Z)
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      logical function isalpha ( char )
      character*1 char

 Isalpha checks if the character char is a letter (a-z or A-Z) and returns
 .true. if so, .false. if otherwise

 Input:
   char:    character to check
\endtt}
\par}
\module{iscoords}%
\noindent Test if input string can represent coordinates and convert it
\newline \ 
\newline \abox{File:} \$MIR/src/subs/iscoords.for
\newline \abox{Keywords:} coordinates
\newline \abox{Responsible:} Bart Wakker
\par{\tenpoint
{\eightpoint\begintt
      logical function iscoords ( mode, coords, c1, c2 )

      character*(*)    mode
      character*(*)    coords
      real             c1, c2

 This checks if the input string can represent coordinates. For mode='ra', the
 input must look like right ascension and declination, for mode='lb', it must
 be longitude and latitude. If this is not so, the return value for iscoords
 is set to false.
 Every possible check is made to ensure that the input could be right ascension
 and declination or longitude/latitude, e.g. whether hours are between 0 and
 24, minutes and seconds between 0 and 59, etc.

 Input:
   mode:      determines whether input must represent right ascension and
              declination (mode='ra') or longitude and latitude (mode='lb').
   coords:    a string that could represent coordinates.

 Output:
   c1, c2:    specified coordinates in radians
\endtt}
\par}
\module{isdigit}%
\noindent Return true if char is 0, 1, 2, 3, 4, 5, 6, 7, 8 or 9
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      logical function isdigit ( char )
      character*1 char

 isdigit checks if the character char is a digit (0-9) and returns .true. if
 so, .false. if otherwise

 Input:
   char:    character to check
\endtt}
\par}
\module{islower}%
\noindent Return true if char is a lowercase letter (a-z)
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      logical function islower ( char )
      character*1 char

 Islower checks if the character char is a lowercase letter (a-z) and returns
 .true. if so, .false. if otherwise

 Input:
   char:    character to check
\endtt}
\par}
\module{ismax}%
\noindent Return index of maximum value of a real array.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function ismax(n,data,step)

        implicit none
        integer n,step
        real data(*)

  Find the index of the maximum value of a real array.

  Input:
    n          Number of elements to be searched.
    data       The real array to be searched.
    step       Skip distance between elements of the searched array.
  Output:
    ismax      Index of the maximum value in the array.

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{ismin}%
\noindent Return index of minimum value of a real array.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function ismin(n,data,step)

        implicit none
        integer n,step
        real data(*)

  Find the index of the minimum value of a real array.

  Input:
    n          Number of elements to be searched.
    data       The real array to be searched.
    step       Skip distance between elements of the searched array.
  Output:
    ismin      Index of the minimum value in the array.

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isrchfge}%
\noindent Search real vector for target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function isrchfge(n,array,inc,target)

        implicit none
        integer n,inc
        real array(*),target

  Isrchfge returns the first location in a real array that is greater
  than or equal to the real target.

  Inputs:
    n          Number of elements to be searched.
    array      The real array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Real value searched for in the array. If target is not
               found, then the routine returns n+1.
  Output:
    isrchfge   Index of the first occurrence of greater or equal to "target".

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isrchfgt}%
\noindent Search real vector for target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function isrchfgt(n,array,inc,target)

        implicit none
        integer n,inc
        real array(*),target

  Isrchfgt returns the first location in a real array less than a target value.

  Inputs:
    n          Number of elements to be searched.
    array      The real array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Real value searched for in the array. If all elements
               in the array are greater than or equal to "target", then
               the routine returns n+1.
  Output:
    isrchflt   Index of the element less than "target".

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isrchfle}%
\noindent Search real vector for target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function isrchfle(n,array,inc,target)

        implicit none
        integer n,inc
        real array(*),target

  Isrchfle returns the first location in a real array less than or equal to
  a target value.

  Inputs:
    n          Number of elements to be searched.
    array      The real array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Real value searched for in the array. If all elements
               in the array are greater than "target", then
               the routine returns n+1.
  Output:
    isrchfle   Index of the element less than or equal to "target".

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isrchflt}%
\noindent Search real vector for target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function isrchflt(n,array,inc,target)

        implicit none
        integer n,inc
        real array(*),target

  Isrchflt returns the first location in a real array less than a target value.

  Inputs:
    n          Number of elements to be searched.
    array      The real array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Real value searched for in the array. If all elements
               in the array are greater than or equal to "target", then
               the routine returns n+1.
  Output:
    isrchflt   Index of the element less than "target".

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isrchieq}%
\noindent Search integer vector for target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function isrchieq(n,array,inc,target)

        implicit none
        integer n,inc
        integer array(*),target

  Isrchieq returns the first location in an integer array that is equal
  to the integer target.

  Inputs:
    n          Number of elements to be searched.
    array      The integer array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Integer value searched for in the array. If target is not
               found, then the routine returns n+1.
  Output:
    isrchieq   Index of thefirst occurrence of "target".

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isrchige}%
\noindent Search integer vector for target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function isrchige(n,array,inc,target)

        implicit none
        integer n,inc
        integer array(*),target

  Isrchige returns the first location in an integer array that is greater
  or equal to the integer target.

  Inputs:
    n          Number of elements to be searched.
    array      The integer array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Integer value searched for in the array. If target is not
               found, then the routine returns n+1.
  Output:
    isrchieq   Index of the first occurrence of something greater or equal
               to the integer target.

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isrchigt}%
\noindent Search integer vector for target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function isrchigt(n,array,inc,target)

        implicit none
        integer n,inc
        integer array(*),target

  Isrchigt returns the first location in an integer array that is greater than
  the integer target.

  Inputs:
    n          Number of elements to be searched.
    array      The integer array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Integer value searched for in the array. If target is not
               found, then the routine returns n+1.
  Output:
    isrchigt   Index of the first occurrence of something greater than
               "target".

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isrchile}%
\noindent Search integer vector for target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function isrchile(n,array,inc,target)

        implicit none
        integer n,inc
        integer array(*),target

  Isrchile returns the first location in an integer array that is less than
  of equal to the integer target.

  Inputs:
    n          Number of elements to be searched.
    array      The integer array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Integer value searched for in the array. If target is not
               found, then the routine returns n+1.
  Output:
    isrchieq   Index of the first occurrence of something less than or
               equal to "target".

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isrchilt}%
\noindent Search integer vector for target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function isrchilt(n,array,inc,target)

        implicit none
        integer n,inc
        integer array(*),target

  Isrchilt returns the first location in an integer array that is less 
  than the integer target.

  Inputs:
    n          Number of elements to be searched.
    array      The integer array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Integer value searched for in the array. If target is not
               found, then the routine returns n+1.
  Output:
    isrchilt   Index of the first occurrence of something less than "target".

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isrchine}%
\noindent Search integer vector for target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        integer function isrchine(n,array,inc,target)

        implicit none
        integer n,inc
        integer array(*),target

  Isrchine returns the first location in an integer array that is not equal
  to the integer target.

  Inputs:
    n          Number of elements to be searched.
    array      The integer array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Integer value searched for in the array. If all elements
               in the array are equal to "target", then the routine
               returns n+1.
  Output:
    isrchine   Index of the element not equal to "target".

  Reference:
  See page 4-59 to 4-64 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{isupper}%
\noindent Return true if char is an uppercase letter (A-Z)
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      logical function isupper ( char )
      character*1 char

 Isupper checks if the character char is an uppercase letter (A-Z) and returns
 .true. if so, .false. if otherwise

 Input:
   char:    character to check
\endtt}
\par}
\module{itime}%
\noindent Returns the present date.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/vmsdate.for
\newline \abox{Keywords:} vms, utilities
\newline \abox{Responsible:} Robert Sault
\par{\tenpoint
{\eightpoint\begintt
      subroutine itime(iarray)

      implicit none
      integer iarray(3)

 Input:
   none
 Output:
   iarray   An integer array containing the current time.  The order
            is: hour, minute, second.
\endtt}
\par}
\module{itoa}%
\noindent Convert an integer into a string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        character*(*) function itoa(n)

        implicit none
        integer n

  Convert an integer into its ascii representation. It is returned
  left justified.

  Input:
    n          The integer to convert.
  Output:
    itoa       The formated integer, left justified.
\endtt}
\par}
\module{j1xbyx}%
\noindent Calculate j1(x)/x
\newline \ 
\newline \abox{File:} \$MIR/src/subs/j1xbyx.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} special-functions, bessel-functions, mathematics
\par{\tenpoint
{\eightpoint\begintt
        real function j1xbyx(arg)

        implicit none
        real arg

   J1xByx calculates the bessel function,  j1(x)/x  from the
   polynomial approximations. See Abramowitz and Stegun, Handbook of
   Mathematical Functions, sections 9.4.4 and 9.4.6, page 370.

  Input:
    arg        The value of x.
  Output:
    j1xbyx     The calculated value of j1(x)/x
\endtt}
\par}
\module{julday}%
\noindent Format a Julian day into a conventional calendar day.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/julday.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} julian-day, date, utilities
\par{\tenpoint
{\eightpoint\begintt
      subroutine julday(julian, form, calday)

      implicit none
      double precision julian
      character form*(*), calday*(*)

  Convert from Julian date to calendar date.  This is not to high
  accuracy, but it achieves the accuracy required.  See "Astronomical
  Formulae for Calculators", Jean Meeus (Wiillmann-Bell Inc).
  The day is assumed to begin at 0 hours UT.

  Input:
    julian      Julian date.
    form       Output selection flag (Must be either 'H' or 'D').

  Output:
    calday      (Gregorian) Calendar day (UT time).
                The output if form = 'D' is like:
                       'yymmmdd.dd'
                The output if form = 'H' is like:
                       'yymmmdd:hh:mm:ss.s'
\endtt}
\par}
\module{keya}%
\noindent Retrieve a character string from the command line.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine keya(key,value,default)

        implicit none
        character key*(*)
        character value*(*),default*(*)

  Retrieve a character string from the command line. If the keyword is
  not found, the default is returned.

  Input:
    key        The name of the keyword to return.
    default    The default value to return, if the keyword is not present
               on the command line.
  Output:
    value      The returned value.
\endtt}
\par}
\module{keyd}%
\noindent Retrieve a double precision from the command line.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine keyd(key,value,default)

        implicit none
        character key*(*)
        double precision value,default

  Retrieve a double precision value from the command line. If the keyword is
  not found, the default is returned.

  Input:
    key        The name of the keyword to return.
    default    The default value to return, if the keyword is not present
               on the command line.
  Output:
    value      The returned value.
\endtt}
\par}
\module{keyf}%
\noindent Retrieve a filename string (with wildcards) from the command line.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine keyf(key,value,default)

        implicit none
        character key*(*)
        character value*(*),default*(*)

  Retrieve a character string from the command line. If the keyword is
  not found, the default is returned.

  Input:
    key        The name of the keyword to return.
    default    The default value to return, if the keyword is not present
               on the command line.
  Output:
    value      The returned value.
\endtt}
\par}
\module{keyfin}%
\noindent Finish access to the 'key' routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine keyfin

        implicit none

  A call to KeyFin indicates that all parameters (that the program wants)
  have been retrieved from the command line. KeyFin makes sure all
  command line parameters have been read.
\endtt}
\par}
\module{keyi}%
\noindent Retrieve an integer from the command line.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine keyi(key,value,default)

        implicit none
        character key*(*)
        integer value,default

  Retrieve an integer value from the command line. If the keyword is
  not found, the default is returned.

  Input:
    key        The name of the keyword to return.
    default    The default value to return, if the keyword is not present
               on the command line.
  Output:
    value      The returned value.
\endtt}
\par}
\module{keyini}%
\noindent Initialise the `key' routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine keyini

        implicit none

  Keyini obtains the command line, and performs some initial parsing
  of it, breaking it up into its keyword=value pairs.
  It also remembers the name of the program, which is currently only
  used by the bug routines.
\endtt}
\par}
\module{keyl}%
\noindent Retrieve a logical value from the command line
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE keyl(key,val,def)

        IMPLICIT NONE
        CHARACTER key*(*)
        LOGICAL   val, def

 Retrieve a logical value from the command line. If the keyword is
 not found, the default is returned.
 It detects, case insensitive, words starting with 'y', 't' and '1'
 with .TRUE. and words starting with 'n', 'f' and '0' with .FALSE.

    Input:
        key      The name of the keyword to return.
        def      The default value to return, if the keyword is not present
                    on the command line.
      Output:
        val      The returned value.
\endtt}
\par}
\module{keyprsnt}%
\noindent Determine if a keyword is present on the command line.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        logical function keyprsnt(key)

        implicit none
        character key*(*)

  Determine if a parameter is still present.

  Input:
    key        The keyword to check for.

  Output:
    keyprsnt   Indicates whether the keyword is present.
\endtt}
\par}
\module{keyr}%
\noindent Retrieve a real value from the command line.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine keyr(key,value,default)

        implicit none
        character key*(*)
        real value,default

  Retrieve a real value from the command line. If the keyword is
  not found, the default is returned.

  Input:
    key        The name of the keyword to return.
    default    The default value to return, if the keyword is not present
               on the command line.
  Output:
    value      The returned value.
\endtt}
\par}
\module{lcase}%
\noindent Convert a string to lower case.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        subroutine lcase(string)

        implicit none
        character string*(*)

  Convert a string to lower case.

  Input/Output:
    string     The string to be converted to lower case.
\endtt}
\par}
\module{len1}%
\noindent Determine the unpadded length of a character string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        integer function len1(string)

        implicit none
        character string*(*)

  This determines the unblanked length of a character string.

  Input:
    string     The character string that we are interested in.
  Output:
    len1       The unpadded length of the character string.
\endtt}
\par}
\module{linetype}%
\noindent Read standard linetype keyword and transfer information to uvio
\newline \ 
\newline \abox{File:} \$MIR/src/subs/linetype.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} text-i/o, utilities
\par{\tenpoint
{\eightpoint\begintt
      subroutine linetype( unit, line, type )

      integer       unit
      real          line(4)
      character*(*) type

 Returns the values of the linetype keyword in an array and also
 does the call to uvset to tell uvio which linetype was selected.
 It sets the default linetype to 'channel,0,1,1,width', i.e. all
 channels (nchan=0), and a step equal to the width.
 Furthermore some checking on the consistency of the input is done.

 Input:
    unit        the logical unit number of the visibility file

 Output:
    type        the linetype ('channel', 'wide' etc)
    line        condensed form for: nchan,start,width,step.
\endtt}
\par}
\module{linlsq}%
\noindent Return parameters of a straight line fit
\newline \ 
\newline \abox{File:} \$MIR/src/subs/lsqu.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} least-squares
\par{\tenpoint
{\eightpoint\begintt
      subroutine linlsq( xarr,yarr,npnt, a1,b1,a2,b2, sigx,sigy,corr )

      real           xarr(*)
      real           yarr(*)
      integer        npnt
      real           a1, a2, b1, b2
      real           sigx, sigy, corr

 This routine returns the parameters of a linear least squares fit to the
 relation defined by xarr and yarr.

 Input:
   xarr:         the x values
   yarr:         the y values
   npnt:         number of elements of xarr and yarr

 Output:
   a1, b1:       coefficients of the relation x=a1*y+b1
   a2, b2:       coefficients of the relation y=a2*x+b2
   sigx, sigy:   rms values of x and y
   corr:         correlation coefficient
\endtt}
\par}
\module{llsqu}%
\noindent Linear least squares fitting
\newline \ 
\newline \abox{File:} \$MIR/src/subs/lsqu.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} least-squares, fitting
\par{\tenpoint
{\eightpoint\begintt
        subroutine llsqu(f,A,n,m,c,ifail,B,pivot)

        implicit none
        integer m,n,ifail,pivot(n)
        real f(m),A(n,m),c(n),B(n,n)

  Solve a linear least squares problem in "n" unknowns, and "m" equations.
  As usual, m must be greater or equal to n.

  The problem is solved by finding:
                                       t
                                 y' = A y

  and                                  t
                                 B  = A A

  then solving this system of linear equations.

  The LINPACK routines SGEFA and SGESL are called to solve a system of
  linear equations.

  Inputs:
    n          Number of unknowns.
    m          Number of equations.
    f          Function values for the m equations.
    A          The matrix giving the weights for each equation.

  Scratch:
    B
    pivot

  Output:
    c          The solution coefficients.
    ifail      Success status:
                 0     Finished OK.
                 1     Singular matrix encountered.
\endtt}
\par}
\module{logclose}%
\noindent Finish up with the log file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/log.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} text-i/o, log-file
\par{\tenpoint
{\eightpoint\begintt
        subroutine LogClose

        implicit none

  This completes access to the log file or terminal, and closes is it up.
  In case the logfile was '/printer', it sends that file to a printer
  (yet to be determined how and which one, in a system independand way)
  (environment variable??)
\endtt}
\par}
\module{logopen}%
\noindent Initialise the log file routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/log.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} text-i/o, log-file
\par{\tenpoint
{\eightpoint\begintt
        subroutine LogOpen(name,flags)

        implicit none
        character name*(*),flags*(*)

  This initialises the log file routines, and opens an output log file.

  Inputs:
    name       Name of the file to open. If this is blank, then output
               is directed to the users terminal. If the name is '/printer'
               at closing (LogClose) the file is sent to printer
    flags      A parameter giving additional options to the routine. This
               consists of a character string, with each character signifying
               some particular option. Possible values are:
                ' '    Just write every to output device on every call
                       to logwrite.
                'q'    Query. If the output is a terminal, after every
                       22 lines, the user is queried if he/she wants to
                       continue. See also documentation of LogWrite and
                       LogWrit.                        
                'p'    Pack. When many consecutive output lines are identical,
                       the pack option replaces them with one output line
                       followed by another line telling how many repetitions.
                       Currently ignored.
\endtt}
\par}
\module{logwrit}%
\noindent Write a line to the log file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/log.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} text-i/o, log-file
\par{\tenpoint
{\eightpoint\begintt
        subroutine LogWrit(line)

        character line*(*)

  This writes a line to the log file or the users terminal.
  If LogOpen was called with option 'q', LogWrit stops the
  task if the user specifies 'quit' as answer.
  See also LogWrite.

  Input:
    line       Line to write.
\endtt}
\par}
\module{logwrite}%
\noindent Write a line to the log file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/log.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} text-i/o, log-file
\par{\tenpoint
{\eightpoint\begintt
        subroutine LogWrite(line,more)

        implicit none
        character line*(*)
        logical more

  This writes a line to the log file or the users terminal.
  If LogOpen was called with option 'q' then LogWrite will
  return a .FALSE. value in more when the user specifies 'quit'.
  The applications program then has to take care of stopping.

  Input:
    line       Line to write.
  Output:
    more       Set to false if the user has had enough.
\endtt}
\par}
\module{lsqfill}%
\noindent Add sums-of-squares to least squares matrix
\newline \ 
\newline \abox{File:} \$MIR/src/subs/polyfit.for
\newline \abox{Keywords:} polynomials, least squares matrix, calibration
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        subroutine lsqfill( count, X, Y, pmax )

        integer count, pmax
        real X(*), Y(*)
  Inputs:
       count -- the number of data points
       X     -- independent variable
       Y     -- dependent variable
       pmax  -- polynomial order of fit
\endtt}
\par}
\module{match}%
\noindent Check if a string occurs in a list of valid strings
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      logical function match ( input, valid_strings, nr )
      character*(*) input
      character*(*) valid_strings
      integer       nr

 match does a minimal match of the input string 'input' on the comma-separated
 list of valid strings. It also returns the string number.

 On output the value of match indicates whether or not any match was found.
 This implies that the input variable input can not be an explicit string,
 but must be a declared character variable.
 The matching is minimal, that means that if e.g. valid_strings has the value
 'terminal,printer,file' and input is 'f', a match is produced. The return
 value of nr will be 3.
 
 Input:
   input:         the string of which it has to be checked if it matches
   valid_strings: a comma-separated list of valid input strings
 Output:
   nr:            the string number of input; 0 if there was no match
\endtt}
\par}
\module{matchdcd}%
\noindent Check if a string occurs in a list of valid strings, with extras
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      logical function matchdcd( input,valid_strings,nr,logsc,cum,abs )

      character*(*) input
      character*(*) valid_strings
      integer       nr
      logical       logsc
      logical       cum
      logical       abs
    
 In the notation below, an exclamation point (!) refers to the logical ``or''
 symbol.  When calling this subroutine, use the logical ``or'' symbol wherever
 an exclamation point (!) is used in this documentation.
\endtt}
{\eightpoint\begintt
 matchdcd does a minimal match of the input string 'input' on the
 comma-separated list of valid strings. It also returns the string number.
 Depending on the values of the logical variables logsc, cum and abs, it allows
 the input string to be c preceded by 'log' or '>' or to be surrounded by '!',
 respectively, returning whether this was the case or not in the same logicals.
 If such special options are present, they will be stripped from the input
 string. I.e. if input was "!x!" and abs=true, on exit input will be "x".
\endtt}
{\eightpoint\begintt
 On exit the value of matchdcd indicates whether or not any match was found. If
 no match was produced nr is zero on exit.

 The matching is minimal, that means that if valid_strings has the value
 'mass,flux,nh' and input is 'f', a match is produced. The return value of nr
 will be 2. On exit input will be set equal to the full string that was
 matched.
 If the input string is preceded by the string 'exact:' the minimal matching
 feature is turned off and only exact matches produce a return value true.
\endtt}
{\eightpoint\begintt
 If on input logsc is true, it will be true on output if input was 'logmass',
 but false if input was 'mass'.
 If on input cum is true, it will be true on output if input was '>flux', but
 false if input was 'flux'.
 If on input abs is true, it will be true on output if input was '!x!', but
 false if input was 'x'.
 These three variables can be combined, i.e. the input can be 'log>!x!'. If
 logsc, cum or abs are false on input, these possibilities are disabled. If all
 three are false, a call to function match may be more useful.
\endtt}
{\eightpoint\begintt
 Input:
   input:         the string of which it has to be checked if it matches
   valid_strings: a comma-separated list of valid input strings
 Output:
   nr:            the string number of input; 0 if there was no match
 Input/Output:
   logsc:         if true on input: input string may be preceded by log
                  output indicates whether it was or not
                  if false on input: input string can not be preceded by log
   cum:           if true on input: input string may be preceded by >
                  output indicates whether it was or not
                  if false on input: input string can not be preceded by >
   abs:           if true on input: input string may be surrounded by !
                  output indicates whether it was or not
                  if false on input: input string can not be surrounded by !
\endtt}
\par}
\module{miniflip}%
\noindent Flip phases into a continuous string
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calphase.for
\newline \abox{Keywords:} calibration, line up phases
\newline \abox{Responsible:} Lee Mundy
\par{\tenpoint
{\eightpoint\begintt
      SUBROUTINE miniflip(npts,phas,flips)

      INTEGER npts, flips(*)
      REAL    phas(*)

   Input:
       npts:   Number of points in phases array
       phas:   phases to be played with in radians

   Output:
       phas:   output phases nicely unwrapped
       flips:  record of number of 2pi flips applied to each point

   miniFlip attempts to correct the phases for phase wrapping
   It uses vector averaging, and hence needs to be supplied
   with an array specifiying how vector averaging is done.
   The source code is full of witty comments how it really
   works.
\endtt}
\par}
\module{mitoa}%
\noindent Convert many integers into a string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        subroutine mitoa(array,n,line,length)

        implicit none
        integer n,array(n),length
        character line*(*)

  Convert multiple integers to a neatly formatted character string.

  Input:
    array      Array of integers to be converted to a string.
    n          Number of integers.

  Output:
    line       The formatted string. Integers are separated by
               commas (no blanks).
    length     The length of the line.
\endtt}
\par}
\module{mkeya}%
\noindent Retrieve multiple character values from the command line.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine mkeya(key,value,nmax,n)

        implicit none
        integer nmax, n
        character key*(*)
        character value(nmax)*(*)

  Retrieve multiple character values from the command line. If the keyword is
  not found, then empty strings are returned. 

  Input:
    key        The name of the keyword to return.
    nmax       The maximum number of values to return
  Output:
    n          The number of values returned.
    value      The returned values
\endtt}
\par}
\module{mkeyf}%
\noindent Retrieve multiple filenames.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine mkeyf(key,value,nmax,n)

        implicit none
        integer nmax,n
        character key*(*),value(nmax)*(*)

  Return a number of filenames. Wildcard expansion of the names is
  performed.

  Input:
    key        The name of the keyword.
    nmax       The maximum number of names to return.
  Output:
    value      The actual filenames.
    n          The number of filenames returned.
\endtt}
\par}
\module{mkeyi}%
\noindent Retrieve multiple integer values from the command line.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine mkeyi(key,value,nmax,n)

        implicit none
        integer nmax, n
        character key*(*)
        integer value(nmax)

  Retrieve multiple integer values from the command line. If the keyword is
  not found, then zero values are returned. 

  Input:
    key        The name of the keyword to return.
    nmax       The maximum number of values to return
  Output:
    n          The number of values returned.
    value      The returned values
\endtt}
\par}
\module{mkeyr}%
\noindent Retrieve multiple real values from the command line.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line
\par{\tenpoint
{\eightpoint\begintt
        subroutine mkeyr(key,value,nmax,n)

        implicit none
        integer nmax, n
        character key*(*)
        real value(nmax)

  Retrieve multiple real values from the command line. If the keyword is
  not found, then zero values are returned. 

  Input:
    key        The name of the keyword to return.
    nmax       The maximum number of values to return
  Output:
    n          The number of values returned.
    value      The returned values
\endtt}
\par}
\module{model}%
\noindent Calculate model visibilities, given a model image.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/model.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} model
\par{\tenpoint
{\eightpoint\begintt
        subroutine Model(flags,tvis,tmod,offset,level,tscr,
     *                                  nhead,header,nchan,nvis)

        implicit none
        character flags*(*)
        integer tmod,tvis,tscr,nchan,nhead,nvis
        real offset(2),level
        external header
\endtt}
{\eightpoint\begintt
  Calculate the model data corresponding to a visibility data file.
  The model can either be a point source, or a full map. If the model
  is a full image cube, then the image is FFTed, and an interpolation
  scheme is used to determine the corresponding visibility model.
\endtt}
{\eightpoint\begintt
  Input:
    tvis       The visibility data file. The caller can set up the uv file
               using the uvselect and uvset routines.
\endtt}
{\eightpoint\begintt
    tmod       The model image file. If this is 0, then the input model
               is assumed to be a point source.
\endtt}
{\eightpoint\begintt
    flags      This selects extra processing options. It is a character
               string, each character of which has the following meaning:
                'c'  Calibration scaling. Look up the source in the
                     calibrators file, to determine the flux of the source.
                'a'  Autoscale. After model calculation, the model is scaled
                     so that it has the same power as the visibilities.
                'h'    Use image header for phase center.
\endtt}
{\eightpoint\begintt
    offset     The offset, in arcsec, in RA and DEC, of the point
               source model. This is only used if tmod.eq.0.
\endtt}
{\eightpoint\begintt
    level      Either a clip level to apply to the data (tmod.ne.0), or
               the amplitude of the point source (tmod.eq.0).
\endtt}
{\eightpoint\begintt
    nhead      Number of "header" values to write out to the scratch file.
               These are filled in by the "header" routine. If "nhead" is
               zero, header is not called.
\endtt}
{\eightpoint\begintt
    header     A service routine called after each visibility record
               is processed. Arguments to this routine are:
                 subroutine header(tvis,preamble,data,flags,nchan,
                   accept,Out,nhead)
               where
                 Input:
                   tvis        Handle of the visibility file.
                   nhead       The value of nhead
                   nchan       The number of channels.
                 Input/Output(?):
                   preamble    Preamble returned by uvread.
                   data        A complex array of nchan elements, giving
                               the correlation data.
                   flags       The data flags.
                 Output:
                   out         The nhead values to save with the data.
                   accept      This determines whether the data is
                               accepted or discarded.
\endtt}
{\eightpoint\begintt
  Output:
    tscr       Output scratch file containing the data.
    nchan      The number of channels in the scratch file.
    nvis       The number of visibilities written to the scratch file.
\endtt}
{\eightpoint\begintt
  In the output scratch file, there are nhead + 5*nchan values per
  visibility record processed. The "nhead" values are filled in by
  the "header" routine. The 5 values per channel consist of
       real(vis),aimag(vis),real(model),aimag(model),flag
  Where "vis" and "model" are the visibility and model data. "Flag" is
  either positive or negative, indicating whether this visibility is
  deemed good or bad.
\endtt}
{\eightpoint\begintt
  Bugs and Shortcomings:
    * The FFT of the entire cube must fit into memory.
    * Disk models (planets) are not supported.
    * Calibration scaling is not handled yet.
    * It would be nice to give a frequency-independent model, and
      replicate it for all planes. Strictly we should do some extra
      stretching of the model at different frequencies.
\endtt}
\par}
\module{modelini}%
\noindent Ready the uv data file for processing by the Model routine.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/model.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} model
\par{\tenpoint
{\eightpoint\begintt
        subroutine ModelIni(tmod,tvis,sels,flags)

        implicit none
        integer tmod,tvis
        character flags*(*)
        real sels(*)

  This performs some standard setting up of the visibility data file,
  ready for model calculation. This routine can easily be replaced
  by a more appropriate user routine if necessary. In particular,
  the steps performed are: rewind the uv data file, setup the line
  type, resets the uv-selection criteria, and then "AND"s in a specification
  to make sure we only get data with the same pointing centre. We skip
  this pointing centre processing if we find that the visibility file
  does not contain pointing offsets.

  Inputs:
    tmod       The handle of the model image.
    tvis       The handle of the input visibility data.
    sels       The uv selection intermediate array.
    flags      A character variable, each character of which specifies
               a processing stp.
                'l'    Set up the linetype.
                'p'    Set up the pointing parameters.
\endtt}
\par}
\module{nel}%
\noindent Return the number used values in an array
\newline \ 
\newline \abox{File:} \$MIR/src/subs/utilities.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} utilities
\par{\tenpoint
{\eightpoint\begintt
      integer          function neli ( i, ni )
      integer          function nelr ( r, nr )
      integer          function neld ( d, nd )
      integer          i(ni)
      real             r(nr)
      double precision d(nd)
      integer          ni, nr, nd

 Nel returns the index of the last used element of the input array, i.e. it
 gives the used length of the array. The result is 0 if all elements are 0 and
 nx if all elements are non-zero. Nelr works on real arrays, neli on integer
 arrays and neld on double precision arrays.

 Input:
   i/r/d:      input array
   ni/nr/nd:   number of elements of input array
\endtt}
\par}
\module{nelc}%
\noindent Return the length of the string
\newline \ 
\newline \abox{File:} \$MIR/src/subs/utilities.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} utilities, strings
\par{\tenpoint
{\eightpoint\begintt
      integer function nelc(string)
      character string*(*)

 Nelc finds the number of characters in a string before a zero byte, discarding
 trailing spaces.

 Input:
   string:   string to determine the length of
\endtt}
\par}
\module{nextpow2}%
\noindent Find the next power of two.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/nextpow2.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} numbers, mathematics
\par{\tenpoint
{\eightpoint\begintt
      integer function nextpow2 (k)

      implicit none
      integer k

  Find next integer, which is a power of two, greater than or equal to k.

  Input:
    k          Number of interest.
  Output:
    nextpow2   Next power of 2 higher than or equal to k.
\endtt}
\par}
\module{nfig}%
\noindent Find number of digits in a number
\newline \ 
\newline \abox{File:} \$MIR/src/subs/utilities.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} utilities
\par{\tenpoint
{\eightpoint\begintt
      integer          function nfigi ( ivalue )
      integer          function nfigr ( rvalue )
      integer          function nfigd ( dvalue )
      integer          ivalue
      real             rvalue
      double precision dvalue

 nfigi returns the number of digits of an integer number, e.g. nfigi(4)=1,
 nfigi(55)=2, nfigi(-10)=3 etc.
 nfigr returns the number of digits in the integer part of a real number. I.e.
 nfigr(1.)=1, nfigr(1.01)=1, nfigr(555.)=3, nfigr(-10.)=3 etc.
 nfigd returns the number of digits in the integer part of a double precision
 number. I.e. nfigd(1.d0)=1, nfigd(1.01d0)=1, nfigd(-10.d0)=3 etc.

 Input:
   value:     value to work on
\endtt}
\par}
\module{nllsqu}%
\noindent Nonlinear least squares fitting
\newline \ 
\newline \abox{File:} \$MIR/src/subs/lsqu.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} least-squares, fitting
\par{\tenpoint
{\eightpoint\begintt
        subroutine nllsqu(n,m,x,h,itmax,eps1,eps2,der,ifail,
     *    FUNCTION,DERIVE,f,fp,dx,dfdx,aa)

        implicit none
        integer n,m,itmax,ifail
        real eps1,eps2,x(n),h(n)
        logical der
        external FUNCTION,DERIVE

        real f(m),fp(m),dx(n),dfdx(n,m),aa(n,n)

  NLLSQU minimizes the sum of squares, and solves a set of nonlinear
  equations. This is derived from H. Spath, "The damped Taylors series
  method for minimizing a sum of squares and solving systems of nonlinear
  equations." Comm. ACM v10, n11, p726-728.

  There have been some modifications to the algorithm as presented in CACM.
  In particular the call sequence is different, and the algorithm has been
  mildly improved in a few places.

  Inputs:
    n          Number of unknowns.
    m          Number of nonlinear equations.
    itmax      Max no of iterations.
    eps1       Iteration stops if (sum f**2) < eps1
    eps2       Iteration stops if eps2 * sum (abs(x)) < sum( abs(dx) )
    der        Logical. If true, then the derivative routine is called. If
               false, the derivative is estimated by many calls to FUNCTION.
    h          This is used ONLY if der=.false. It gives the step sizes
               to use in estimating partial derivatives.
  Input/Output:
    x          Input: Initial estimate of solution.
               Output: The best solution so far.

  Scratch:
    f
    fp
    dx
    dfdx
    aa

  Outputs:
    ifail      ifail = 0 All OK.
                       1 Singular matrix encountered.
                       2 Max number of iterations exceeded.
                       3 Failure to find better solution.

  Externals:
       The external FUNCTION must be implemented. But DERIVE is not
       needed if "der" is set false.

c      subroutine DERIVE(x,dfdx,n,m)
c      real x(n),dfdx(n,m)
c Inputs:
c      x       Prospective solution.
c Outputs:
c      dfdx    Derivatives of the nonlinear equation for this particular
c              value of x.
c
c      subroutine FUNCTION(x,f,n,m)
c      real x(n),f(m)
c Inputs:
c      x       Prospective solution.
c Outputs:
c      f       Value of the m nonlinear equations, given x.
\endtt}
\par}
\module{oneamp}%
\noindent Convert visibility to amp/phase or real/imag
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvsubs.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} complex-data, uv-data
\par{\tenpoint
{\eightpoint\begintt
        real function oneamp(vis,flag)

        implicit none
        complex vis
        character*(*) flag

  Converts a complex vis to 'Amp' 'Phase' 'Real' 'Imag' part.

  Input:
    vis        complex,input)   visibility
    flag       One of : 'a' 'p' 'r' 'i'
  Output:
               The amplitude, phase(degrees), real, or imaginary part.
\endtt}
\par}
\module{options}%
\noindent Get command line options.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/options.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} user-input
\par{\tenpoint
{\eightpoint\begintt
        subroutine Options(key,opts,present,nopt)

        implicit none
        character key*(*)
        integer nopt
        character opts(nopt)*(*)
        logical present(nopt)

  Get options from the command line, and return to the caller those
  options that are present. For example, assume the task keyword is
  "options", and that possible options are, say, display,movie,fiddle, etc
  then this examines the command line:
    task options=fiddle
  and returns indicating that "fiddle" was present, but "display" and
  "movie" were absent.
  This will allow the user to abbreviate options to uniqueness, and will
  generate an error if there is an ambiguous option.

  Inputs:
    key        The task keyword to use.
    opts       An array of possible option values.
    nopt       The number of possible options.
  Output:
    present    This indicates whether the option was present.
\endtt}
\par}
\module{output}%
\noindent Output a line of text to the user.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/txtio.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} terminal-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine output(line)

        implicit none
        character line*(*)

  Output writes a line of text to the standard output (usually the users
   terminal).

  Input:
    line       The line of text to write. Only the significant part
               of the string 'line(1:len1(line))' is output
\endtt}
\par}
\module{packi2}%
\noindent Pack normal integers into 16 bit integers
\newline \ 
\newline \abox{File:} \$MIR/src/subs/packi2.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} low-level-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine packi2(in,out,n)

        implicit none
        integer n
        integer in(n)
        integer*2 out(n)

  Pack normal integers into the 16 bit integers, with the bytes in
  "network" order.

  Input:
    n          Number of integers to pack.
    in         Integers to pack.
  Output:
    out        Output integer*2, in "network" order.
\endtt}
\par}
\module{padleft}%
\noindent Right justify a string to length characters.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      subroutine padleft(string, length)

      implicit none
      character string*(*)
      integer length

  Right-justify a string to a specified length.

  Inputs:
    string        The string to be padded.
    length        The length of the string after padding.
  Outputs:
    string        The string with spaces added to the left.
\endtt}
\par}
\module{pgerase}%
\noindent Erase the screen - and nothing more
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine pgerase
        implicit none

  Erase screen -- and nothing more.
\endtt}
\par}
\module{pghline}%
\noindent Histogram line plot for pgplot.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/pghline.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} plotting, uv-data
\par{\tenpoint
{\eightpoint\begintt
        subroutine PgHline(npts,x,y,gapfac)

        implicit none
        integer npts
        real x(npts), y(npts), gapfac

  Histogram style line plot of y-array versus x-array. Points are not
  connected over gaps or reversals in the x-array.

  Inputs:
    npts       number of points
    x          x-array to be plotted
    y          y-array to be plotted
    gapfac     factor to define a gap in x-array. E.g. 2= 2*(x(i+1)-x(i)) 
\endtt}
\par}
\module{phase}%
\noindent Extract phase in radians from complex number
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvsubs.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} complex-data, uv-data
\par{\tenpoint
{\eightpoint\begintt
        real function phase(vis)

  Extracts the phase (radians) from a complex number.

  Input:
    vis        complex number
\endtt}
\par}
\module{phaseamp}%
\noindent Convert to phase/amplitude
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calphase.for
\newline \abox{Keywords:} calibration, phases
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE phaseamp( nbase, basediff, mark )

        INTEGER nbase, basediff(2, *)
        LOGICAL mark

       PhaseAmp converts the Rdata() from Real-Imag to Amp-Phase
       and also returns a list of 2pi wraps needed for closure
 NOTE:
       It's use is now OBSOLETE since the new flipper(). A bug('w',
       is called when phaseamp is used!
       
  Inputs:
       nbase    -- number of baselines used in basediff array
       mark     -- whether to also mark unclosed data as bad in 'rflags'

  Outputs:
       basediff -- list of 2pi wraps needed for closure
\endtt}
\par}
\module{phasedis}%
\noindent Find consistent antenna phases
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calphase.for
\newline \abox{Keywords:} calibration, phases
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE phasedis( phase, wraps )

        REAL    phase(*)
        INTEGER wraps(*)

  Note: Not the most robust algorithm ever invented -- perhaps looping
        through multiple times would help
        This subroutine is OBSOLETE since it is used with 'phaseamp'

  Inputs:
       phase -- list of phases for each baseline

  Outputs:
       wraps -- list of 2pi wraps for each baseline
\endtt}
\par}
\module{phiwrap}%
\noindent Returns the number of 2pi wraps
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calphase.for
\newline \abox{Keywords:} calibration, phases
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        INTEGER FUNCTION phiwrap(phase)

        REAL phase

       function to return number of 2.PI wrap arounds

       Note: OBSOLETE, is only called by 'phaseamp'

       inputs:
           phase       -- angle to be checked
\endtt}
\par}
\module{plotone}%
\noindent Plot one or more set of x,y points on a single graph
\newline \ 
\newline \abox{File:} \$MIR/src/subs/plotone.for
\newline \abox{Responsible:} Lee Mundy
\newline \abox{Keywords:} plotting, pgplot, points
\par{\tenpoint
{\eightpoint\begintt
      subroutine PlotOne(nvals,x,dim1,dim2,npls,yarr,xlab,ylab,glab,
     -                   device)

 Makes a x,y line plot of a set of points. Multiple x,y data sets
 are drawn on the same plot page and are distinguished by different
 colors (if available on plot device) or line styles. Routine does
 automatic plot scaling and all calls to PGPLOT.

 Arguments:

 NVALS (input, integer): number of points in each data set to plot
 X (input, real)       : values for x-axis
 dim1 (input, integer) : actual first dimension of YARR
 dim2 (input, integer) : actual second dimension of YARR
 npls (input, integer) : number of data sets to be plotted
 yarr (input, real)    : array of y values, (npls,nvals)
 xlab (input, char)    : label for x-axis
 ylab (input, char)    : label for y axis
 glab (input, char)    : label for the global plot
 device(input, char)   : plot device name
\endtt}
\par}
\module{powell}%
\noindent Minimization of a function, without derivative information.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/powell.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} optimization, mathematics
\par{\tenpoint
{\eightpoint\begintt
      subroutine powell(x,e,n,f,escale,icon,mxiter,calcfx,w,maxfun,
     *                                                          ifail)

      implicit none
      integer n,icon,mxiter,maxfun,ifail
      real f,escale
      real x(n),e(n),w(n*(n+3))
      external calcfx
\endtt}
{\eightpoint\begintt
  1) Purpose.
  This subroutine finds the minimum of a function of several
  variables. It requires no derivatives. the user must provide a
  routine to evaluate the function for any values of the variables.
  i.e. the program will find a minimum of a function , f ,of n
  variables where
            f = f(x(1),x(2),x(5),...x(n))
\endtt}
{\eightpoint\begintt
  Briefly the method used is:
  Starting from a point x(1),x(2),...,x(n) the program constructs
  n+1 lines through the point and searches for a minimum of f along
  each line calling calcfx for appropriate values of f as it goes.
  x(1),x(2),x(5),x(6),....,x(n) are then re-set.   each set of n+1
  searches is called an iteration. Iterations continue until the
  minimum is found.
\endtt}
{\eightpoint\begintt
  2) Arguments:

    n          must be set to the number of variables.

    x and e    These are one dimensional arrays. on entry to the routine
               x(i) must be set to an approximation to the ith variable
               and e(i) to the accuracy to which its optimum value is
               required. On exit x(i) will be set to the calculated optimum
               value of the ith variable. It is assumed that the magnitudes
               of the parameters e(i) are approximately proportional to
               the magnitudes of the corresponding variables x(i).

    f          Thus will be set to the minimum value of the function.

    escale     This limits the maximum change in the variables at a single
               step.  x(i) will not be changed by more than escale*e(i).

    icon       This must be set to 1 or 2. It controls the ultimate
               convergence criterion (see section 5).

    maxit      The routine will be left regarless after maxit iterations 
    maxfun     have been completed, or maxfun function evaluations.

    w          Scratch array.

    ifail      Error return.
               Ifail = 0:   Success
                       1    Maximum change does not alter function
                       2    Accuracy limited by errors in calcfx.
                       3    Max iterations performed within Powell
                       4    Max function values evaluated in Powell
\endtt}
{\eightpoint\begintt
  3) Method.
  This will be published by m.j.d. powell in the july or october
  1964. computer journal. The minimum will practically never be
  found in less than n iteration. The function is calculated at
  least 2n times per iteration. The method is such that each
  iteration causes the function to decrease, except when the
  ultimate convergence criterion is being applied with icon=2.
\endtt}
{\eightpoint\begintt
  4) Subroutine calcfx.
     subroutine calcfx (n,x,f)
  must be provided by the user. n is the number of variables. x(i)
  x(2),.....x(n) are the current values of the variables. It must
  set f to the corresponding value of the function to be minimized.
  Remember that as calcfx is the name of a subroutine and is one
  of the arguments of powell  calcfx must appear in an external
  statement in any subprogram calling powell.
  e.g.
     external calcfx
\endtt}
{\eightpoint\begintt
  5) The ultimate convergence criterion.
  This will normally be satisfactory if icon is set to one.
  However if low accuracy is required or if it is suspected that the
  required accuracy is not being achieved. icon should be set to two
  and a more thorough check on the ultimate convergence will be
  made at the expense of increasing the execution time by maybe
  as much as 30 per cent. With icon=1 convergence will be assumed
  when an iteration changes each variable by less than 10 per cent
  of the required accuracy. With icon=2 such a point is found and it
  is then displaced by ten times the required accuracy in each
  variable. Minimization is continued from the new point until a
  change of less than 10per cent is again made by an iteration. The
  two estimate of the minimum are then compared.
\endtt}
{\eightpoint\begintt
  6) Recommendations.
  a) Do not set escale so small that powell must creep slowly to the
  minimum, it is only there to prevent the unlikely circumstance of
  a jump from one local minimum to another. this usually wont
  happen even if  escale is large(10**9).
  b) Set the required accuracy so that sscale is at least 100,
  c) If the answers appear to be unreasonable, try different
  initial values of the variables x(i).
\endtt}
{\eightpoint\begintt
  7) Reference.
     Powell M.J.D. (1964)  An efficient method for finding the
     minimum of a function of several variables without calculating
     derivatives. The Computer Journal, vol. 7, p. 303.
\endtt}
\par}
\module{prime}%
\noindent Returns a prime less than or equal to N.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/prime.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} numbers, mathematics
\par{\tenpoint
{\eightpoint\begintt
        integer function prime(n)

        implicit none
        integer n

  This returns a prime less than or equal to N.

  Input:
    n          Number to find a prime close to.
  Output:
    prime      The closest prime less than or equal to n.
\endtt}
\par}
\module{progname}%
\noindent Return name of the program currently running
\newline \ 
\newline \abox{File:} \$MIR/src/subs/key.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} user-input, command-line, program-name
\par{\tenpoint
{\eightpoint\begintt
        subroutine progname(name)

        implicit none
        character name*(*)

  Retrieve the name of the program currently running

  Output:
    name       The name
\endtt}
\par}
\module{prompt}%
\noindent Read input from the user
\newline \ 
\newline \abox{File:} \$MIR/src/subs/txtio.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} terminal-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine prompt(string,length,prmpt)

        implicit none
        integer length
        character string*(*),prmpt*(*)

  Read input from the standard input (usually the users terminal).

  Input:
    prmpt      Prompt string.
  Output :
    string     The string read from the terminal.
    length     The length of the string read from the terminal.
\endtt}
\par}
\module{putplane}%
\noindent Writes a portion of a plane, specified by runs format.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/plane.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} region-of-interest, runs
\par{\tenpoint
{\eightpoint\begintt
        subroutine PutPlane(lu,Run,nRun,xoff,yoff,nx,ny,In,nIn)

        implicit none
        integer lu,nRun,Run(3,nRun),nIn,xoff,yoff,nx,ny
        real In(nIn)

  Write out a subportion of a Miriad image plane. The subportion to
  write  (given in runs form).

  Input:
    lu         The handle of the output Miriad file.
    Run        The runs specifications.
    nRun       The number of runs.
    xoff,yoff  Offset to add to the runs before writing.
    nx,ny      The size of the plane.
    In         The pixel data.
    nIn        The total number of pixels in the "In" array.
\endtt}
\par}
\module{putpoly}%
\noindent Write out the phase-amplitude calibration fit
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calpoly.for
\newline \abox{Keywords:} calibration, polynomials, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE putpoly( dataset )
        IMPLICIT NONE

        CHARACTER*(*) dataset

  Inputs:
       dataset -- name of calibration data set
\endtt}
\par}
\module{putruns}%
\noindent Writes the blanking file of an image.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/plane.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} region-of-interest, runs, blanking
\par{\tenpoint
{\eightpoint\begintt
        subroutine PutRuns(lOut,Runs,nRuns,xoff,yoff,nx,ny)

        implicit none
        integer lOut,nRuns,xoff,yoff,nx,ny
        integer Runs(3,*)

  Write the runs data for the current plane.

  Input:
    lOut       The handle of the output Miriad file.
    Run        The runs specifications.
    nRun       The number of runs.
    xoff,yoff  Offset to add to the runs before writing.
    nx,ny      The size of the plane.
\endtt}
\par}
\module{putsrc}%
\noindent Write out source stuff
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsetio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE putsrc( file )

        CHARACTER*(*) file

   PutSrc Re-writes the source-names and associated values of an 
   already exisiting calibrator dataset.
   This is a very dangerous operation, and the caller better know exactly 
   what he/she is doing. It's normally called by calmake only, which looks
   up fluxes of calibrators, and fills in plstuff(4,) for each
   source.
   Now it also writes out the baseline based calibrator fluxes -
   i.e. calbflux(,)

   Input:
       file    --  name of the calibration dataset. It must already exist.
\endtt}
\par}
\module{pxtotv}%
\noindent Convert image pixels to TV device positions.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
      subroutine pxtotv(pixx, pixy, xtv, ytv)

      implicit none
      integer xtv, ytv
      integer pixx, pixy

  Convert image pixels to TV device positions and take into account
  zoom and scroll.  The input is usually the value of an image pixel
  that is going to be put on a zoomed and panned image.

  Inputs:
    pixx    I     Pixel x position after zoom and scroll.
    pixy    I     Pixel y position after zoom and scroll.

  Output:
    xtv     I     Screen x position before zoom and scroll.
    ytv     I     Screen y position before zoom and scroll.
\endtt}
\par}
\module{r8tyx}%
\noindent Radix, 8 iterations
\newline \ 
\newline \abox{File:} \$MIR/src/subs/r8tyx.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} mathematics
\par{\tenpoint
{\eightpoint\begintt
      subroutine r8tyx(nxtlt, nthpo, lengt, cs,
     *                  c0, c1, c2, c3, c4, c5, c6, c7)
\endtt}
\par}
\module{radhms}%
\noindent Write out ra and dec in hms/dms from input in radians
\newline \ 
\newline \abox{File:} \$MIR/src/subs/deghms.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} coordinates
\par{\tenpoint
{\eightpoint\begintt
      subroutine radhms ( a, d, radec )
      real          a, d
      character*(*) radec

 radhms takes as input the right ascension and declination in radians and
 constructs the string 'hh mm ss.ss sdd mm ss.ss'.
 characters 1 through 12 correspond to ra, 13 through 24 to dec.
 Care is taken that hours are between 0 and 24, minutes and seconds between
 0 and 60. I.e. ra=0 60 00.0 can not occur.
 Further, if minutes or seconds are less than 10, an extra 0 is added, i.e.
 9 minutes is written as 09 minutes.
 Finally, if hours or degrees are less than 10, there is no extra space, i.e.
 1 hours comes out as 'ra=1 00 00.0', not 'ra= 1 00 00.0' and -1 degree comes
 out as 'dec=-1 00 00.0', not 'dec=- 1 00 00.0'.

 Input:
   a:     right ascension in radians
   d:     declination in radians

 Output:
   radec: resulting output string
\endtt}
\par}
\module{randset}%
\noindent Set random number generator seed.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/noise.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} random-variables, noise
\par{\tenpoint
{\eightpoint\begintt
        subroutine RandSet(seed)

        implicit none
        integer seed

  This sets the seed of the random number generator. Future sequences
  of random numbers will be generated from this seed.

  Input:
    seed       Some "random" integer value, which is the seed to be
               used.
\endtt}
\par}
\module{rangle}%
\noindent Convert degrees value (in radians) into a formatted string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/angles.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} utility
\par{\tenpoint
{\eightpoint\begintt
      character*(*) function rangle(theta)

      implicit none
      double precision theta

  Converts an angle expressed in radians into a string.

  Inputs:
    theta    Angle in radians.

  Output:
    rangle   Angle formated into a string with format:
               [+/-]DD:MM:SS.SS
\endtt}
\par}
\module{rdhda}%
\noindent Read a string-valued header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine rdhda(tno,keyword,value,default)
        integer tno
        character keyword*(*)
        character value*(*),default*(*)

  Read a string valued header variable.

  Input:
    tno         The file handle of the data set.
    keyword     The name of the header variable.
    default     The default value to return, if the header variable
                is not found.
  Output:
    value       The value of the header variable. This will be the default
                value, if the variable is missing from the header.      
\endtt}
\par}
\module{rdhdc}%
\noindent Read a complex-valued header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine rdhdc(tno,keyword,value,default)
        integer tno
        character keyword*(*)
        complex value,default

  Read a complex valued header variable.

  Input:
    tno         The file handle of the data set.
    keyword     The name of the header variable.
    default     The default value to return, if the header variable
                is not found.
  Output:
    value       The value of the header variable. This will be the default
                value, if the variable is missing from the header.      
\endtt}
\par}
\module{rdhdd}%
\noindent Read a double precision-valued header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine rdhdd(tno,keyword,value,default)
        integer tno
        character keyword*(*)
        double precision value,default

  Read a double precision valued header variable.

  Input:
    tno         The file handle of the data set.
    keyword     The name of the header variable.
    default     The default value to return, if the header variable
                is not found.
  Output:
    value       The value of the header variable. This will be the default
                value, if the variable is missing from the header.      
\endtt}
\par}
\module{rdhdi}%
\noindent Read an integer-valued header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine rdhdi(tno,keyword,value,default)
        integer tno
        character keyword*(*)
        integer value,default

  Read an integer valued header variable.

  Input:
    tno         The file handle of the data set.
    keyword     The name of the header variable.
    default     The default value to return, if the header variable
                is not found.
  Output:
    value       The value of the header variable. This will be the default
                value, if the variable is missing from the header.      
\endtt}
\par}
\module{rdhdia}%
\noindent Read an integer array header variable
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        subroutine rdhdia( tno, itemname, length, value )

        integer tno, length
        character*(*) itemname
        integer value(*)

   rdhdia reads a header variable of unknown type

   inputs:
       tno               -- handle of data set
       itemname          -- name of the item to read
       length            -- number of items

   outputs:
       value             -- value of the item
\endtt}
\par}
\module{rdhdr}%
\noindent Read a real-valued header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine rdhdr(tno,keyword,value,default)
        integer tno
        character keyword*(*)
        real value,default

  Read a real valued header variable.

  Input:
    tno         The file handle of the data set.
    keyword     The name of the header variable.
    default     The default value to return, if the header variable
                is not found.
  Output:
    value       The value of the header variable. This will be the default
                value, if the variable is missing from the header.      
\endtt}
\par}
\module{readbrk}%
\noindent Read breakpoint data
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsetio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE readbrk(file)

        CHARACTER*(*) file

       ReadBkr reads the breakpoint data of a calibration set

   Inputs:
       file -- name of the calibration set
\endtt}
\par}
\module{readset}%
\noindent Read in data from a calibration set
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsetio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE readset( file )

        CHARACTER file*(*)

   Input:
       file --     the name of the cal.dataset to be opened

   The 'file' is assumed to be a calibration dataset, and is read
   in memory. It reads the gain correllations data and associated
   source names
   It is verbose in the sense that is outputs the names of the 
   sources read.
   In version 6.1 and later calibrator fluxes are baseline based and
   stored in a item 'cdata'. This may be a temporary fix to a more
   fundamental problem.
       
\endtt}
\par}
\module{remext}%
\noindent Remove the extension part of a filename
\newline \ 
\newline \abox{File:} \$MIR/src/subs/fullname.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} files
\par{\tenpoint
{\eightpoint\begintt
      subroutine remext ( filename )
      character*(*)  filename

 This takes the filename and strips all characters after the last '.'. If no
 '.' occurs, the input remains unchanged.

  Input/Output:
    filename:    name of a file
\endtt}
\par}
\module{rfac}%
\noindent Calculate n factorial.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/hann.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} factorial, utilities
\par{\tenpoint
{\eightpoint\begintt
      subroutine rfact (n, nfac)

      implicit none
      integer n
      real nfac

  Find n!  use real numbers so can have reasonable sized arguments.

  Input:
    n      i     Number to find the factorial of
  Output:
    nfac   r     Result
\endtt}
\par}
\module{rpolyzr}%
\noindent Roots of a real polynomial.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/poly.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} polynomials
\par{\tenpoint
{\eightpoint\begintt
      subroutine rpolyzr(a,nn,roots,ifail)

      implicit none
      integer nn,ifail
      complex roots(nn)
      real a(0:nn)

  This procedure attempts to solve a real polynomial equation in degree nn
  using the technique suggested by Grant and Hitchins (1971) to limiting
  machine precision. On entry, the coefficients of the polynomial are
  held in the array a(0:nn), with a(0) holding the coefficient of the
  highest power. On normal entry, the parameter ifail has value zero,
  and will remain zero on successful exit, with the calculated estimates
  of the roots held in roots(1:nn), in approximately decreasing order
  of magnitude. The parameter "tol" givers the precision of the floating
  binary arithmetic used, normally 2**(-t), where "t" is the number
  of bits in the mantissa.

  Abnormal exits will be indicated by ifail having a value 1 or 2. The
  former implieds that either a(0) = 0 or nn < 1. For ifail=2, a
  possible saddle point has been detected. The degree of the reduced poly
  is stored in nn and its coefficients are held in a(0:nn), the roots
  obtained thus far are held in roots(nn+1) onwards. An immediate
  re-entry is possible with ind unchanged and with a new starting
  point for the search held in roots(1).

  The algorithm has been copies from:
    Grant J.A., Hitchins G.D., (1973 or 1974) "Two algorithms for the
    solution of polynomial equations to limiting machine precision"
    The Computer Journal, vol 18, n3, pp 258-264

  Apart from cosmetic changes, it is an FORTRAN equivalent of the
  ALGOL program they present.

  Input/Output:
    nn         The degree of the poly. 
    a          The poly coefficients.  Destroyed by the algorithm.
    ifail      Should be zero on normal entry and exit, but see above.

  Output:
    roots      The roots of the polynomial.
\endtt}
\par}
\module{rtfmt}%
\noindent Construct a format during run time
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      character*(*)  function rtfmt ( string, vals, nvals )
      character*(*)  string
      integer        vals ( * )
      integer        nvals

 Rtfmt takes as input a format string. It replaces characters between < and >
 with a number, which is given by the array vals. The first occurence of <...>
 corresponds to vals(1), etc. This allows to make up the format in a write 
 statement during runtime, thereby making it possible to print only as many
 characters as needed and avoiding unused empty spaces.
 To get a '<' character in the output format string, stutter it, i.e. use '<<'.

 Example 1:
 write(*,rtfmt( '''Date is:'',i<>,''-'',i<>,''-'',i<>', rtf, 3 )) date
 where date is a 3-element array. The 3-element array rtf contains the number
 of digits of each of the three elements (see function nfig for how to obtain
 these numbers). If rtf has e.g. the values 1, 1 and 4, the format string that
 is produced will be: '''Date is:'',i1,''-'',i1,''-'',i4'. The output on the
 terminal will look something like: '1-1-1900' or '1-10-90' or '12-12-1991',
 i.e. there are never any obsolete spaces.

 Example 2:
 if(    abs ( x-int(x) ) .lt. 1.e-10   ) ndec(2) = 0
 if(    abs ( x-int(x) ) .ge. 1.e-10   ) ndec(2) = 2
 ndec(1) = nfigi( int(x) ) + 3
 write( *, rtfmt( '''x='',f<>.<>', ndec, 2 ) ) x
 Now the f-format with which a variable is written depends on the value of the
 variable, so that the output will be 'x=1.02' or 'x=1' or 'x=100' or 'x=1000',
 i.e. no distracting spaces come out.

 Example 3:
 nspac = 60 - len1(message)
 write(*, rtfmt( 'a, <nspac>x, ''>'',$', nspac,1 ) ) message(:len1(message))
 This puts out a message on the screen, with the prompt character > always in
 column 60, no matter how long the string 'message' was.

 Input:
   string:     A format.
   vals:       Values to replace characters between < and > with
   nvals:      Number of values
\endtt}
\par}
\module{rtoa}%
\noindent Convert a real value into a string.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      character*(*) function rtoa(value, form, nsf)

      implicit none
      real value
      integer form, nsf

  Format a real value into a string using pgplot's pgnumb.

  Inputs:
    value         The value (must be real).
    form          How the number is formatted:
                    form = 0 - uses either decimal or
                               exponential notation
                    form = 1 - uses decimal notation
                    form = 2 - uses exponential notation
    nsf           Number of significant figures for output
                    (best range is between 1 and 6)
\endtt}
\par}
\module{s2code}%
\noindent Convert integer slot code to 4 character slot code
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Keywords:} calibration, slotcode
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        CHARACTER*4 FUNCTION s2code (s)

        INTEGER     s

   Converts an integer slot to 4 character slot code
   Note that the code will be in UPPER CASE.
   For additional comments see code2s.

   Input:
       s      -- integer (1..20)
   Output:
       s2code   -- 4 character code ($,$$,W$$$)
                   Legal values for $, $$, and $$$ are:
                   $ ..... A, P
                   $$ .... U, L
                   $$$ ... 1, 2, 3, 4, 5, 6, 7, 8
\endtt}
\par}
\module{scalunit}%
\noindent Set calibration unit conversion mode
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Keywords:} calibration
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        INTEGER FUNCTION scalunit(unit)

        CHARACTER unit*(*)

   Convert a unit string into an integer scaling mode 

   It is case insensitive, in fact it converts the input
   'unit' character string to lower case.

       unit        scalmode
       ----        --------
       k           0
       k/jy        1
       k/mjy       2
       k/kjy       3
       jy/k       -1
       mjy/k      -2
       kjy/k      -3
\endtt}
\par}
\module{scanchar}%
\noindent Scan a string for a character.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        subroutine scanchar(string,k1,k2,c)

        implicit none
        character string*(*),c*1
        integer k1,k2

  This scans forward through a string, until it finds a character "c".

  Input:
    string     The string containing the characters.
  Input/Output:
    k1,k2      These delimit the characters in the string that are
               to be processed. On output, k1 is incremented to point
               to the character that was being scanned for.
\endtt}
\par}
\module{scrclose}%
\noindent Close and delete a scratch file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/scrio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} scratch-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine scrclose(tno)
        integer tno

  This closes and deletes a scratch file. The scratch file cannot be
  accessed again, after it is closed.
  Input:
    tno         The handle of the scratch file.                         
\endtt}
\par}
\module{scropen}%
\noindent Open a scratch file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/scrio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} scratch-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine scropen(tno)
        integer tno

  This opens a scratch file, and readies it for use.
  Output:
    tno         The handle of the scratch file.                         
\endtt}
\par}
\module{scrread}%
\noindent Read real data from a scratch file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/scrio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} scratch-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine scrread(tno,buf,offset,length)
        integer tno,offset,length
        real buf(length)

  This reads real data from the scratch file.
  Input:
    tno         The handle of the scratch file.
    offset      The offset (measured in reals) into the scratch file
                to read. The first real has offset 0.
    length      The number of reals to read.
  Output:
    buf         The returned data.                                      
\endtt}
\par}
\module{scrwrite}%
\noindent Write real data to the scratch file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/scrio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} scratch-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine scrwrite(tno,buf,offset,length)
        integer tno,offset,length
        real buf(length)

  This writes real data to the scratch file.
  Input:
    tno         The handle of the scratch file.
    offset      The offset (measured in reals) into the scratch file
                to write. The first real has offset 0.
    length      The number of reals to write.
    buf         The data to write.                                      
\endtt}
\par}
\module{selapply}%
\noindent Call the appropraite uv routine to set the uv selection.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/select.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} uv-selection, uv-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine SelApply(tno,sels,select)

        implicit none
        integer tno
        real sels(*)
        logical select

  This calls the uvselect routine, to indicate what data is to be
  selected, etc.

  Inputs:
    tno        The handle of the uv data file.
    sels       The intermediate form of the selection.
    select     If true, the data is selected, otherwise the data is
               discarded.
\endtt}
\par}
\module{selinput}%
\noindent Get the users uv selection specification.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/select.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} uv-selection, uv-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine SelInput(key,sels,maxsels)

        implicit none
        character key*(*)
        integer maxsels
        real sels(maxsels)

  This gets the specification of the selected uv data from the key
  routines.

  Inputs:
    key        Keyword to be used with the key routine. Usually this is
               "select".
    maxsels    The size of the "sels" array. 500 elements is
               more than adequate. This would be a complicated selection
               for an array with many antennae.

  Output:
    sels       Intermediate form of the selection.
\endtt}
\par}
\module{selprobe}%
\noindent Check if a particular uv data has been selected.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/select.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} uv-selection, uv-i/o
\par{\tenpoint
{\eightpoint\begintt
        logical function SelProbe(sels,object,value)

        implicit none
        character object*(*)
        real sels(*)
        double precision value

  This routine checks whether particular uv data have been selected by
  the user. It returns .true. if so, or .false. otherwise.

  Inputs:
    sels       The intermidate form of the uv selection, passed back
               by SelInput.
    object     The type of value to check. Possible values are:
                 Object:               Units of Value:
                 'time'                Julian day.
                 'antennae'            Baseline number = 256*ant1 + ant2.
                                       One of ant1 or ant2 can be zero.
                 'uvrange'             Wavelengths.
                 'uvnrange'            Nanoseconds.
                 'visibility'          Visibility number (1 relative).
                 'dra'                 Radians.
                 'ddec'                Radians.
                 'pointing'            Arcseconds.
                 'amplitude'           Same as correlation data.
                 'window'              Window Number.
                 'on'                  On switch
                 'polarization'        Polarization type.
               Note that this does not support all objects to uvselect.
               The name must be given in full (no abbreviations and case
               is significant).
    value      The value to check whether it has been selected.
  Output:
    SelProbe   This returns the value .true. if the data could possibly be
               selected. It does not guarantee that such data might exist
               in any particular data file. It also has the limitation that
               information is not present to convert "uvrange" and "uvnrange"
               calls into each other. These should be treated with caution.
\endtt}
\par}
\module{setsflag}%
\noindent Set flags along time axis according to selected sources
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Keywords:} calibration, multi-source
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE setsflag (n, src)

        INTEGER    n
        CHARACTER  src(*)*(*)

  According to an array of names of sources selected, the 'Sflags'
  array in the common block /CALDATA/ is flagged true or false if
  that point is to be selected for fitting.
  Since the 'Sname' array of sources are upper case, the input array
  'src' is converted to upper case on output.

  Input:
       n    -- number of sources, if 0, all are selected
       src  -- array of sources
  Output:
       src  -- array of sources, but now converted to upper case
\endtt}
\par}
\module{sfetra}%
\noindent Transformation between equatorial and other coordinate systems
\newline \ 
\newline \abox{File:} \$MIR/src/subs/sfetra.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} coordinates
\par{\tenpoint
{\eightpoint\begintt
      subroutine sfetra( slon, slat, inv, sys )
      subroutine dsfetra( dlon, dlat, inv, sys )

      real                 slon, slat
      double precision     dlon, dlat
      logical              inv
      integer              sys

 Trigonometric coordinate transform by matrix multiplication. Defines
 transformation from equatorial to galactic, ecliptic or supergalactic
 coordinates.
 Sfetra takes a real variable as in/output, for dsfetra coordinates
 must be in double precision.

 Input/Output:
   slon/dlon:   longitude (in radians)
   slat/dlat:   latitude  (in radians)

 Input:
   inv:         direction of transformation
                .false. from equatorial to other systems
                .true.  from other systems to equatorial
   sys:         in-/output system
                1: galactic coordinates
                2: ecliptic coordinates
                3: supergalactic coordinates
\endtt}
\par}
\module{shadowed}%
\newline \abox{File:} \$MIR/src/subs/shadowed.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} uv-data
\par{\tenpoint
{\eightpoint\begintt
      integer function shadowed( tno, ants, overlap )
      integer          tno
      double precision ants
      real             overlap

 Shadowed returns a value indicating which of the two input antennas
 was shadowed. If the returned value is 0 there was no shadowing.
 The result is valid for the last record read with uvread.
 The two antennas to check are coded in the variable ants in the
 usual manner. I.e. ant1=ants/256 and ant2=ants-256*ant1, i.e. ants=
 ant1*256.+ant2. One can use the variable preamble(4) returned by
 uvread as input.
 The antenna positions and pointings are read from the visibility
 file to which the handle 'tno' corresponds.
 Data is considered shadowed when the projected baseline is less than
 the value given by the variable overlap (in units of meters).
 If the value of overlap equals 0, shadowed returns with the value 0.

 Inputs:
   tno         The handle of the uv data file
   ants        A code giving the antennas to check on shadowing.
               the code is the same as the one in the preamble(4)
               variable returned by uvread.
   overlap     Projected baseline below which data is considered
               shadowed.
\endtt}
\par}
\module{solve}%
\noindent Solve a matrix
\newline \ 
\newline \abox{File:} \$MIR/src/subs/polyfit.for
\newline \abox{Keywords:} least squares fit, calibration
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE solve( nlsq )

        INTEGER nlsq

  Inputs:
       nlsq -- order of final least squares fit
\endtt}
\par}
\module{sortidxa}%
\noindent Index sort of a an array of character values
\newline \ 
\newline \abox{File:} \$MIR/src/subs/sortidx.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} sorting, indexing
\par{\tenpoint
{\eightpoint\begintt
      subroutine sortidxa (n, x ,idx)

      integer n, idx(n)
      character*(*) x(n)

       -- see documentation on sortidxd
\endtt}
\par}
\module{sortidxd}%
\noindent Index sort of a an array of double precision values
\newline \ 
\newline \abox{File:} \$MIR/src/subs/sortidx.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} sorting, indexing
\par{\tenpoint
{\eightpoint\begintt
      subroutine sortidxd (n, x ,idx)

      integer n, idx(n)
      double precision x(n)

  sortidxX:  (shell) sort of an array into a integer index-array
               See also e.g. K&R pp108
       Various versions exist:
           sortidxa    index sorting of character array
           sortidxi    index sorting of integer array
           sortidxr    index sorting of real array
           sortidxd    index sorting of double precision array

       input:  x[]   array of values
               n     number of elements in x to sort

       output: idx[] 'pointer' array, such that x[idx[i-1]]<x[idx[i]] for
                     i=2..n
\endtt}
\par}
\module{sortidxi}%
\noindent Index sort of a an array of integer values
\newline \ 
\newline \abox{File:} \$MIR/src/subs/sortidx.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} sorting, indexing
\par{\tenpoint
{\eightpoint\begintt
      subroutine sortidxi (n, x ,idx)

      integer n, idx(n)
      integer x(n)

       -- see documentation on sortidxd
\endtt}
\par}
\module{sortidxr}%
\noindent Index sort of a an array of real values
\newline \ 
\newline \abox{File:} \$MIR/src/subs/sortidx.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} sorting, indexing
\par{\tenpoint
{\eightpoint\begintt
      subroutine sortidxr (n, x ,idx)

      integer n, idx(n)
      real x(n)

       -- see documentation on sortidxd
\endtt}
\par}
\module{spanchar}%
\noindent Skip over a particular character.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        subroutine spanchar(string,k1,k2,c)

        implicit none
        character string*(*),c*1
        integer k1,k2

  Skip over any occurrences of the character "c" in the string.

  Input:
    string     The string containing the characters.
  Input/Output:
    k1,k2      These delimit the characters in the string that are
               to be processed. On output, k1 is incremented to point
               beyond the character that was being skipped.
\endtt}
\par}
\module{squares}%
\noindent Compute sums-of-squares
\newline \ 
\newline \abox{File:} \$MIR/src/subs/polyfit.for
\newline \abox{Keywords:} polynomials, calibration
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE squares( count, X, Y, pmax )

        INTEGER count, pmax
        REAL    x(*), y(*)

  Inputs:
       count -- the number of data points
       X     -- independent variable
       Y     -- dependent variable
       pmax  -- polynomial order of fit
\endtt}
\par}
\module{substr}%
\noindent Returns the n-th substring from the input string
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
      character*(*) function substr ( string, n )
      character*(*) string
      integer       n

 This takes as input a string which consists of a comma-separated list of
 substrings and an integer. It returns with the substring corresponding to
 the n-th position. E.g. substring('a,b,c,d,e',3) equals 'c'.

 If n is an illegal number, i.e. 0 or larger than the number of substrings
 in string, an empty string is returned.

 Input:
   string:     comma-separated list of substrings
   n:          position of requested substring in the list
\endtt}
\par}
\module{tabflux}%
\noindent Return the flux of a calibrator source at an input freq.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tabflux.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} calibration, flux, frequency
\par{\tenpoint
{\eightpoint\begintt
      subroutine tabflux(FileName, source, freq, delfreq, day, delday,
     *  flux, rms, Line, iostat)

      implicit none
      character FileName*(*), source*(*)
      real freq, delfreq, delday, flux, rms
      double precision day
      integer Line, iostat

 Input:
   FileName The name of the flux calibrator file.  This defaults to
            MIRCAT/cals.fluxes.
   delfreq  The frequency width (real: GHz) around the parameter
            ``freq'' in which to include a frequency match.
   delday   The date width (real: Julian days) around the parameter
            ``day'' in which to include a date match.

 Input/Output:
   source   The calibrator source name ('*' means all sources;
            minimum match of name is in effect).
            Output is the full name of the source that matches.
   freq     The frequency (GHz) of the calibrator data desired (input
            value of 0.0 defaults match to all frequencies).  Output
            is the freq (GHz) of the match.
   day      The day flag for the routine 'tabfind.' Day = 0 means the
            most recent match; day means first match since day; and -day
            means first match less than abs(day).  The internal format
            for day (when day != 0) is the same as for DATE entries in
            the flux calibration file (Julian Day).  On Output, day
            is the Julian Day of the match(s).
   flux     On Input, flux is the lower limit flux (Jy) of the calibrator
            in which to consider a match and defaults to all matching
            fluxes if set to 0.0.  On Output, flux (Jy) is the matching
            source(s) flux value at freq GHz.
   Line     On Input, this integer represents the next entry in the
            sorted flux table (not the file) to consider for a match.
            Line = 1 is the first table entry, so to effectively "rewind"
            the sorted table, reset Line to 1 on each subsequent call.
            On output, Line is next item to consider as a possible match.

 Output:
   rms      The rms (Jy) of the calibrator (set to 0 if not listed).
   iostat   The returned error code.  0 means no error; -1 means no
            data read; -2, EOF.  Other errors from routine TABFIND.
\endtt}
\par}
\module{taver}%
\noindent Scalar averaging an array
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsubs.for
\newline \abox{Keywords:} calibration, scalar-average
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE taver (n, x, y, dx)

        INTEGER n
        REAL    x(*), y(*), dx

   Scalar average of an array - the X array is assumed to be
       sorted already - using a cluster algorithm

  Inputs:
       n    -- number of elements in x and y arrays
       x    -- array of input ordinates
       y    -- array of input values
       dx   -- max step in x to group values
  Output:
       n    -- number of elements in x and y
       x    -- array of output ordinates
       y    -- array of output values
\endtt}
\par}
\module{teken}%
\noindent Returns the sign of a real value
\newline \ 
\newline \abox{File:} \$MIR/src/subs/utilities.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} utilities
\par{\tenpoint
{\eightpoint\begintt
     integer          function tekeni ( i )
     real             function tekenr ( r )
     double precision function tekend ( d )
     integer          i
     real             r
     double precision d

 tekenr returns +1.   or -1.   depending on the sign of the real x.
 tekeni returns +1    or -1    depending on the sign of the integer i
 tekend returns +1.d0 or -1.d0 depending on the sign of the double precision d
\endtt}
\par}
\module{title}%
\noindent Write title in standard format into LogFile.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/title.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} image analysis, log-file
\par{\tenpoint
{\eightpoint\begintt
        Subroutine Title(lIn,naxis,blc,trc,cbof)

        implicit none
        integer lIn,naxis,blc(naxis),trc(naxis)

   Write title in standard format into LogFile.

  Inputs:
    lIn        The handle of the Image.
    naxis      Number of axes of the Image.
    blc,trc    Corners of region of interest.
  Output:
    cbof       Beam oversampling factor.
\endtt}
\par}
\module{todayjul}%
\noindent Format the current day into a Julian day.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/julday.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} julian-day, date, utilities
\par{\tenpoint
{\eightpoint\begintt
      subroutine todayjul(julian)

      implicit none
      double precision julian

  Convert the current date to Julian date.  This is not to high
  accuracy, but it achieves the accuracy required. See "Astronomical
  Formulae for Calculators", Jean Meeus (Wiillmann-Bell Inc).
  The day is assumed to begin at 0 hours UT.

  Input:
    none

  Output:
    julian      Julian date.
\endtt}
\par}
\module{token}%
\noindent Obtain token delimited by \_ ()[]
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvsubs.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} i/o, user-interaction.
\par{\tenpoint
{\eightpoint\begintt
        character*(*) function token(in,inext,iend,leng)

        implicit none
        character*(*) in
        integer inext,iend,leng

  Obtain the next token from a string variable where the delimiters
       are _ ()[].

  Input:
    in         string being decoded
    inext      pointer into string in
    iend       length of in.
  Output:
    leng       length of token
\endtt}
\par}
\module{trnfin}%
\noindent Close up the transpose routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/trnio.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} transpose, reorder
\par{\tenpoint
{\eightpoint\begintt
        subroutine trnFin

        implicit none

  TrnFin releases any resources allocated by the transpose routines.
\endtt}
\par}
\module{trnini}%
\noindent Initialise the transpose routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/trnio.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} transpose, reorder
\par{\tenpoint
{\eightpoint\begintt
        subroutine trnIni(nd1,nd2,nd3)

        implicit none
        integer nd1,nd2,nd3

  The transpose routines perform a reordering on the axes of a 3D cube.
  In particular the reordering is such that axes 1,2,3 on input, become
   axes 2,3,1 on output, respectively.
  Initialise things for the transpose routine.

  Inputs:
    nd1,nd2,nd3        Dimensions of the input image.
\endtt}
\par}
\module{trnread}%
\noindent Read back a plane of the reordered cube.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/trnio.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} transpose, reorder
\par{\tenpoint
{\eightpoint\begintt
        subroutine trnread(p,Data)

        implicit none
        integer p
        real Data(*)

  TrnRead reads back a plane of the reordered cube.

  Input:
    p          Plane number. Plane numbers run from 1 to nd1.
    Data       The pixel data of the plane. This should be a real array
               of size nd2 by nd3.
\endtt}
\par}
\module{trnwrite}%
\noindent Write a plane of the cube in its initial order.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/trnio.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} transpose, reorder
\par{\tenpoint
{\eightpoint\begintt
        subroutine trnwrite(p,Data)

        implicit none
        integer p
        real Data(*)

  The caller passes TrnWrite a plane of the input (initial ordered) cube.
  The caller can then later read back a reordered cube with TrnRead.

  Input:
    p          Plane number. Plane numbers vary from 1 to nd3.
    Data       The pixel data of the plane. This should be a real array
               of size nd1 by nd2.
\endtt}
\par}
\module{tvchan}%
\noindent Display a given image channel.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine TVchan(channel)

        implicit none
        integer channel

  TvChan causes a particular image channel to appear on the display
  screen. Channels are numbers from 1 to NCHAN (where NCHAN is the
  maximum number of channels that the display possesses.

  Input:
    channel    Channel to turn on.
\endtt}
\par}
\module{tvchar}%
\noindent Get characteristics of the display device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine TVchar(xmax,ymax,channels,levels)

        implicit none
        integer xmax,ymax,channels,levels

  This returns characteristics about the device we are using.

  The display device is assumed to be "xmax" by "ymax" pixels by
  "channels" images deep. Channels are number from 1 upwards to "channels".
  The pixel coordinate system has pixel (1,1) in the lower left corner
  of the screen, and pixel (xmax,ymax) in the top right corner.

  Output:
    xmax,ymax  Screen size in pixels.
    channels   Number of image channels.
    levels     Number of grey scale levels.
\endtt}
\par}
\module{tvclose}%
\noindent Close the display device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine tvclose
        implicit none

  TvClose closes up the image display device, flushing any buffers before
  it finishes.
\endtt}
\par}
\module{tvcursor}%
\noindent Read the location of the image display device's cursor.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine TVcursor(x,y,button)

        implicit none
        integer x,y,button

  Read the current cursor/track ball position, and return the number of
  the last button pressed.

  Output:
    x,y        Cursor screen position (not image memory position).
    button     The number of the last button pressed, This varies from
               1 upwards. A value of zero indicates no button has been
               pushed.
\endtt}
\par}
\module{tveras}%
\noindent Erase a channel on the image display device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine tveras(channel)
        implicit none
        integer channel

  TvEras causes a particular image channel to be erased.
  Channels are numbers from 1 to NCHAN (where NCHAN is the
  maximum number of channels that the display possesses.
  NOTE: If a device is unable to erase only one particular
  channel, then it initializes all channels (via TvReset).

  Input:
    channel    Channel number to erase.
\endtt}
\par}
\module{tvflush}%
\noindent Flush data to the display device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine TVflush

        implicit none

  TvFlush causes any data that has been buffered up, to be flushed to the
  display device. TvFlush then waits for completion of the transfer.
\endtt}
\par}
\module{tvline}%
\noindent Write a raster line to the image display device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine tvline(x,y,channel,array,n)

        implicit none
        integer x,y,channel,n,array(n)

  Write a line to the TV screen.

  Integer:
   x,y         Coordinates of start location.
   channel     Channel to load.
   array       Array of pixels.
   n           Number of pixels.
\endtt}
\par}
\module{tvlocal}%
\noindent Put the display device into an interactive loop with the user.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine tvlocal

        implicit none

  Allow the TV to do its own thing. This allows the user to interact
  directly with the TV in some device-dependent fashion.
\endtt}
\par}
\module{tvlut}%
\noindent Load a image display device's lookup table.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine TVLut(table)

        implicit none
        character table*(*)

  This allows the caller to load a particular colour lookup table into
  the image display device.

  Inputs:
    table      The name of the table to load. Valid values are:
                 'B&W'
                 'Colour'
                 'Rainbow'
\endtt}
\par}
\module{tvopen}%
\noindent Open an image display device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine tvopen(device)

        implicit none
        character device*(*)

  Open an image display device. See TvChar for a description of the
  Tv model.

  Input:
    device     Name of device. This is of the form:
                 type@name
               Here "name" is the physical device name, or the
               name of the server (for network display servers). "Type"
               is the device or server type. Legitimate values are:
                 'ivas'        IVAS server (on VMS only)
                 'ultra'       Ultra frame buffer (on UNICOS only).
                 'sss'         Sun screen server.
                 'ivserve'     Ivas server.
                 'raster'      Rastertech device (on FX only).
                 'file'        Dump to a file (UNICOS only).
                 'vfile'       Dump to file - variable size (UNICOS only).
               Examples:
                 ivas@ixa0:    An IVAS with device name IXA0:
                 ivserve@castor  An IVAS server on machine castor.
                 sss@colo      A SSS server on machine colo.
\endtt}
\par}
\module{tvreset}%
\noindent Reset the image display device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine TVreset
        implicit none

  TVReset causes the image display device to be reset. The image memories
  are cleared, the default lookup table loaded, pan and zoom set to
  0, and the device generally put into its default state.
\endtt}
\par}
\module{tvscrl}%
\noindent Scroll a display on a TV device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
       subroutine tvscrl(scrolx, scroly)
       implicit none
       integer scrolx, scroly

  Input:
    scrolx  Amount of X scroll (>0 scroll to the right).
    scroly  Amount of Y scroll (>0 scroll upwards).

  Output:
    None
\endtt}
\par}
\module{tvselpt}%
\noindent Interactive point/range selection on a display device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
      subroutine tvselpt(channel, type, x1, y1, x2, y2)

      implicit none
      integer channel, type, x1, y1, x2, y2

  TVSELPT allows interactive point or range selection on a TV screen.
  If the device is capable of creating different types of selection
  operations, then the input variable ``type'' sets that style.  If
  necessary (see ``type''), four input positions must be given.  The
  first position is registered when the left mouse button is pushed.
  Moving the mouse from that position alters the drawing according
  to ``type''.  When the left button is pushed again, the operation
  ends and returns the first and last mouse positions.  The operation
  is reset if the middle button is pushed before hitting the left
  button a second time or the mouse is moved outside of the window
  selected.  Selecting either the right button or hitting the STOP
  key (L1 on a Sun) aborts the operation.

  Input:
    channel  Tv Channel to act on.
    type     Style of selection operation (if used by the device):
               If ``type'' = 0, then a point and click selects a point.
               If ``type'' = 1, then a line from (x1,y1) to (x2,y2)
                 is drawn.
               If ``type'' = 2, then a box centered on (x1,y1) is
                 drawn.
               If ``type'' = 3, then a box with (x1,y1) at one corner
                 and (x2,y2) at the other corner is drawn.
               If ``type'' = 4, then a "V" is drawn from the start
                 point (x1,y1) to the present cursor position to
                 the end point (x2,y2).
               NOTE:  ``x1, x2, y1, y2'' MUST be input if ``type'' = 4.

  Input/Output:
    x1, y1   Coordinates of start location.
    x2, y2   Coordinates of end location.
\endtt}
\par}
\module{tvtext}%
\noindent Write a character string to the image display device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
      subroutine tvtext(x, y, channel, string, n, color, dir)

      implicit none
      integer x, y, channel, n
      integer color, dir
      character string*(*)

  Write a line of text to the TV screen.

  Integer:
     x, y      Device coordinates of starting location.
     channel   Channel to load text.
     string    Text to write.
     n         Number of characters in ``string''.
     color     Color of text (Either 0 or 1 for graphics plane).
               0 means off; 63 means full on.
     dir       Direction (0: L->R; 1: T->D; 2: R->L; 3: B->T).
\endtt}
\par}
\module{tvtopx}%
\noindent Convert TV device position to image pixels.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
      subroutine tvtopx(xtv, ytv, pixx, pixy)

      implicit none
      integer xtv, ytv
      integer pixx, pixy

  Convert TV device position to image pixels and take into account
  zoom and scroll.  The input is usually the value returned by a
  call to TvCursor and is converted so that the position can be
  compared with the unzoomed, unpanned image.

  Inputs:
    xtv     I     Screen x position before zoom and scroll.
    ytv     I     Screen y position before zoom and scroll.

  Output:
    pixx    I     Pixel x position after zoom and scroll.
    pixy    I     Pixel y position after zoom and scroll.
\endtt}
\par}
\module{tvview}%
\noindent Change the viewing window to a subportion of image memory.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
        subroutine TVview(xmin,ymin,xmax,ymax)

        implicit none
        integer xmin,ymin,xmax,ymax

  View only a subportion of the screen.

  Input:
    xmin,ymin,xmax,ymax Portion of the screen to view.
\endtt}
\par}
\module{tvwind}%
\noindent Set/read current window (viewport) of a display device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
      subroutine tvwind(x1, y1, x2, y2)

      implicit none
      integer x1, y1, x2, y2

  TVWIND allows the current viewport on a TV screen to be set/read.
  If the device is capable of adjusting its viewport and the input
  positions are non-zero, the viewport is set.  In both cases, the
  current viewport is returned.

  Input/Output:
    x1, y1   Coordinates of the lower left corner in TV pixels.
    x2, y2   Coordinates of the top right corner in TV pixels.

  NOTE:  x1, x2, y1, y2 should ALL be set equal to 0 if resizing is NOT
         desired (ie. just do a viewport read).
\endtt}
\par}
\module{tvzoom}%
\noindent Zoom a region of an image on a TV device.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tv.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} tv, display
\par{\tenpoint
{\eightpoint\begintt
       subroutine tvzoom(zoom, xc, yc)
       implicit none
       integer zoom, xc, yc

  Input:
    zoom    Integer zoom value.
    xc      Integer position of the desired X center of expansion.
    yc      Integer position of the desired Y center of expansion.

            ranges for xc and yc are as follows:
              (1 <= xc <= maxtvx) and (1 <= yc <= maxtvy) with
              xc = 1 at the LHS and yc = 1 at the bottom of the TV.

  Output:
    None
\endtt}
\par}
\module{txtclose}%
\noindent Close a text file
\newline \ 
\newline \abox{File:} \$MIR/src/subs/txtio.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} text-files, text-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine txtclose(lu)

        implicit none
        integer lu

  TxtClose closes a text file.

  Input:
    lu         The handle of the text file
\endtt}
\par}
\module{txtopen}%
\noindent Open a text file
\newline \ 
\newline \abox{File:} \$MIR/src/subs/txtio.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} text-files, text-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine txtopen(lu,name,status,iostat)

        implicit none
        integer lu,iostat
        character name*(*),status*(*)

  This opens a text file for either reading or writing.

  Inputs:
    name       Name of the file to be opened.
    status     Either 'old' or 'new'.
  Output:
    lu         A handle used to access the file.
    iostat     Completion code. A zero value indicates success. Other
               values are system dependent.
\endtt}
\par}
\module{txtopena}%
\noindent Open a text file for appendation.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/txtio.for
\newline \abox{Keywords:} text-files, text-i/o
\newline \abox{Responsible:} Neil Killeen
\par{\tenpoint
{\eightpoint\begintt
        subroutine txtopena(lu,name,iostat)

        implicit none
        integer lu,iostat
        character name*(*)

  This opens an old text file for either reading or writing in append
  mode.

  Inputs:
    name       Name of the file to be opened.
  Output:
    lu         A handle used to access the file.
    iostat     Completion code. A zero value indicates success. Other
               values are system dependent.  
\endtt}
\par}
\module{txtread}%
\noindent Read a line from a text file
\newline \ 
\newline \abox{File:} \$MIR/src/subs/txtio.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} text-files, text-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine txtread(lu,string,length,iostat)

        implicit none
        integer lu,length,iostat
        character string*(*)

  TxtRead reads a line from a text file.

  Input:
    lu         The handle of the text file.
  Output:
    string     The string read.
    length     The number of characters read.
    iostat     I/O completion code. Zero indicates success, -1 indicates
               end-of-file, other values indicate an error.
\endtt}
\par}
\module{txtwrite}%
\noindent Write a line to a text file
\newline \ 
\newline \abox{File:} \$MIR/src/subs/txtio.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} text-files, text-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine txtwrite(lu,string,length,iostat)

        implicit none
        integer lu,iostat,length
        character string*(*)

  TxtWrite writes a line to a text file. Any trailing spaces in input
  string are not written.

  Input:
    lu         The handle of the text file.
    string     The string to be written.
    length     The number of characters to be written.
  Output:
    iostat     I/O completion code. Zero indicates success.
\endtt}
\par}
\module{ucase}%
\noindent Convert string to upper case.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/string.for
\newline \abox{Responsible:} Bart Wakker
\newline \abox{Keywords:} strings
\par{\tenpoint
{\eightpoint\begintt
        subroutine ucase(string)

        implicit none
        character string*(*)

  Convert a string to upper case.

  Input/Output:
    string     The string to be converted to upper case.
\endtt}
\par}
\module{ucursor}%
\noindent Check Ultra cursor pos and 'exit' button state.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ultra2.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} terminal-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine UCursor(x,y,button)

        implicit none
        integer x,y,button

  Check the cursor position and the state of the 'exit' button for the
  ultra frame buffer.

  Outputs:
    x,y        Coordinates of the cursor. These are rescaled to the
               range 0 to 2047 in x, and 0 to 1023 in y.
    button     This is set to 1 if the Exit button has been pressed.
\endtt}
\par}
\module{udef}%
\noindent Set up and display Ultra control panel.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ultra2.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} terminal-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine UDef

        implicit none

  Set up and disp the ctrl panel for ultra frame buffer.
\endtt}
\par}
\module{ufin}%
\noindent Finish Ultra frame buffer and control panel.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ultra2.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} terminal-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine ufin

        implicit none

  Finish up with the control panel and the ultra frame buffer.
\endtt}
\par}
\module{uinit}%
\noindent Indicate to ultra where control panel host is.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ultra2.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} terminal-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine uinit(host)

        implicit none
        character host*(*)

  This indicates to the Ultra software where the host for the control
  panel is.

  Input:
    host       Host running the control panel software. If this is -, then
               there is not control panel host.
\endtt}
\par}
\module{ulocal}%
\noindent Allow user to fiddle the ultra frame buffer.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/ultra2.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} terminal-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine ulocal()

        implicit none

  Allow the user to fiddle the ultra frame buffer.
\endtt}
\par}
\module{uniform}%
\noindent Return uniformly distributed random variables.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/noise.for
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} random-variables, noise
\par{\tenpoint
{\eightpoint\begintt
        subroutine uniform(data,n)

        implicit none
        integer n
        real data(n)

  Generate uniformly distributed noise, in the range [0,1]. This works
  on any machine.

  Inputs:
    n          Number of random numbers to produce.

  Output:
    data       An array of uniformly distributed random numbers.
\endtt}
\par}
\module{unpacki2}%
\noindent Unpack 16 bit integers into normal integers
\newline \ 
\newline \abox{File:} \$MIR/src/subs/packi2.for
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} low-level-i/o
\par{\tenpoint
{\eightpoint\begintt
        subroutine unpacki2(in,out,n)

        implicit none
        integer n
        integer*2 in(n)
        integer out(n)

  Unpack 16 bit integers, with the bytes in "network" order, into normal
  integers.

  Input:
    n          Number of integers to pack.
    in         Input integer*2 to unpack.
  Output:
    out        Output integers.
\endtt}
\par}
\module{uvclose}%
\noindent Close a uv file
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvclose(tno)
        integer tno

  This close a uv data file.
  Input:
    tno         Handle of the uv data set.                              
\endtt}
\par}
\module{uvcopyvr}%
\noindent Copy variables from one uv file to another.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvcopyvr(tin,tout)
        integer tin,tout

  This copies those variables, in the input uv data set, which have
  changed and which are marked as "copy" ('u' flag of a call to uvtrack).

  Inputs:
    tin         File handle of the input uv data set.
    tout        File handle of the output uv data set.                  
\endtt}
\par}
\module{uvdatget}%
\noindent Get information about the UVDat routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvdat.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} uv-i/o, uv-data, uv-selection
\par{\tenpoint
{\eightpoint\begintt
        subroutine UVDatGet(object,aval,ival,rval)

        implicit none
        character object*(*),aval*(*)
        integer ival
        real rval

  This returns miscellaneous information about what is going on inside
  the UVDAT routines.

  Input:
    object     This is a string describing the information to return.
               Possible values are:
                'namexxx' (where xxx is a number) - Returns the name of
                          the nth input file, in "aval".
                'number'  The file number currently being processed.
                'ltype'   Returns linetype in "aval".
                'lstart'  Returns the linetype start value, in "rval".
                'lwidth'  Returns the linetype width value, in "rval".
                'lstep'   Returns the linetype step  value, in "rval".
  Output:
    aval       Character string output.
    ival       Integer valued output.
    rval       Real valued output.
\endtt}
\par}
\module{uvdatinp}%
\noindent Get command line uv data parameters.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvdat.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} uv-i/o, uv-data, uv-selection
\par{\tenpoint
{\eightpoint\begintt
        subroutine UVDatInp(key,flags)

        implicit none
        character key*(*),flags*(*)

  This gets command line inputs and store them away in common. It remembers
  which uvset calls we need to make. In particular, it gets the following
  keywords:
    'vis'      Input visibility files (actually the keyword is the "key"
               argument).
    'select'   UV selection specification.
    'line'     Data linetype specification (optional).
    'ref'      Reference linetype specification (optional).

  Input:
    key        The keyword associated with the input visibility file.
               Generally this will be 'vis'.
    flags      This is a character string determining the processing steps
               that need to be performed. It consists of:
                'r'    Get reference linetype specification (keyword 'ref').
                'l'    Get data linetype specification.
                'p'    Apply planet rotation and scaling.
                'w'    Return u and v in wavelengths.
                '1'    Default number of channels is 1.
                'c'    Apply selfcal gain solutions.
                'x'    Data must be cross-correlation data.
                'a'    Data must be auto-correlation data.
\endtt}
\par}
\module{uvdatprb}%
\noindent Determine what data have been selected in the uvdat routines.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvdat.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} uv-i/o, uv-data, uv-selection
\par{\tenpoint
{\eightpoint\begintt
        logical function uvDatPrb(object,value)

        implicit none
        character object*(*)
        double precision value

  This probes the data selection criteria. It simply calls the appropriate
  "Select" routine which does this.

  Input:
    object     The name of the object to check. It is the corresponding
               item to the SelProbe routine's "object" arguement.
               routine.
    value      The value to check whether it has been selected.
  Output:
    uvDatPrb   This returns the value .true. if the data could possibly be
               selected. It does not guarantee that such data might exist
               in any particular data file. It also has the limitation that
               information is not present to convert "uvrange" and "uvnrange"
               calls into each other. These should be treated with caution.
\endtt}
\par}
\module{uvdatrd}%
\noindent Read uv data from a multi-file set.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvdat.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} uv-i/o, uv-data, uv-selection
\par{\tenpoint
{\eightpoint\begintt
        subroutine UVDatRd(tIn,preamble,data,flags,n,nread)

        implicit none
        integer tIn,n,nread
        double precision preamble(4)
        complex data(n)
        logical flags(n)

  This opens the uv data files, performs the various uvset and uvselect
  calls, and the uvclose calls, as well (of course) as the uvread call.

  Input:
    n          The size of the data and flags arrays.
  Outputs:
    tIn        The handle of the uv data set.
    preamble   The uvread preamble.
    data       The uvread correlation data.
    flags      The uvread flags data.
    data       The correlation data.
    nread      The number of channels read.
\endtt}
\par}
\module{uvfit1}%
\noindent Fit a constant to an "object" returned by uvinfo.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvfit.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} uv-data
\par{\tenpoint
{\eightpoint\begintt
        subroutine uvfit1(tno,object,n,a,epsi)

        implicit none
        integer tno,n
        character object*(*)
        double precision a,epsi

  UvFit1 fits a constant to an "object" return by uvinfo. It
  returns the estimate of the constant and the rms error of the
  fit.

  Input:
    tno        Handle of the uv data file.
    object     Some string, passed down to uvinfo.
    n          The number of channels ("nread" returned by uvread).
  Output:
    a          The estimate of the constant value.
    epsi       Rms error of the estimate.
\endtt}
\par}
\module{uvfit2}%
\noindent Fit a line to an "object" returned by uvinfo.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvfit.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} uv-data
\par{\tenpoint
{\eightpoint\begintt
        subroutine uvfit2(tno,object,n,a,b,epsi)

        implicit none
        integer tno,n
        character object*(*)
        double precision a,b,epsi

  UvFit2 fits a line to an "object" return by uvinfo. It
  returns the estimate of the poarameters of the line, along with
  the rms error of the fit.

  Input:
    tno        Handle of the uv data file.
    object     Some string, passed down to uvinfo.
    n          The number of channels ("nread" returned by uvread).
  Output:
    a,b        The equation of the line is
                a*(i-1) + b
    epsi       Rms error of the estimate.
\endtt}
\par}
\module{uvflgwr}%
\noindent Write uv flags after a read.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvflgwr(tno,flags)
        integer tno
        logical flags(*)

  This causes the flags associated with correlation data to be rewritten.
  It is typically used by a flagging program to overwrite old flagging
  information. It will typically be called soon after uvread (which is
  used to get the old flags, and position the file), thus overwriting
  the old flags.

  Input:
    tno         The handle of the input uv file.
    flags       Logical array of "nread" elements ("nread" as returned
                by the last call to uvread).                            
\endtt}
\par}
\module{uvgetvr}%
\noindent Get the values of a uv variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvgetvra(tno,varname,adata)
        subroutine uvgetvri(tno,varname,idata,n)
        subroutine uvgetvrr(tno,varname,rdata,n)
        subroutine uvgetvrd(tno,varname,ddata,n)
        subroutine uvgetvrc(tno,varname,cdata,n)
        integer tno,n
        character varname*(*)
        character adata*(*)
        integer   idata(n)
        real      rdata(n)
        double precision ddata(n)
        complex cdata(n)

  These routines return the current value of a uv variable. N gives the size
  of elements in the return array. This MUST match with the actual number
  of elements in the variable. An exception is for the character string
  routine, where the size of the "adata" string must be strictly greater
  than (not equal to!) the size of the string.

  Input:
    tno         The handle of the uv data file.
    varname     The name of the variable to return.
    n           The number of elements to return. This must agree with
                the size of the variable!
  Output:
    data        The returned values of the variable.                    
\endtt}
\par}
\module{uvinfo}%
\noindent Get information about the last data read with uvread.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvinfo(tno,object,data)
        integer tno
        character object*(*)
        double precision data(*)

  This returns extra information about the data read in the last call
  to uvread.

  Input:
    tno         The handle of the uv file.
    object      Indicates what information is required. Currently
                this can be
                'velocity' returns "nread" numbers, giving the velocity
                           (km/s) of each channel.
                'restfreq' returns "nread" numbers, giving the rest
                           frequency (GHz) of each channel.
                'bandwidth' returns "nread" numbers, giving the bandwidth
                           (GHz) of each channel.
                'visno'    returns 1 number, which is the number of
                           visibilities read from this file.
                'frequency' returns "nread" numbers, giving the rest-frame
                           frequency (GHz) of each channel.
                'amprange' returns 3 numbers. The first gives the amplitude
                           selection for this record, the next two give
                           the selection range. Possible values of data(1) are
                           -1 : Data outside the range [data(2),data(3)]
                                was rejected.
                            0 : No amplitude selection.
                           +1 : Data inside the range [data(2),data(3)]
                                was rejected.
  Output:
    data        The actual information returned.                        
\endtt}
\par}
\module{uvnext}%
\noindent Skip to the next uv record.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvnext(tno)
        integer tno

  Skip to the next uv data record. On write, this causes an end-of-record
  mark to be written. On read, this causes data to be read up until the
  next end-of-record mark.

  Input:
    tno         The uv data file handle.                                
\endtt}
\par}
\module{uvopen}%
\noindent Open a uv data file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvopen(tno,name,status)
        integer tno
        character name*(*),status*(*)

  Create and/or ready a UV data base to be accessed.

  Input:
    name        Name of the directory tree containg the u-v data.
    status      Either "old" or "new". Old files can be read, new
                files can only be written.
  Output:
    tno         Handle of the uv data set.                              
\endtt}
\par}
\module{uvprobvr}%
\noindent Return information about a variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvprobvr(tno,varname,type,length,update)
        integer tno,length
        character varname*(*),type*1
        logical update

  This checks whether a particular variable exists. If it does, this
  passes back the type and (current) length of the variable, and whether
  it was updated on the last call to uvread or uvscan.

  Input:
    tno         The handle of the input uv data file.
    varname     The name of the variable to check.
  Output:
    type        The type of the variable. If the variable does not
                exist, this is blank. Otherwise it is one of 'a', 'r',
                'i', 'd' or 'c'.
    length      The number of elements in the uv variable. If this is not
                known (which is true if the variable has never been read)
                then this will be zero.
    update      This will be set .true. if this variable was updated
                on the last call to uvread or uvscan.                   
\endtt}
\par}
\module{uvputvr}%
\noindent Write the value of a uv variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvputvra(tno,varname,adata)
        subroutine uvputvri(tno,varname,idata,n)
        subroutine uvputvrr(tno,varname,rdata,n)
        subroutine uvputvrd(tno,varname,ddata,n)
        subroutine uvputvrc(tno,varname,cdata,n)
        integer tno,n
        character varname*(*)
        character adata*(*)
        integer   idata(n)
        real      rdata(n)
        double precision ddata(n)
        complex cdata(n)

  These routines write new values for a uv variable. N gives the number
  of elements to write.

  Input:
    tno         The handle of the uv data file.
    varname     The name of the variable to write.
    n           The number of elements to write.
    data        The values of the variable.                             
\endtt}
\par}
\module{uvrdvr}%
\noindent Return the value of a UV variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvrdvra(tno,varname,adata,adefault)
        subroutine uvrdvri(tno,varname,idata,idefault)
        subroutine uvrdvrr(tno,varname,rdata,rdefault)
        subroutine uvrdvrd(tno,varname,ddata,ddefault)
        subroutine uvrdvrc(tno,varname,cdata,cdefault)
        integer tno
        character varname*(*)
        character adata*(*),adefault*(*)
        integer   idata,    idefault
        real      rdata,    rdefault
        double precision ddata,ddefault
        complex cdata,cdefault

  These routines get the first value of a variable. If the variable is
  missing,the default value is returned.

  Input:
    tno         The handle of the uv data file.
    varname     The name of the variable to return.
    default     The default value.
  Output:
    data        The returned value of the variable.                     
\endtt}
\par}
\module{uvread}%
\noindent Read in some uv correlation data.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvread(tno,preamble,data,flags,n,nread)
        integer tno,n,nread
        double precision preamble(4)
        complex data(n)
        logical flags(n)

  This reads a single visibility from the data file. This starts by scanning
  the uv data stream until a correlation record is found. The correlations
  are then converted to complex numbers if necessary, and returned to the
  caller. Uvread also performs some massaging (see uvset) and selection
  (see uvselect) steps.

  Input:
    tno         Handle of the uv data set.
    n           Max number of channels that can be read.
  Output:
    preamble    A double array of 4 elements giving u,v, time and
                baseline number (in that order).
    data        A real array of at least n complex elements (or 2n real
                elements). This returns the correlation data.
    flags       Logical array of at least n elements. A true value for
                a channel indicates good data.
    nread       Number of correlations returned. On end-of-file, zero
                is returned.                                            
\endtt}
\par}
\module{uvrewind}%
\noindent Reset the uv data file to the start of the file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvrewind(tno)
        integer tno

  Rewind a uv file, readying it to be read from the begining again.

  Input:
    tno         The uv data file handle.                                
\endtt}
\par}
\module{uvscan}%
\noindent Scan a uv file until a variable changes.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        integer function uvscan(tno,varname)
        integer tno
        character varname*(*)

  Scan through a uv file until a particular variable changes. This always
  reads to the end of the record (i.e. until all variables that change
  simultaneously are read) after "varname" was encountered.

  Input:
    tno         The handle of the uv file to be scanned.
    varname     The variable to terminate the search.

  Output:
    uvscan_c    0 on success, -1 on end-of-file. Standard error
                number otherwise.                                       
\endtt}
\par}
\module{uvselect}%
\noindent Select or reject uv data.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvselect(tno,object,p1,p2,flag)
        integer tno
        character object*(*)
        double precision p1,p2
        logical flag

  This specifies the portion of the data to be selected by calls to
  uvread. Normally data that are not selected, are not returned.
  Exceptions are the "window" and "amplitude" objects, which cause the
  corresponding visibilities to be flagged as bad, but returned anyway.

  Input:
    tno         Handle of the uv data file.
    object      This can be one of "time","antennae","visibility",
                "uvrange","pointing","amplitude","window","or","dra",
                "ddec","uvnrange","increment","ra","dec","and".
    p1,p2       Generally this is the range of values to select. For
                "antennae", this is the two antennae pair to select.
                A zero indicates "all antennae".
                For "window", only p1 is used.
    flag        If true, the data is selected. If false, the data is
                discarded.                                              
\endtt}
\par}
\module{uvset}%
\noindent Set up the uv linetype, and other massaging steps.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvset(tno,object,type,n,p1,p2,p3)
        integer tno
        character object*(*),type*(*)
        integer n
        real p1,p2,p3

  Set up the way uvread behaves. This determines whether uvread returns
  correlation channels, wide-band channels or velocity channels. This also
  sets up whether u and v are returned in wavelengths or nanosec, and
  what planet processing is performed.

  Input:
    tno         Handle of the uv data set.
    object      Name of the object that we are setting the type of.
    type        The type of data that the user wants returned.
    n           Some integer parameter.
    p1,p2,p3    Some real parameters.                                   
\endtt}
\par}
\module{uvtrack}%
\noindent Set flags and switches associated with a uv variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvtrack(tno,varname,switches)
        integer tno
        character varname*(*),switches*(*)

  UVTRACK allows the programmer to set switches and flags associated with
  a particular uv variable, to allow extra processing steps of that
  variable.

  Input:
    tno         The handle of the input uv file.
    varname     The name of the variable of interest.
    switches    This is a character string, each character of which
                causes a particular flag or switch to be turned on for
                this particular variable. Valid values are:
                 'u'  Remember if this variable gets updated, and  when
                      it gets updated, uvupdate returns .true. the next
                      time it is called.
                 'c'  Remember if this variable gets updated, and when 
                      it gets updated, cause it to be copied during the
                      next call to uvcopyvr.                            
\endtt}
\par}
\module{uvupdate}%
\noindent Check whether any "important" variables have changed.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        logical function uvupdate(tno)
        integer tno

  This checks whether any ``important variables'' has been updated in the
  last call to uvread or uvscan. Important variables are those flagged
  with the 'u' flag in a call to uvtrack.

  Input:
    tno         File handle of the uv file to check.                    
\endtt}
\par}
\module{uvwdatrd}%
\noindent Read wideband correlator data.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvdat.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} uv-i/o, uv-data, uv-selection
\par{\tenpoint
{\eightpoint\begintt
        subroutine UVWDatRd(tIn,data,flags,n,nread)

        implicit none
        integer tIn,n,nread
        complex data(n)
        logical flags(n)

  This reads wideband data, and optionally applies the gain factor. It
  ignores end-of-file (uvDatRd should handle this).

  Input:
    n          The size of the data and flags arrays.
  Outputs:
    tIn        The handle of the uv data set.
    data       The uvread correlation data.
    flags      The uvread flags data.
    data       The correlation data.
    nread      The number of channels read.
\endtt}
\par}
\module{uvwread}%
\noindent Read in the wideband uv correlation data.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvwread(tno,data,flags,n,nread)
        integer tno,n,nread
        complex data(n)
        logical flags(n)

  This reads a single wideband visibility record from the data file.
  This should generally be called after uvread. It performs no scanning
  before returning the data. Otherwise uvwread generally performs the
  same massaging steps as uvread.

  Input:
    tno         Handle of the uv data set.
    n           Max number of channels that can be read.
  Output:
    data        A array of at least n complex elements (or 2n real
                elements). This returns the correlation data.
    flags       Logical array of at least n elements. A true value for
                a channel indicates good data.
    nread       Number of correlations returned. On end-of-file, zero
                is returned.                                            
\endtt}
\par}
\module{uvwrite}%
\noindent Write correlation data to a uv file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvwrite(tno,preamble,data,flags,n)
        integer tno,n
        double precision preamble(4)
        complex data(n)
        logical flags(n)

  Write a visibility record to the data file.
  Input:
    tno         Handle of the uv data set.
    n           Number of channels to be written.
    preamble    A double array of 4 elements giving u,v, time and
                baseline number (in that order).
    data        A complex array of n elements containing
                the correlation data.
    flags       Logical array of n elements. A true value for
                a channel indicates good data.                          
\endtt}
\par}
\module{uvwwrite}%
\noindent Write wide-band correlation data to a uv file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvio.c
\newline \abox{Responsible:} Robert Sault
\newline \abox{Keywords:} uv-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine uvwwrite(tno,data,flags,n)
        integer tno,n
        complex data(n)
        logical flags(n)

  Write a wide-band visibility record to the data file.
  Input:
    tno         Handle of the uv data set.
    n           Number of channels to be written.
    data        A complex array of n elements containing
                the correlation data.
    flags       Logical array of n elements. A true value for
                a channel indicates good data.                          
\endtt}
\par}
\module{vectav}%
\noindent Vector averaging with lookup index table
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calphase.for
\newline \abox{Keywords:} calibration, vector-average
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
      SUBROUTINE vectav (b,p,count,avidx,clump,nclump,x,y,dtaver,tmax)

      INTEGER avidx(*), clump(*), b, p, count, nclump
      REAL    x(*), y(*), dtaver,tmax

  Vector average the wide band calibration data in rdata(). For a
  given set (baseline,slot)=(b,p) a vector average with time
  resolution 'dtaver' is done. Data are assumed to be timesorted
  through the avidx() index array.

  Input:
     b        --  baseline index (1..nbl)
     p        --  slot for phase/amplitude (1..4)
     count    --  length of index array (lookup table in Rtime())
     avidx    --  index array: Rtime(avidx(i)) are used
     dtaver   --  max timestep in clump formation
     tmax     --  max time to integrate for in clump formation
  Output:
     nclump   --  length of filled in data in array (x,y)
     x        --  array of averaged times (x(j), j=1..nclump)
     y        --  array of vector averaged phase or amplitude (see p)
     clump    --  lookup table of original data into clumps:
                   Data-element avidx(i) was used in clump(j)
                   (i=1..count)  (j=1..nclump)
\endtt}
\par}
\module{wedge}%
\noindent Load a wedge onto a TV device with user specified ranges.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/tvsubs.for
\newline \abox{Responsible:} Jim Morgan
\newline \abox{Keywords:} image-data, tv, display
\par{\tenpoint
{\eightpoint\begintt
      subroutine wedge(map, Nxy, Dir, chan, x0, y0, pmin, pmax, width)

      implicit none
      integer Nxy, Dir, chan, x0, y0, width
      real map(Nxy), pmin, pmax

  Displays a wedge of real numbers on the TV device scaled to the
  limits of the device.  If Dir is 1 and Nxy is too large (MAXDIM),
  the wedge is truncated (to MAXDIM).

  Input:
    map(Nxy)     Input real array of values.
    Nxy          The dimension of the wedge array.
    Dir          The direction to stretch the wedge.  If ``Dir'' is 0,
                 then the array is displayed along the x direction
                 and repeated ``width'' pixels upward; if ``Dir'' is 1,
                 then the array is displayed along the y direction
                 and repeated ``width'' pixels to the right.  Any
                 other value of Dir is treated as if Dir was set to 0.
    chan         The TV channel to load the wedge.
    x0, y0       The lower left corner to start loading the wedge.
    pmin         The minimum value of the array.
    pmax         The maximum value of the array.
    width        The number of pixels to repeat the wedge in
                 direction ``Dir'' on the display.

  Output:
    none
\endtt}
\par}
\module{whenfeq}%
\noindent Return locations equal to target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        subroutine whenfeq(n,array,inc,target,index,nval)

        implicit none
        integer n,inc,nval
        integer index(*)
        real array(*),target

  Whenfeq returns the all the locations in a real array equal to the real
  target.

  Inputs:
    n          Number of elements to be searched.
    array      The real array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Real value to be searched for in the array.

  Output:
    index      The integer array containing the index of locations
               equal to the target.
    nval       Number of values put in the index array.

  Reference:
  See page 4-65 to 4-71 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{whenfge}%
\noindent Return locations greater than or equal to the target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        subroutine whenfge(n,array,inc,target,index,nval)

        implicit none
        integer n,inc,nval
        integer index(*)
        real array(*),target

  Whenfge returns the all the locations in a real array greater than or equal
  to the real target.

  Inputs:
    n          Number of elements to be searched.
    array      The real array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Real value to be searched for in the array.

  Output:
    index      The integer array containing the index of locations
               greater than or equal to the target.
    nval       Number of values put in the index array.

  Reference:
  See page 4-65 to 4-71 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{whenfgt}%
\noindent Return locations greater than the target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        subroutine whenfgt(n,array,inc,target,index,nval)

        implicit none
        integer n,inc,nval
        integer index(*)
        real array(*),target

  Whenfgt returns the all the locations in a real array greater than the real
  target.

  Inputs:
    n          Number of elements to be searched.
    array      The real array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Real value to be searched for in the array.

  Output:
    index      The integer array containing the index of locations
               greater than the real target.
    nval       Number of values put in the index array.

  Reference:
  See page 4-65 to 4-71 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{whenfle}%
\noindent Return locations less than or equal to the target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        subroutine whenfle(n,array,inc,target,index,nval)

        implicit none
        integer n,inc,nval
        integer index(*)
        real array(*),target

  Whenfle returns the all the locations in a real array less than or equal
  to the real target.

  Inputs:
    n          Number of elements to be searched.
    array      The real array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Real value to be searched for in the array.

  Output:
    index      The integer array containing the index of locations
               less than or equal to the target.
    nval       Number of values put in the index array.

  Reference:
  See page 4-65 to 4-71 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{whenflt}%
\noindent Return locations less than the target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        subroutine whenflt(n,array,inc,target,index,nval)

        implicit none
        integer n,inc,nval
        integer index(*)
        real array(*),target

  Whenflt returns the all the locations in a real array less than the real
  target.

  Inputs:
    n          Number of elements to be searched.
    array      The real array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Real value to be searched for in the array.

  Output:
    index      The integer array containing the index of locations
               less than the target.
    nval       Number of values put in the index array.

  Reference:
  See page 4-65 to 4-71 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{whenfne}%
\noindent Return locations not equal to target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        subroutine whenfne(n,array,inc,target,index,nval)

        implicit none
        integer n,inc,nval
        integer index(*)
        real array(*),target

  Whenfne returns the all the locations in a real array not equal to the real
  target.

  Inputs:
    n          Number of elements to be searched.
    array      The real array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Real value to be searched for in the array.

  Output:
    index      The integer array containing the index of locations
               not equal to the target.
    nval       Number of values put in the index array.

  Reference:
  See page 4-65 to 4-71 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{whenige}%
\noindent Return locations greater than or equal to the integer target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        subroutine whenige(n,array,inc,target,index,nval)

        implicit none
        integer n,inc,nval
        integer index(*)
        integer array(*),target

  Whenige returns the all the locations in an integer array greater than or
  equal to the integer target.

  Inputs:
    n          Number of elements to be searched.
    array      The integer array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Integer value to be searched for in the array.

  Output:
    index      The integer array containing the index of locations
               greater than or equal to the target.
    nval       Number of values put in the index array.

  Reference:
  See page 4-65 to 4-71 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{whenigt}%
\noindent Return locations greater than the integer target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        subroutine whenigt(n,array,inc,target,index,nval)

        implicit none
        integer n,inc,nval
        integer index(*)
        integer array(*),target

  Whenigt returns the all the locations in an integer array greater than
  the integer target.

  Inputs:
    n          Number of elements to be searched.
    array      The integer array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Integer value to be searched for in the array.

  Output:
    index      The integer array containing the index of locations
               greater than the target.
    nval       Number of values put in the index array.

  Reference:
  See page 4-65 to 4-71 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{whenile}%
\noindent Return locations less than or equal to the integer target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        subroutine whenile(n,array,inc,target,index,nval)

        implicit none
        integer n,inc,nval
        integer index(*)
        integer array(*),target

  Whenile returns the all the locations in an integer array less than or
  equal to the integer target.

  Inputs:
    n          Number of elements to be searched.
    array      The integer array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Integer value to be searched for in the array.

  Output:
    index      The integer array containing the index of locations
               less than or equal to the target.
    nval       Number of values put in the index array.

  Reference:
  See page 4-65 to 4-71 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{whenilt}%
\noindent Return locations less than the target.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/math.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} scilib
\par{\tenpoint
{\eightpoint\begintt
        subroutine whenilt(n,array,inc,target,index,nval)

        implicit none
        integer n,inc,nval
        integer index(*)
        integer array(*),target

  Whenilt returns the all the locations in an integer array less than the
  integer target.

  Inputs:
    n          Number of elements to be searched.
    array      The integer array to be searched.
    inc        Skip distance between elements of the searched array.
    target     Integer value to be searched for in the array.

  Output:
    index      The integer array containing the index of locations
               less than the target.
    nval       Number of values put in the index array.

  Reference:
  See page 4-65 to 4-71 of the Cray "Library Reference Manual".
\endtt}
\par}
\module{width}%
\noindent Calculate wideband channel width
\newline \ 
\newline \abox{File:} \$MIR/src/subs/uvsubs.for
\newline \abox{Responsible:} Mel Wright
\newline \abox{Keywords:} uv-data, visibility
\par{\tenpoint
{\eightpoint\begintt
        subroutine width(nspect,sdf,nschan,wide)

        implicit none
        integer nspect,nschan(nspect)
        double precision sdf(nspect)
        real wide

  Calculates the width of the wideband synthesized channel from
  the correlator setup parameters.  This is used by UVHAT.

  Input:
    nspect     number of correlator spectra
    sdf        width of correlator spectra
    nschan     number of channels in each spectra
  Output:
    wide       width of synthesized wideband (ghz)
\endtt}
\par}
\module{win}%
\noindent Subroutine package for interactive plots, using PGPLOT.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
 The Win package consists of a set of subroutines for interactive
 display of simultaneous plots.  At any one time some subset of the plots are
 displayed in an X-Y grid, and cursor input can be directed toward and
 particular window.  Zooming and panning are also possible.  See CalFlag and
 VarPlot as examples.
\endtt}
\par}
\module{wincoord}%
\noindent Change PGPLOT coordinates to a window
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinCoord( x, y )
        implicit none
        integer x, y

    WinCoord sets the PGPLOT coordinates to a particular window for
    plotting.  Generally the user calls WinShow rather than calling this
    subroutine directly.
\endtt}
\par}
\module{wincurs}%
\noindent Get a character from a window
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE WinCurs( nx, ny, px, py, c )
        REAL      px, py
        INTEGER   nx, ny
        CHARACTER c*1

    WinCurs gets a character from the screen and returns an absolute
    position in {xpos, ypos}.  If the character was typed from within
    an active plot, then the window number is returned in {nx, ny},
    otherwise {nx, ny} is {0, 0}.  See WinToScr and WinToUsr.
    If the device did not have a cursor (like printers) char(0) is
    returned in c.
\endtt}
\par}
\module{winloc}%
\noindent Set window screen locations
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinLoc( Xlo, Xhi, Ylo, Yhi )
        implicit none
        real Xlo, Xhi, Ylo, Yhi

    WinLoc sets the location of a plot on the viewing surface.  Generally
    the user does not call WinLoc except for an application such as a
    button.
\endtt}
\par}
\module{winnear}%
\noindent Return the nearest point
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinNear( nx, ny, xpos, ypos, count, x, y, 
     1                      idx, dist )
        implicit none
        integer count, nx, ny, idx
        real xpos, ypos, x(*), y(*), dist

    WinNear finds the nearest data point to an absolute position.
    The ordinal number of the data point is returned if the point is
    unambiguous, otherwise the negative is returned.
\endtt}
\par}
\module{winnorm}%
\noindent Normalize plots and add a margin
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinNorm( margin )
        implicit none
        real margin

    WinNorm normalizes the set of active windows to have the same user
    coordinates and adds a margin around the data.  A margin of 0.1 is
    recommended.
\endtt}
\par}
\module{winnormy}%
\noindent Normalize plots and add a margin
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinNormY( margin )
        implicit none
        real margin

    WinNormY normalizes the set of active windows to have the same user
    Y coordinates ONLY and adds a margin around the data.  A margin of
    0.1 is recommended.
\endtt}
\par}
\module{winpick}%
\noindent Set the active windows
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinPick( Xlo, Xhi, Ylo, Yhi )
        implicit none
        integer Xlo, Xhi, Ylo, Yhi

    WinPick selects which of the available plots are to be acted upon or
    displayed.  If the user might use { 1, 4, 1, 3 } to effect a grid of
    4x3 plots.  Any further WinXxxx routine will operate on all the the
    selected plots is some fashion, either independently or with some sort
    of average.
\endtt}
\par}
\module{winpick1}%
\noindent Set an active window
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinPick1( X, Y )
        implicit none
        integer X, Y

    WinPick1 selects a particular plot, as in WinPick above.
\endtt}
\par}
\module{winpoint}%
\noindent Draw points
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine winpoint(n, x, y, ipt)
        implicit none
        integer n, ipt(*)
        real x(*), y(*)

    WinPoint draw a set of points - the symbol indicator is not
    exactly in the order of the standard pgplot graph markers,
    but a lookup table is used which reorder them a bit. Just
    a silly preference based history...

   Input:
       n     integer       Number of points in arrays
       x     real          Array of X-coordinates of points
       y     real          Array of Y-coordinates of points
       ipt   integer       Array of graph markers
\endtt}
\par}
\module{winqscal}%
\noindent Queries set window user scales for selected window
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinQScal( Xlo, Xhi, Ylo, Yhi )
        implicit none
        real Xlo, Xhi, Ylo, Yhi

    WinQScal returns the user coordinates of a plot window.  Select
    desired window using WinPick1. See WinScale.
\endtt}
\par}
\module{winscale}%
\noindent Set window user scales
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinScale( Xlo, Xhi, Ylo, Yhi )
        implicit none
        real Xlo, Xhi, Ylo, Yhi

    WinScale sets the user coordinates of a set of plots.  Also see
    WinSize and WinNorm.
\endtt}
\par}
\module{winscalx}%
\noindent Set window user X-scales
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinScalx( Xlo, Xhi )
        implicit none
        real Xlo, Xhi

    WinScaly sets the X user coordinates of a set of plots.  
    Also see WinScale.
\endtt}
\par}
\module{winscaly}%
\noindent Set window user Y-scales
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinScaly( Ylo, Yhi )
        implicit none
        real Ylo, Yhi

    WinScaly sets the Y user coordinates of a set of plots.  
    Also see WinScale.
\endtt}
\par}
\module{winset}%
\noindent Set max unzoomed window matrix
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinSet(Xhi,Yhi)
        implicit none
        integer Xhi, Yhi

    WinSet sets-up the maximum number of x-windows and y-windows
    allowed in all future calls. This routine must be called before
    calling WinPick or WinPick1
\endtt}
\par}
\module{winshow}%
\noindent Put the plots onto the screen
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinShow( xlabel, ylabel, title, func )
        implicit none
        character*(*) xlabel(*), ylabel(*),title(*)
        external func
        integer func

    WinShow show the plots on the screen by setting up the appropriate
    PGPLOT coordinates are calling func on each window.  Func is a user
    supplied routine which should draw the plot.  WinShow currently draws
    the box and labels, which are supplied in xlabel and ylabel.
    The title is draw in a smaller font to be able to more more info.

    The calling sequence of func is:

               subroutine func(x, y)
               integer x, y
\endtt}
\par}
\module{winsize}%
\noindent Size windows to the data
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinSize( N, X, Y )
        implicit none
        integer N
        real X(*), Y(*)

    WinSize sets the user coordinates of a set of windows to the minimum and
    maximum of a set of data points.  See also WinNorm.
\endtt}
\par}
\module{winsymb}%
\noindent Return win2pgplot symbol marker
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        integer function winsymb(i)
        implicit none
        integer i

   Input:
       i        integer        win symbol marker
   Output:
       winsymb  integer        pgplot symbol marker (0..31)
\endtt}
\par}
\module{wintoscr}%
\noindent Convert a point to screen coordinates
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinToScr( x, y, px, py )
        implicit none
        real px, py
        integer x, y

    WinToScr converts {xpos, ypos} from user coordinates to screen
    coordinates, such as those returned by WinCurs.
\endtt}
\par}
\module{wintousr}%
\noindent Convert a point to screen coordinates
\newline \ 
\newline \abox{File:} \$MIR/src/subs/win.for
\newline \abox{Responsible:} Peter Teuben
\newline \abox{Keywords:} plotting, pgplot, user-interaction
\par{\tenpoint
{\eightpoint\begintt
        subroutine WinToUsr( x, y, px, py )
        implicit none
        real px, py
        integer x, y

    WinToUsr converts {xpos, ypos} from screen coordinates to user
    coordinates.
\endtt}
\par}
\module{wrhda}%
\noindent Write a string-valued header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine wrhda(tno,keyword,value)
        integer tno
        character keyword*(*)
        character value*(*)

  Write a string valued header variable.

  Input:
    tno         The file handle of the data set.
    keyword     The name of the header variable.
    value       The value of the header variable.                       
\endtt}
\par}
\module{wrhdc}%
\noindent Write a complex-valued header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine wrhdc(tno,keyword,value)
        integer tno
        character keyword*(*)
        complex value

  Write a complex valued header variable.
  Input:
    tno         The file handle fo the data set.
    keyword     The name of the header variable.
    value       The complex value of the header variable.               
\endtt}
\par}
\module{wrhdd}%
\noindent Write a double precision valued header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine wrhdd(tno,keyword,value)
        integer tno
        character keyword*(*)
        double precision value

  Write the value of a header variable which has a double precision value.

  Input:
    tno         The handle of the data set.
    keyword     Name to the keyword.
    value       The double precision value.                             
\endtt}
\par}
\module{wrhdi}%
\noindent Write an integer valued header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine wrhdi(tno,keyword,value)
        integer tno
        character keyword*(*)
        integer value

  Write an integer valued header variable.

  Input:
    tno         The handle of the data set.
    keyword     The name of the header variable.
    value       The integer value of the header variable.               
\endtt}
\par}
\module{wrhdia}%
\noindent Write an integer array header variable
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        subroutine wrhdia( tno, itemname, length, value )

        integer tno, length
        character itemname*(*)
        integer   value(*)

   wrhdia:  writes a header variable of unknown type

   inputs:
       tno               -- handle of data set
       itemname          -- name of the item to write
       length            -- number of items
       value             -- value of the item
\endtt}
\par}
\module{wrhdr}%
\noindent Write a real valued header variable.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/headio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} header-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine wrhdr(tno,keyword,value)
        integer tno
        character keyword*(*)
        real value

  This writes a real-valued header keyword.
  Input:
    tno         Handle of the data set.
    keyword     Name of the keyword to write.
    value       The value of the keyword.                               
\endtt}
\par}
\module{writbrk}%
\noindent Write break point data
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsetio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE writbrk(file)

        CHARACTER*(*) file

       WriteBrk writes the breakpoint data to an already existing
       calibration data set

   Inputs:
       file -- name of the calibration set
\endtt}
\par}
\module{writeset}%
\noindent Write out data to a calibration set (timesorted)
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsetio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE writeset( file , checksrc)

        CHARACTER file*(*)
        LOGICAL   checksrc

   Input:
       file    --  name of the dataset to which a calbration dataset
                   is written. It must not exist yet, or routine will
                   bomb out
       checksrc    logical (true/false) denoting is sourcename needs
                   to be checked for breakpoint settings
\endtt}
\par}
\module{writflag}%
\noindent Write out flags to a calibration data set
\newline \ 
\newline \abox{File:} \$MIR/src/subs/calsetio.for
\newline \abox{Keywords:} calibration, i/o
\newline \abox{Responsible:} Peter Teuben
\par{\tenpoint
{\eightpoint\begintt
        SUBROUTINE writflag( file )

   WritFlag re-writes the flags of an already existing calibration
   set

   Input:
       file  - file name of calibration dataset

        character*(*) file
\endtt}
\par}
\module{xyclose}%
\noindent Close up an image file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/xyio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} image-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine xyclose(tno)
        integer tno

  This closes an image file.

  Input:
    tno         The handle of the image file.                           
\endtt}
\par}
\module{xyflgrd}%
\noindent Read image masking information (flags format).
\newline \ 
\newline \abox{File:} \$MIR/src/subs/xyio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} image-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine xyflgrd(tno,index,flags)
        integer tno,index
        logical flags(*)

  This reads image mask information. It is the counterpart of xyread.
  Input:
    tno         Handle of the image file.
    index       The row in a plane to read in. This varies betwen 1 and
                NAXIS2. Set xysetpl to change the plane being accessed.
  Output:
    flags       A logical array of NAXIS1 elements. A true value indicates
                that the pixel is good.                                 
\endtt}
\par}
\module{xyflgwr}%
\noindent Write image masking information (flags format).
\newline \ 
\newline \abox{File:} \$MIR/src/subs/xyio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} image-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine xyflgwr(tno,index,flags)
        integer tno,index
        logical flags(*)

  This writes image mask information. It is the counterpart of xywrite.
  Input:
    tno         Handle of the image file.
    index       The row in a plane to write out. This varies between 1 and
                NAXIS2. See xysetpl to set the which plane is to be
                accessed.
    flags       A logical array of NAXIS1 elements. A true value indicates
                that the pixel is good.                                 
\endtt}
\par}
\module{xymkrd}%
\noindent Read the masking information for an image (runs format).
\newline \ 
\newline \abox{File:} \$MIR/src/subs/xyio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} image-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine xymkrd(tno,index,runs,n,nread)
        integer tno,index,n,nread
        integer runs(n)

  This reads the masking information associated with a row of an image,
  and returns it in "runs" format. 

  Input:
    tnoe        The handle associated with the image.
    index       The index of the row to determine mask info about. The
                last call to xysetpl determines which plane to access.
    n           The size of the array to receive the mask info.
  Output:
    runs        The mask info, in "runs" form. If "i" varies from 1 to
                nread/2, then pixels runs(2*i-1) to runs(2*i) are
                good, whereas pixels runs(2*i) to runs(2*i+1) are bad.
    nread       The number of "runs" read.                              
\endtt}
\par}
\module{xymkwr}%
\noindent Write image masking information (runs format).
\newline \ 
\newline \abox{File:} \$MIR/src/subs/xyio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} image-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine xymkwr(tno,index,runs,n)
        integer tno,index,n
        integer runs(n)

  This writes out the masking information associated with a row of an image.
  This information is passes in in "runs" format. 

  Input:
    tnoe        The handle associated with the image.
    index       The index of the row to determine mask info about. The
                last call to xysetpl determines which plane to access.
    n           The size of the array containing the mask info.
    runs        The mask info, in "runs" form. If "i" varies from 1 to
                nread/2, then pixels runs(2*i-1) to runs(2*i) are
                good, whereas pixels runs(2*i) to runs(2*i+1) are bad.  
\endtt}
\par}
\module{xyopen}%
\noindent Open an image file.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/xyio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} image-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine xyopen(tno,name,status,naxis,axes)
        integer tno,naxis,axes(naxis)
        character name*(*),status*(*)

  This opens an image file. For an old file, determine the size of
  each axe. For a new file, it writes out this info.

  Input:
    name        The name of the file to be opened.
    status      Either 'old' or 'new'.
    naxis       The maximum number of axes that the calling program can
                handle. For an 'old' file, if the data file has fewer
                than naxis axes, the higher dimensions are treated as having
                only one element. If the data file has more than naxis
                axes, and the higher dimensions are more than 1 element
                deep, xyopen bombs out.
  Input or Output:
    axes        This is input for status='new' and output for status='old'.
                It gives the number of elements along each axis.
  Output:
    tno         The handle of the output file.                          
\endtt}
\par}
\module{xyread}%
\noindent Read a row from an image.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/xyio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} image-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine xyread(tno,index,array)
        integer tno,index
        real array(*)

  This reads a single row from an image. This accesses the plane given
  by the last call to xysetpl.

  Input:
    tno         The image file handle, returned by xyopen.
    index       The row number to read. This varies from 1 to NAXIS2.
  Output:
    array       The read row. NAXIS1 elements are returned.             
\endtt}
\par}
\module{xysetpl}%
\noindent Set which plane of a cube is to be accessed.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/xyio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} image-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine xysetpl(tno,naxis,nsize)
        integer tno,naxis,nsize(naxis)

  This sets up which plane of a cube is to be accessed.

  Input:
    tno         Handle of the image file.
    naxis       Size of the "nsize" array.
    nsize       This gives the indices, along the 3rd, 4th, 5th, etc
                dimensions, of the plane that is to be accessed. nsize(1)
                corresponds to the index along the 3rd dimension.       
\endtt}
\par}
\module{xywrite}%
\noindent Write a row to an image.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/xyio.c
\newline \abox{Responsible:} Mark Stupar
\newline \abox{Keywords:} image-i/o
\par{\tenpoint
{\eightpoint\begintt
FORTRAN call sequence:
        subroutine xywrite(tno,index,array)
        integer tno,index
        real array(*)

  This writes a single row to an image. This accesses the plane given
  by the last call to xysetpl.

  Input:
    tno         The image file handle, returned by xyopen.
    index       The row number to write. This varies from 1 to NAXIS2.
    array       The read row. NAXIS1 elements are written.              
\endtt}
\par}
\module{zed}%
\noindent Zeeman fit of I spectrum to V spectrum.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/zed.for
\newline \abox{Responsible:} Neil Killeen
\newline \abox{Keywords:} zeeman
\par{\tenpoint
{\eightpoint\begintt
        subroutine Zed(mode,ispect,vspect,m,n,a,b,siga,sigb,sigi,convrg)

        implicit none
        character mode*(*)
        integer m,n
        logical convrg
        real ispect(m,n),vspect(m,n),a,b,siga,sigb,sigi

  This finds values of a and b, which are optimal in either a maximum
  likelihood or least squares sense, such that

    V = a*D*I + b*I

  One solution for a and b is found for the n given spectra.

  Here D is a matrix approximating a derivative operator. The derivative
  formula used here is either:
    f(i) - f(i-1)
  or
    0.5*(f(i+1) - f(i-1))
\endtt}
{eightpoint\begintt
  Inputs:
    ispect,vspect Measured I and V spectra.
    m          Number of data points in the I and V spectra.
    n          Number of spectra.
    mode       This consists of flags, which determine
               the algorithm to be used. Possible characters are:
                 '2'   Use two sided derivative estimate. Otherwise a
                       one sided derivative is used.
                 'm'   Use the maximum likelihood technique, otherwise a 
                       least squares algorithm is used.
                 'l'   Fit for the leakage parameter as well.
                 'x'   Perform extra checks that we have converged to the
                       global minimum. This slows down the algorithm by
                       about a factor of 3. This should be used in cases
                       of poor signal to noise.
                  'd'  Debiased least squares. This debiases alpha and sigma
                       alpha only.
               For example, mode='mlx2' means use max. likelihood, including
               leakage, use two sided derivative, and perform extra checks
               that we have converged to the global minimum.
  Output:
    a,b        Estimated a and b parameters.
    siga,sigb  Estimates of the error in a and b.
    sigi       Estimate of the rms noise.
    convrg     True if the procedure converged. It is generally safe to
               ignore this. Even when it indicates the algorithm has
               failed to converge, it actually means that it is essentially
               at the minimum, but not all conditions for convergence have
               yet to be satisfied.
\endtt}
\par}
\module{zedfudge}%
\noindent Calculate sigma fudge factor, for Zeeman experiments.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/zed.for
\newline \abox{Responsible:} Neil Killeen
\newline \abox{Keywords:} zeeman
\par{\tenpoint
{\eightpoint\begintt
        subroutine ZedFudge(mode,ispect,vspect,m,n1,n2,a,b,fudge,
     *                                                  rho,beam,nx,ny)

        implicit none
        character mode*(*)
        integer m,n1,n2,nx,ny
        real ispect(m,n1*n2),vspect(m,n1*n2)
        real a,b,fudge,rho,beam(nx*ny)

  This determines the fudge factor that the sigma_{alpha} estimate
  should be multiplied by to give a correct value. This is used when
  the noise is correlated.

  Inputs:
    mode       '2' indicates that we should use a two sided derivative.
    m          Number of channels.
    n1,n2      Number of pixels in x and y.
    ispect     I spectra.
    vspect     V spectra.
    a,b        Values of alpha and beta to use.
    rho        Correlation factor in the spectral dimension.
    beam       Dirty beam patch.
    nx,ny      Size of the dirty beam patch.

  Output:
    fudge      Sigma fudge factor. Sigma estimates derived by ignoring the
               noise correlation should be multiplied by this fudge factor
               to get better error estimates.
\endtt}
\par}
\module{zedfunc}%
\noindent Return Zeeman maximum likelihood chi**2 value.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/zed.for
\newline \abox{Responsible:} Neil Killeen
\newline \abox{Keywords:} zeeman
\par{\tenpoint
{\eightpoint\begintt
        subroutine ZedFunc(mode,ispect,vspect,m,n,a,b,sigi)

        implicit none
        integer m,n
        real ispect(m,n),vspect(m,n),a,b,sigi
        character mode*(*)

  This returns a normalized value of chi^2, given a and b.

  Inputs:
    mode       Flags to the algorithm. The only recognized flag is '2',
               for two sided derivative.
    ispect,vspect I and V spectra.
    m          Number of channels.
    n          Number of spectra.
    a,b        Alpha and beta parameters of interest.

  Output:
    sigi       Normalized version of chi^2. In particular
               sigi = sqrt{chi^2/((m-1)*n)}
               The expected value of this at the minimum is sigma_I.
\endtt}
\par}
\module{zedihat}%
\noindent Calculate Zeeman estimate of a true I spectrum
\newline \ 
\newline \abox{File:} \$MIR/src/subs/zed.for
\newline \abox{Responsible:} Neil Killeen
\newline \abox{Keywords:} zeeman
\par{\tenpoint
{\eightpoint\begintt
        subroutine ZedIHat(mode,ispect,vspect,m,n,a,b,ihat)

        implicit none
        character mode*(*)
        integer m,n
        real ispect(m,n),vspect(m,n),ihat(m,n)
        real a,b

  This returns an estimate of the true I spectrum, given a and b.

  Inputs:
    mode       Flags to the algorithm. The only recognized flag is '2',
               for two sided derivative.
    ispect,vspect Observed I and V spectra.
    m          Number of channels.
    n          Number of spectra.
    a,b        Alpha and beta parameters of interest.

  Output:
    ihat       An estimate of the true value of I.
\endtt}
\par}
\module{zedrho}%
\noindent Estimate Zeeman splitting, for spectrally correlated noise.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/zed.for
\newline \abox{Responsible:} Neil Killeen
\newline \abox{Keywords:} zeeman
\par{\tenpoint
{\eightpoint\begintt
        subroutine ZedRho(mode,ispect,vspect,m,n,rho,a,b,siga,sigb,sigi,
     *                                          convrg)

        implicit none
        character mode*(*)
        integer m,n
        real ispect(m),vspect(m),rho,a,b,siga,sigb,sigi
        logical convrg

  This finds the maximum likelihood solution, when there is correlation
  between adjacent channels. This performs a proper treatment. There are
  no approximations.

  Inputs:
    ispect,vspect Measured I and V spectra.
    m          Number of data points in the I and V spectra.
    n          Number of spectra. Currently this must be 1.
    mode       Currently ignored.
    rho        Channel-to-channel correlation coefficient.
  Output:
    a,b        Estimated a and b parameters.
    siga,sigb  Estimates of the error in a and b.
    sigi       Estimate of the rms noise.
    convrg     True if the procedure converged. It is generally safe to
               ignore this. Even when it indicates the algorithm has
               failed to converge, it actually means that it is essentially
               at the minimum, but not all conditions for convergence have
               yet to be satisfied.
  Limitations:
    Unlike Zed, this does not handle multiple spectra, leakage terms,
    2-sided derivative nor does it do extra searching to avoid spurious
    minima. Its estimate of siga is not as good as Zed's. Generally
    it is faster and just as accurate (more accurate in siga) to call
    the combination of Zed and ZedFudge.
\endtt}
\par}
\module{zedscale}%
\noindent Determine conversion factor from channels to magnetic field.
\newline \ 
\newline \abox{File:} \$MIR/src/subs/zed.for
\newline \abox{Responsible:} Neil Killeen
\newline \abox{Keywords:} zeeman
\par{\tenpoint
{\eightpoint\begintt
      subroutine ZedScale (lunI, freq, scale, noline)

      implicit none
      integer lunI
      real scale,freq
      logical noline

     Depending on the first axis type, set the scale to convert
     from a channel increment to a frequency increment (Hz) and then
     if possible, to a magnetic field strength

     Input:
        lunI    i  Handle for I spectrum cube
        freq    r  Frequency (GHz) of line for matching with
                   Zeeman parameters stored internally   
     Output:
        scale   r  If noline=.false. scale converts delta_channel to
                   a magnetic field strength, else scale converts
                   only to a delta_freq (Hz)
        noline  l  If .false. the user specified FREQ was matched
\endtt}
\par}
\module{zedvhat}%
\noindent Calculate Zeeman estimate of a true V spectrum
\newline \ 
\newline \abox{File:} \$MIR/src/subs/zed.for
\newline \abox{Responsible:} Neil Killeen
\newline \abox{Keywords:} zeeman
\par{\tenpoint
{\eightpoint\begintt
        subroutine ZedVHat(mode,IHat,m,n,a,b,VHat)

        implicit none
        character mode*(*)
        integer m,n
        real IHat(m,n), VHat(M,n)
        real a,b

  This returns an estimate of the true V spectrum, given a, b and IHat

  Inputs:
    mode       Flags to the algorithm. The only recognized flag is '2',
               for two sided derivative.
    IHat       Estimate of true noiseless spectrum
    m          Number of channels.
    n          Number of spectra.
    a,b        Alpha and beta parameters of interest.

  Output:
    VHat       An estimate of the true value of V.  Note that the first
               and possibly last (depending on derivative type) is NOT 
               filled.
\endtt}
\par}
