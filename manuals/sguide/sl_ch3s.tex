\par{\bf \$MIR/src/subs/amphase.for}
{\eightpoint\begintt
amphase ....... pjt .... Compute amplitude and phase.
\endtt}
\par{\bf \$MIR/src/subs/angles.for}
{\eightpoint\begintt
dangle ........ jm ..... Convert degrees/hours value into a formatted string.
hangle ........ jm ..... Convert hours value (in radians) into a formatted string.
rangle ........ jm ..... Convert degrees value (in radians) into a formatted string.
\endtt}
\par{\bf \$MIR/src/subs/ari.for}
{\eightpoint\begintt
aricomp ....... pjt .... Parse a Fortran-like expression.
ariexec ....... pjt .... Evalute an expression, previously parsed by AriComp.
\endtt}
\par{\bf \$MIR/src/subs/assert.for}
{\eightpoint\begintt
assert ........ pjt .... Assert a condition, otherwise bug out
assertf ....... pjt .... Assert a file existence condition, otherwise bug out
asserti2 ...... pjt .... Assert a condition, otherwise bug out
\endtt}
\par{\bf \$MIR/src/subs/axistype.for}
{\eightpoint\begintt
axistype ...... mchw ... Find the axis label and plane value in user friendly units
\endtt}
\par{\bf \$MIR/src/subs/basant.for}
{\eightpoint\begintt
basant ........ jm ..... Routine to determine antennas from baseline number.
\endtt}
\par{\bf \$MIR/src/subs/boxes.for}
{\eightpoint\begintt
boxes ......... mjs .... Summary of region of interest routines.
boxinfo ....... mjs .... Determine bounding box of the region of interest.
boxinput ...... mjs .... Read command line box specification.
boxmask ....... mjs .... AND in a mask to the region of interest.
boxrect ....... mjs .... Determine in a region-of-interest is rectangular.
\endtt}
{\eightpoint\begintt
boxruns ....... mjs .... Return region of interest in "runs" form.
boxset ........ mjs .... Set default region of interest.
\endtt}
\par{\bf \$MIR/src/subs/bsrch.for}
{\eightpoint\begintt
bsrcha ........ mchw ... Search a list of strings for a particular string.
bsrchi ........ mchw ... Search a list of integers for a particular integer.
\endtt}
\par{\bf \$MIR/src/subs/bug.for}
{\eightpoint\begintt
bug ........... mjs .... Give an error message, and abort if needed.
bugno ......... mjs .... Give a error message associated with a particular error number.
\endtt}
\par{\bf \$MIR/src/subs/calio.for}
{\eightpoint\begintt
caclose ....... pjt .... Close a calibration set
cadread ....... pjt .... Read data from a calibration set
cadwrite ...... pjt .... Write data into a calibration set
caerror ....... pjt .... Write a calibration I/O error
caflag ........ pjt .... Flag data in a calibration set
\endtt}
{\eightpoint\begintt
caopen ........ pjt .... Open a calibration set
casread ....... pjt .... Read source index data
caswrite ...... pjt .... Write source index data
rdhdia ........ pjt .... Read an integer array header variable
wrhdia ........ pjt .... Write an integer array header variable
\endtt}
\par{\bf \$MIR/src/subs/calphase.for}
{\eightpoint\begintt
flipper ....... pjt .... Flip phases into a continuous string
getclo3 ....... pjt .... Return sign for closure calculation for 3 baselines
miniflip ...... lgm .... Flip phases into a continuous string
phaseamp ...... pjt .... Convert to phase/amplitude
phasedis ...... pjt .... Find consistent antenna phases
\endtt}
{\eightpoint\begintt
phiwrap ....... pjt .... Returns the number of 2pi wraps
vectav ........ pjt .... Vector averaging with lookup index table
\endtt}
\par{\bf \$MIR/src/subs/calpoly.for}
{\eightpoint\begintt
addpoly ....... pjt .... Add a polynomial to the database of polynomials
chkpoly ....... pjt .... Check if the current polynomial is set
evalpoly ...... pjt .... Evaluate a polynomial
fitpoly ....... pjt .... Fit a polynomial
getpoly ....... pjt .... Read in the phase-amplitude calibration fit
\endtt}
{\eightpoint\begintt
inipoly ....... pjt .... Forced initialize polynomials
putpoly ....... pjt .... Write out the phase-amplitude calibration fit
\endtt}
\par{\bf \$MIR/src/subs/calsetio.for}
{\eightpoint\begintt
addhist ....... pjt .... Add history to a dataset
hisappn ....... pjt .... Append history from a file to an open dataset
putsrc ........ pjt .... Write out source stuff
readbrk ....... pjt .... Read breakpoint data
readset ....... pjt .... Read in data from a calibration set
\endtt}
{\eightpoint\begintt
writbrk ....... pjt .... Write break point data
writeset ...... pjt .... Write out data to a calibration set (timesorted)
writflag ...... pjt .... Write out flags to a calibration data set
\endtt}
\par{\bf \$MIR/src/subs/calsubs.for}
{\eightpoint\begintt
ampscal ....... pjt .... Scale amplitudes of a calibrator
blname ........ pjt .... Returns baseline name
code2s ........ pjt .... Convert ascii code to integer slot code
findbase ...... pjt .... Returns the baseline number
findsrc ....... pjt .... Find index of word in a list of words
\endtt}
{\eightpoint\begintt
getants ....... pjt .... Returns the number of antennas and antenna pair
getslot ....... pjt .... Get all slots that match wildcard slotcode
s2code ........ pjt .... Convert integer slot code to 4 character slot code
scalunit ...... pjt .... Set calibration unit conversion mode
setsflag ...... pjt .... Set flags along time axis according to selected sources
\endtt}
{\eightpoint\begintt
taver ......... pjt .... Scalar averaging an array
\endtt}
\par{\bf \$MIR/src/subs/convl.for}
{\eightpoint\begintt
convl ......... mjs .... Performs the convolution of the image with the beam.
convlini ...... mjs .... Initialize the convolution routines.
\endtt}
\par{\bf \$MIR/src/subs/ctrl.for}
{\eightpoint\begintt
ctrlchck ...... jm ..... Check if a particular buttons has been pushed.
ctrlclr ....... jm ..... Clear any memory in the control panel of buttons being pressed.
ctrldef ....... jm ..... Define a control panel button, etc.
ctrlfin ....... jm ..... Close down the control panel.
ctrlinit ...... jm ..... Initialise the panel panel.
\endtt}
{\eightpoint\begintt
ctrlopen ...... jm ..... Open the panel panel.
ctrlset ....... jm ..... Set the value of a control panel button, etc.
ctrlview ...... jm ..... Pop up the control panel on the workstation screen.
ctrlwait ...... jm ..... Wait for a button to be pressed.
\endtt}
\par{\bf \$MIR/src/subs/deghms.for}
{\eightpoint\begintt
deghms ........ bpw .... Write out ra and dec in hms/dms from input in degrees
radhms ........ bpw .... Write out ra and dec in hms/dms from input in radians
\endtt}
\par{\bf \$MIR/src/subs/delay.for}
{\eightpoint\begintt
delay ......... mjs .... Delay a specified length of time.
\endtt}
\par{\bf \$MIR/src/subs/fft.for}
{\eightpoint\begintt
fftcc ......... pjt .... Complex to complex 1D FFT routine.
fftcr ......... pjt .... Complex to real 1D FFT routine.
fftrc ......... pjt .... Real to complex 1D FFT
\endtt}
\par{\bf \$MIR/src/subs/filedel.for}
{\eightpoint\begintt
filedel ....... pjt .... Delete a file
\endtt}
\par{\bf \$MIR/src/subs/findname.for}
{\eightpoint\begintt
findname ...... jm ..... Return the expanded name of a file.
\endtt}
\par{\bf \$MIR/src/subs/fitsio.for}
{\eightpoint\begintt
fitcdio ....... rjs .... Sequential read or write of a FITS header.
fitrdhda ...... rjs .... Read a character value from a FITS file header.
fitrdhdd ...... rjs .... Read a double precision value from a FITS file header.
fitrdhdi ...... rjs .... Read an integer value from a FITS file header.
fitrdhdl ...... rjs .... Read a logical value from a FITS file header.
\endtt}
{\eightpoint\begintt
fitrdhdr ...... rjs .... Read a real value from a FITS file header.
fitsrch ....... rjs .... Search for a keyword in the header of an old FITS file.
fitwrhda ...... rjs .... Write a string to a FITS file header.
fitwrhdd ...... rjs .... Write a double precision keyword to a FITS file header.
fitwrhdh ...... rjs .... Write a string to a FITS file header.
\endtt}
{\eightpoint\begintt
fitwrhdi ...... rjs .... Write an integer value to a FITS file header.
fitwrhdl ...... rjs .... Write a logical value to a FITS file header.
fitwrhdr ...... rjs .... Write a real value to a FITS file header.
fuvclose ...... rjs .... Close a UV FITS file.
fuvopen ....... rjs .... Open a FITS uv file.
\endtt}
{\eightpoint\begintt
fuvrdhd ....... rjs .... Get coordinate information about a UV FITS file.
fuvread ....... rjs .... Read visibility data from UV FITS file.
fuvsetlm ...... rjs .... Set the ranges of parameters for a FITS UV file.
fuvtoff ....... rjs .... Get time offset for a UV FITS file.
fuvwrhd ....... rjs .... Save UV FITS file coordinate information.
\endtt}
{\eightpoint\begintt
fuvwrite ...... rjs .... Write data to a UV FITS file.
fxyclose ...... rjs .... Close a FITS image file.
fxyopen ....... rjs .... Open a FITS image file.
fxyread ....... rjs .... Read a row of data from a FITS image.
fxysetlm ...... rjs .... Set the pixel range for scaling a FITS image.
\endtt}
{\eightpoint\begintt
fxysetpl ...... rjs .... Select the plane of interest in a FITS image.
fxywrite ...... rjs .... Write a row of a FITS image.
\endtt}
\par{\bf \$MIR/src/subs/fullname.for}
{\eightpoint\begintt
fullname ...... bpw .... Expand an environment variable in front of a filename
remext ........ bpw .... Remove the extension part of a filename
\endtt}
\par{\bf \$MIR/src/subs/getbeam.for}
{\eightpoint\begintt
getbeam ....... mchw ... Get beam from image header.
\endtt}
\par{\bf \$MIR/src/subs/getpb.for}
{\eightpoint\begintt
getpb ......... pjt .... Determine the primary beam associated with a image.
\endtt}
\par{\bf \$MIR/src/subs/grid.for}
{\eightpoint\begintt
corrfun ....... mchw ... Generate the gridding convolution correction function.
gcffun ........ mchw ... Generate the gridding convolution function.
\endtt}
\par{\bf \$MIR/src/subs/hann.for}
{\eightpoint\begintt
hannsm ........ jm ..... Hanning smooth a data array..
hcoeffs ....... jm ..... Calculated coefficients for Hanning smoothing.
rfac .......... jm ..... Calculate n factorial.
\endtt}
\par{\bf \$MIR/src/subs/headio.c}
{\eightpoint\begintt
hdcopy ........ mjs .... Copy a headfer variable from one data set to another.
hdprobe ....... mjs .... Determine characteristics of a header variable.
hdprsnt ....... mjs .... Determine if a header variable is present.
hisclose ...... mjs .... This closes the history file.
hisopen ....... mjs .... Open the history file.
\endtt}
{\eightpoint\begintt
hisread ....... mjs .... Read a line of text from the history file.
hiswrite ...... mjs .... Write a line of text to the history file.
rdhda ......... mjs .... Read a string-valued header variable.
rdhdc ......... mjs .... Read a complex-valued header variable.
rdhdd ......... mjs .... Read a double precision-valued header variable.
\endtt}
{\eightpoint\begintt
rdhdi ......... mjs .... Read an integer-valued header variable.
rdhdr ......... mjs .... Read a real-valued header variable.
wrhda ......... mjs .... Write a string-valued header variable.
wrhdc ......... mjs .... Write a complex-valued header variable.
wrhdd ......... mjs .... Write a double precision valued header variable.
\endtt}
{\eightpoint\begintt
wrhdi ......... mjs .... Write an integer valued header variable.
wrhdr ......... mjs .... Write a real valued header variable.
\endtt}
\par{\bf \$MIR/src/subs/hio.c}
{\eightpoint\begintt
haccess ....... mjs .... Open an item of a data set for access.
hclose ........ mjs .... Close a Miriad data set.
hdaccess ...... mjs .... Finish up access to an item.
hdelete ....... mjs .... Delete an item from a data-set.
hopen ......... mjs .... Open a data set.
\endtt}
{\eightpoint\begintt
hread ......... mjs .... Hwrite -- Read and write items.
hsize ......... mjs .... Determine the size (in bytes) of an item.
\endtt}
\par{\bf \$MIR/src/subs/hisinput.for}
{\eightpoint\begintt
hisinput ...... jm ..... Copy task input parameters to a history file.
\endtt}
\par{\bf \$MIR/src/subs/hsort.for}
{\eightpoint\begintt
hsorta ........ jm ..... Perform an index heapsort on a character string array.
hsortad ....... jm ..... Perform a dual index heapsort on a character string array.
hsortar ....... jm ..... Perform a dual index heapsort on a character string array.
hsortd ........ jm ..... Perform an indexed heapsort on a double precision array.
hsorti ........ jm ..... Perform an indexed heapsort on a integer array.
\endtt}
{\eightpoint\begintt
hsortr ........ jm ..... Perform an indexed heapsort on a real array.
hsortrr ....... jm ..... Perform a dual index heapsort on a real array.
\endtt}
\par{\bf \$MIR/src/subs/imminmax.for}
{\eightpoint\begintt
imminmax ...... jm ..... Return Miriad image minimum and maximum value.
\endtt}
\par{\bf \$MIR/src/subs/intpio.for}
{\eightpoint\begintt
intpini ....... mjs .... Initialize the interpolation i/o routines.
intprd ........ mjs .... Read a row of interpolated data
intprini ...... mjs .... Reinitialize the interpolation i/o routines.
\endtt}
\par{\bf \$MIR/src/subs/iscoords.for}
{\eightpoint\begintt
iscoords ...... bpw .... Test if input string can represent coordinates and convert it
\endtt}
\par{\bf \$MIR/src/subs/j1xbyx.for}
{\eightpoint\begintt
j1xbyx ........ mchw ... Calculate j1(x)/x
\endtt}
\par{\bf \$MIR/src/subs/julday.for}
{\eightpoint\begintt
dayjul ........ jm ..... Format a conventional calendar day into a Julian day.
julday ........ jm ..... Format a Julian day into a conventional calendar day.
todayjul ...... jm ..... Format the current day into a Julian day.
\endtt}
\par{\bf \$MIR/src/subs/key.for}
{\eightpoint\begintt
keya .......... pjt .... Retrieve a character string from the command line.
keyd .......... pjt .... Retrieve a double precision from the command line.
keyf .......... pjt .... Retrieve a filename string (with wildcards) from the command line.
keyfin ........ pjt .... Finish access to the 'key' routines.
keyi .......... pjt .... Retrieve an integer from the command line.
\endtt}
{\eightpoint\begintt
keyini ........ pjt .... Initialise the `key' routines.
keyl .......... pjt .... Retrieve a logical value from the command line
keyprsnt ...... pjt .... Determine if a keyword is present on the command line.
keyr .......... pjt .... Retrieve a real value from the command line.
mkeya ......... pjt .... Retrieve multiple character values from the command line.
\endtt}
{\eightpoint\begintt
mkeyf ......... pjt .... Retrieve multiple filenames.
mkeyi ......... pjt .... Retrieve multiple integer values from the command line.
mkeyr ......... pjt .... Retrieve multiple real values from the command line.
progname ...... pjt .... Return name of the program currently running
\endtt}
\par{\bf \$MIR/src/subs/linetype.for}
{\eightpoint\begintt
linetype ...... bpw .... Read standard linetype keyword and transfer information to uvio
\endtt}
\par{\bf \$MIR/src/subs/log.for}
{\eightpoint\begintt
logclose ...... bpw .... Finish up with the log file.
logopen ....... bpw .... Initialise the log file routines.
logwrit ....... bpw .... Write a line to the log file.
logwrite ...... bpw .... Write a line to the log file.
\endtt}
\par{\bf \$MIR/src/subs/lsqu.for}
{\eightpoint\begintt
linlsq ........ bpw .... Return parameters of a straight line fit
llsqu ......... bpw .... Linear least squares fitting
nllsqu ........ bpw .... Nonlinear least squares fitting
\endtt}
\par{\bf \$MIR/src/subs/luns.for}
{\eightpoint\begintt
freelun ....... mjs .... Release a logical unit, previously allocated with GetLun.
getlun ........ mjs .... Get a logical unit number.
\endtt}
\par{\bf \$MIR/src/subs/math.for}
{\eightpoint\begintt
ismax ......... pjt .... Return index of maximum value of a real array.
ismin ......... pjt .... Return index of minimum value of a real array.
isrchfge ...... pjt .... Search real vector for target.
isrchfgt ...... pjt .... Search real vector for target.
isrchfle ...... pjt .... Search real vector for target.
\endtt}
{\eightpoint\begintt
isrchflt ...... pjt .... Search real vector for target.
isrchieq ...... pjt .... Search integer vector for target.
isrchige ...... pjt .... Search integer vector for target.
isrchigt ...... pjt .... Search integer vector for target.
isrchile ...... pjt .... Search integer vector for target.
\endtt}
{\eightpoint\begintt
isrchilt ...... pjt .... Search integer vector for target.
isrchine ...... pjt .... Search integer vector for target.
whenfeq ....... pjt .... Return locations equal to target.
whenfge ....... pjt .... Return locations greater than or equal to the target.
whenfgt ....... pjt .... Return locations greater than the target.
\endtt}
{\eightpoint\begintt
whenfle ....... pjt .... Return locations less than or equal to the target.
whenflt ....... pjt .... Return locations less than the target.
whenfne ....... pjt .... Return locations not equal to target.
whenige ....... pjt .... Return locations greater than or equal to the integer target.
whenigt ....... pjt .... Return locations greater than the integer target.
\endtt}
{\eightpoint\begintt
whenile ....... pjt .... Return locations less than or equal to the integer target.
whenilt ....... pjt .... Return locations less than the target.
\endtt}
\par{\bf \$MIR/src/subs/model.for}
{\eightpoint\begintt
model ......... mchw ... Calculate model visibilities, given a model image.
modelini ...... mchw ... Ready the uv data file for processing by the Model routine.
\endtt}
\par{\bf \$MIR/src/subs/nextpow2.for}
{\eightpoint\begintt
nextpow2 ...... mchw ... Find the next power of two.
\endtt}
\par{\bf \$MIR/src/subs/noise.for}
{\eightpoint\begintt
gaus .......... rjs .... Generate gaussianly distributed random variables.
randset ....... rjs .... Set random number generator seed.
uniform ....... rjs .... Return uniformly distributed random variables.
\endtt}
\par{\bf \$MIR/src/subs/options.for}
{\eightpoint\begintt
options ....... bpw .... Get command line options.
\endtt}
\par{\bf \$MIR/src/subs/packi2.for}
{\eightpoint\begintt
packi2 ........ mjs .... Pack normal integers into 16 bit integers
unpacki2 ...... mjs .... Unpack 16 bit integers into normal integers
\endtt}
\par{\bf \$MIR/src/subs/pghline.for}
{\eightpoint\begintt
pghline ....... mchw ... Histogram line plot for pgplot.
\endtt}
\par{\bf \$MIR/src/subs/plane.for}
{\eightpoint\begintt
getplane ...... mjs .... Read portion of a plane, specified by runs format.
putplane ...... mjs .... Writes a portion of a plane, specified by runs format.
putruns ....... mjs .... Writes the blanking file of an image.
\endtt}
\par{\bf \$MIR/src/subs/plotone.for}
{\eightpoint\begintt
plotone ....... lgm .... Plot one or more set of x,y points on a single graph
\endtt}
\par{\bf \$MIR/src/subs/poly.for}
{\eightpoint\begintt
rpolyzr ....... bpw .... Roots of a real polynomial.
\endtt}
\par{\bf \$MIR/src/subs/polyfit.for}
{\eightpoint\begintt
lsqfill ....... pjt .... Add sums-of-squares to least squares matrix
solve ......... pjt .... Solve a matrix
squares ....... pjt .... Compute sums-of-squares
\endtt}
\par{\bf \$MIR/src/subs/powell.for}
{\eightpoint\begintt
powell ........ bpw .... Minimization of a function, without derivative information.
\endtt}
\par{\bf \$MIR/src/subs/prime.for}
{\eightpoint\begintt
prime ......... jm ..... Returns a prime less than or equal to N.
\endtt}
\par{\bf \$MIR/src/subs/r8tyx.for}
{\eightpoint\begintt
r8tyx ......... mchw ... Radix, 8 iterations
\endtt}
\par{\bf \$MIR/src/subs/scrio.c}
{\eightpoint\begintt
scrclose ...... mjs .... Close and delete a scratch file.
scropen ....... mjs .... Open a scratch file.
scrread ....... mjs .... Read real data from a scratch file.
scrwrite ...... mjs .... Write real data to the scratch file.
\endtt}
\par{\bf \$MIR/src/subs/select.for}
{\eightpoint\begintt
selapply ...... bpw .... Call the appropraite uv routine to set the uv selection.
selinput ...... bpw .... Get the users uv selection specification.
selprobe ...... bpw .... Check if a particular uv data has been selected.
\endtt}
\par{\bf \$MIR/src/subs/sfetra.for}
{\eightpoint\begintt
sfetra ........ bpw .... Transformation between equatorial and other coordinate systems
\endtt}
\par{\bf \$MIR/src/subs/shadowed.for}
{\eightpoint\begintt
shadowed ...... bpw .... (no description)
\endtt}
\par{\bf \$MIR/src/subs/sortidx.for}
{\eightpoint\begintt
sortidxa ...... pjt .... Index sort of a an array of character values
sortidxd ...... pjt .... Index sort of a an array of double precision values
sortidxi ...... pjt .... Index sort of a an array of integer values
sortidxr ...... pjt .... Index sort of a an array of real values
\endtt}
\par{\bf \$MIR/src/subs/string.for}
{\eightpoint\begintt
atod .......... bpw .... Convert a string into a double precision.
atoi .......... bpw .... Convert a string into an integer.
getfield ...... bpw .... Extract a field from a string.
getparm ....... bpw .... Extract a parameter from a string.
gettok ........ bpw .... Extract a token from a string.
\endtt}
{\eightpoint\begintt
indek ......... bpw .... Get position of substring in a string, returning length if not found
isalnum ....... bpw .... Return true if char is an alphanumeric character
isalpha ....... bpw .... Return true if char is a letter (a-z, A-Z)
isdigit ....... bpw .... Return true if char is 0, 1, 2, 3, 4, 5, 6, 7, 8 or 9
islower ....... bpw .... Return true if char is a lowercase letter (a-z)
\endtt}
{\eightpoint\begintt
isupper ....... bpw .... Return true if char is an uppercase letter (A-Z)
itoa .......... bpw .... Convert an integer into a string.
lcase ......... bpw .... Convert a string to lower case.
len1 .......... bpw .... Determine the unpadded length of a character string.
match ......... bpw .... Check if a string occurs in a list of valid strings
\endtt}
{\eightpoint\begintt
matchdcd ...... bpw .... Check if a string occurs in a list of valid strings, with extras
mitoa ......... bpw .... Convert many integers into a string.
padleft ....... bpw .... Right justify a string to length characters.
rtfmt ......... bpw .... Construct a format during run time
rtoa .......... bpw .... Convert a real value into a string.
\endtt}
{\eightpoint\begintt
scanchar ...... bpw .... Scan a string for a character.
spanchar ...... bpw .... Skip over a particular character.
substr ........ bpw .... Returns the n-th substring from the input string
ucase ......... bpw .... Convert string to upper case.
\endtt}
\par{\bf \$MIR/src/subs/tabflux.for}
{\eightpoint\begintt
calget ........ jm ..... Routine to retrieve an interpolated calibrator flux.
tabflux ....... jm ..... Return the flux of a calibrator source at an input freq.
\endtt}
\par{\bf \$MIR/src/subs/title.for}
{\eightpoint\begintt
title ......... mchw ... Write title in standard format into LogFile.
\endtt}
\par{\bf \$MIR/src/subs/trnio.for}
{\eightpoint\begintt
trnfin ........ mchw ... Close up the transpose routines.
trnini ........ mchw ... Initialise the transpose routines.
trnread ....... mchw ... Read back a plane of the reordered cube.
trnwrite ...... mchw ... Write a plane of the cube in its initial order.
\endtt}
\par{\bf \$MIR/src/subs/tv.for}
{\eightpoint\begintt
pxtotv ........ jm ..... Convert image pixels to TV device positions.
tvchan ........ jm ..... Display a given image channel.
tvchar ........ jm ..... Get characteristics of the display device.
tvclose ....... jm ..... Close the display device.
tvcursor ...... jm ..... Read the location of the image display device's cursor.
\endtt}
{\eightpoint\begintt
tveras ........ jm ..... Erase a channel on the image display device.
tvflush ....... jm ..... Flush data to the display device.
tvline ........ jm ..... Write a raster line to the image display device.
tvlocal ....... jm ..... Put the display device into an interactive loop with the user.
tvlut ......... jm ..... Load a image display device's lookup table.
\endtt}
{\eightpoint\begintt
tvopen ........ jm ..... Open an image display device.
tvreset ....... jm ..... Reset the image display device.
tvscrl ........ jm ..... Scroll a display on a TV device.
tvselpt ....... jm ..... Interactive point/range selection on a display device.
tvtext ........ jm ..... Write a character string to the image display device.
\endtt}
{\eightpoint\begintt
tvtopx ........ jm ..... Convert TV device position to image pixels.
tvview ........ jm ..... Change the viewing window to a subportion of image memory.
tvwind ........ jm ..... Set/read current window (viewport) of a display device.
tvzoom ........ jm ..... Zoom a region of an image on a TV device.
\endtt}
\par{\bf \$MIR/src/subs/tvsubs.for}
{\eightpoint\begintt
imscale ....... jm ..... Autoscale a map.
wedge ......... jm ..... Load a wedge onto a TV device with user specified ranges.
\endtt}
\par{\bf \$MIR/src/subs/txtio.for}
{\eightpoint\begintt
output ........ bpw .... Output a line of text to the user.
prompt ........ bpw .... Read input from the user
txtclose ...... bpw .... Close a text file
txtopen ....... bpw .... Open a text file
txtopena ...... nebk ... Open a text file for appendation.
\endtt}
{\eightpoint\begintt
txtread ....... bpw .... Read a line from a text file
txtwrite ...... bpw .... Write a line to a text file
\endtt}
\par{\bf \$MIR/src/subs/ultra2.for}
{\eightpoint\begintt
ucursor ....... mjs .... Check Ultra cursor pos and 'exit' button state.
udef .......... mjs .... Set up and display Ultra control panel.
ufin .......... mjs .... Finish Ultra frame buffer and control panel.
uinit ......... mjs .... Indicate to ultra where control panel host is.
ulocal ........ mjs .... Allow user to fiddle the ultra frame buffer.
\endtt}
\par{\bf \$MIR/src/subs/utilities.for}
{\eightpoint\begintt
arctan ........ bpw .... Arctangent function
boxnr ......... bpw .... Find in which box the input value lies.
nel ........... bpw .... Return the number used values in an array
nelc .......... bpw .... Return the length of the string
nfig .......... bpw .... Find number of digits in a number
\endtt}
{\eightpoint\begintt
teken ......... bpw .... Returns the sign of a real value
\endtt}
\par{\bf \$MIR/src/subs/uvdat.for}
{\eightpoint\begintt
gainfact ...... mchw ... Determine the self-cal gain at a given time and baseline.
gainfin ....... mchw ... Close up the selfcal gains routines.
gaininit ...... mchw ... Initialise the "gains" routines.
uvdatget ...... mchw ... Get information about the UVDat routines.
uvdatinp ...... mchw ... Get command line uv data parameters.
\endtt}
{\eightpoint\begintt
uvdatprb ...... mchw ... Determine what data have been selected in the uvdat routines.
uvdatrd ....... mchw ... Read uv data from a multi-file set.
uvwdatrd ...... mchw ... Read wideband correlator data.
\endtt}
\par{\bf \$MIR/src/subs/uvfit.for}
{\eightpoint\begintt
uvfit1 ........ mchw ... Fit a constant to an "object" returned by uvinfo.
uvfit2 ........ mchw ... Fit a line to an "object" returned by uvinfo.
\endtt}
\par{\bf \$MIR/src/subs/uvio.c}
{\eightpoint\begintt
uvclose ....... rjs .... Close a uv file
uvcopyvr ...... rjs .... Copy variables from one uv file to another.
uvflgwr ....... rjs .... Write uv flags after a read.
uvgetvr ....... rjs .... Get the values of a uv variable.
uvinfo ........ rjs .... Get information about the last data read with uvread.
\endtt}
{\eightpoint\begintt
uvnext ........ rjs .... Skip to the next uv record.
uvopen ........ rjs .... Open a uv data file.
uvprobvr ...... rjs .... Return information about a variable.
uvputvr ....... rjs .... Write the value of a uv variable.
uvrdvr ........ rjs .... Return the value of a UV variable.
\endtt}
{\eightpoint\begintt
uvread ........ rjs .... Read in some uv correlation data.
uvrewind ...... rjs .... Reset the uv data file to the start of the file.
uvscan ........ rjs .... Scan a uv file until a variable changes.
uvselect ...... rjs .... Select or reject uv data.
uvset ......... rjs .... Set up the uv linetype, and other massaging steps.
\endtt}
{\eightpoint\begintt
uvtrack ....... rjs .... Set flags and switches associated with a uv variable.
uvupdate ...... rjs .... Check whether any "important" variables have changed.
uvwread ....... rjs .... Read in the wideband uv correlation data.
uvwrite ....... rjs .... Write correlation data to a uv file.
uvwwrite ...... rjs .... Write wide-band correlation data to a uv file.
\endtt}
\par{\bf \$MIR/src/subs/uvsubs.for}
{\eightpoint\begintt
angles ........ mchw ... Convert angle in degrees/hours to a string
bselect ....... mchw ... Find if given antenna is in given baseline code
expi .......... mchw ... Extract complex exponent of input in radians
oneamp ........ mchw ... Convert visibility to amp/phase or real/imag
phase ......... mchw ... Extract phase in radians from complex number
\endtt}
{\eightpoint\begintt
token ......... mchw ... Obtain token delimited by _ ()[]
width ......... mchw ... Calculate wideband channel width
\endtt}
\par{\bf \$MIR/src/subs/vmsdate.for}
{\eightpoint\begintt
itime ......... rjs .... Returns the present date.
\endtt}
\par{\bf \$MIR/src/subs/win.for}
{\eightpoint\begintt
fatpoint ...... pjt .... Draw fat, visible points
pgerase ....... pjt .... Erase the screen - and nothing more
win ........... pjt .... Subroutine package for interactive plots, using PGPLOT.
wincoord ...... pjt .... Change PGPLOT coordinates to a window
wincurs ....... pjt .... Get a character from a window
\endtt}
{\eightpoint\begintt
winloc ........ pjt .... Set window screen locations
winnear ....... pjt .... Return the nearest point
winnorm ....... pjt .... Normalize plots and add a margin
winnormy ...... pjt .... Normalize plots and add a margin
winpick ....... pjt .... Set the active windows
\endtt}
{\eightpoint\begintt
winpick1 ...... pjt .... Set an active window
winpoint ...... pjt .... Draw points
winqscal ...... pjt .... Queries set window user scales for selected window
winscale ...... pjt .... Set window user scales
winscalx ...... pjt .... Set window user X-scales
\endtt}
{\eightpoint\begintt
winscaly ...... pjt .... Set window user Y-scales
winset ........ pjt .... Set max unzoomed window matrix
winshow ....... pjt .... Put the plots onto the screen
winsize ....... pjt .... Size windows to the data
winsymb ....... pjt .... Return win2pgplot symbol marker
\endtt}
{\eightpoint\begintt
wintoscr ...... pjt .... Convert a point to screen coordinates
wintousr ...... pjt .... Convert a point to screen coordinates
\endtt}
\par{\bf \$MIR/src/subs/xyio.c}
{\eightpoint\begintt
xyclose ....... mjs .... Close up an image file.
xyflgrd ....... mjs .... Read image masking information (flags format).
xyflgwr ....... mjs .... Write image masking information (flags format).
xymkrd ........ mjs .... Read the masking information for an image (runs format).
xymkwr ........ mjs .... Write image masking information (runs format).
\endtt}
{\eightpoint\begintt
xyopen ........ mjs .... Open an image file.
xyread ........ mjs .... Read a row from an image.
xysetpl ....... mjs .... Set which plane of a cube is to be accessed.
xywrite ....... mjs .... Write a row to an image.
\endtt}
\par{\bf \$MIR/src/subs/zed.for}
{\eightpoint\begintt
zed ........... nebk ... Zeeman fit of I spectrum to V spectrum.
zedfudge ...... nebk ... Calculate sigma fudge factor, for Zeeman experiments.
zedfunc ....... nebk ... Return Zeeman maximum likelihood chi**2 value.
zedihat ....... nebk ... Calculate Zeeman estimate of a true I spectrum
zedrho ........ nebk ... Estimate Zeeman splitting, for spectrally correlated noise.
\endtt}
{\eightpoint\begintt
zedscale ...... nebk ... Determine conversion factor from channels to magnetic field.
zedvhat ....... nebk ... Calculate Zeeman estimate of a true V spectrum
\endtt}
\par{\bf \$MIR/src/subs/zeebin.for}
{\eightpoint\begintt
binfid ........ nebk ... Adjust window size and fiddle bin sizes for spacial averaging
binrd2 ........ nebk ... For vxy images, apply specified binning criterion
binup ......... nebk ... Bin up data in array
\endtt}
