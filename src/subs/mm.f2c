/************************************************************************/
/*									*/
/*  A set of FORTRAN-callable routines to allocate and free memory.	*/
/*                                                                      */
/*  Strictly speaking this is machine specific, but it should work on   */
/*  most machines with fairly standard C support.			*/
/*                                                                      */
/*  History:                                                            */
/*    26mar92 rjs  Original version.                                    */
/*    27jul92 rjs  Significant changes, to support 'd','c' and 'l' data */
/*		   types.						*/
/*    23dec92 rjs  Use intf2c, to make it more system independent.	*/
/*     5nov94 rjs  Try to be a bit more pedantic.			*/
/*    20jun02 pjt  even more pedantic yet                               */
/*    15aug07 pjt  fix for 64bit linux                                  */ 
/*    14jul08 pjt  merged in ATNF style                                 */
/*    21aug08 pjt  fixed linux 64bit alloc bug from shared libs + debug */
/*                                                                      */
/************************************************************************/

#include <stddef.h>
#include <stdlib.h>
#if defined(linux)
#include <malloc.h>
#endif
#include "miriad.h"

/* The size of all data items should be a multiple of the base unit.
   The base unit is preferably larger than 1 byte to help access
   larger memory areas on machines better than 32 bit addressing.	*/

#define base_unit sizeof(int)

/************************************************************************/
fortran integer function mmsize(integer type)
/**mmsize -- Determine the size of a data element in terms of "int"s.	*/
/*&rjs                                                                  */
/*:miscellaneous                                                        */
/*+ FORTRAN call sequence:

        integer function mmsize(type)
c
	implicit none
        integer type

  This returns the size of a data element in terms of a standard "int".

  Input:
    type	The data type. Possible values are:
		  ichar('i')	Normal integer.
		  ichar('r')	Real.
		  ichar('d')	Double precision.
		  ichar('l')    Logical.
		  ichar('c')    Complex.

  Output:
    mmsize	An integer giving the size in terms of ints.		*/

/*--                                                                    */
/*----------------------------------------------------------------------*/
{
  int size = 0;
  switch(type.val){
    case 'i':	size = sizeof(fort_integer);			break;
    case 'r':	size = sizeof(fort_real);			break;
    case 'd':	size = sizeof(fort_double);			break;
    case 'l':	size = sizeof(fort_logical);	   		break;
    case 'c':	size = 2*sizeof(fort_real);			break;
    default:	bug_c('f',"Unrecognised data type, in mmSize");
  }
  if(size % base_unit)bug_c('f',"Something wrong in mmSize");
  return size/base_unit;
}
/************************************************************************/
fortran integer function mmalloc(integer data,integer size)
/**mmalloc -- Allocate a block of memory.				*/
/*&rjs                                                                  */
/*:miscellaneous                                                        */
/*+ FORTRAN call sequence:

        integer function mmalloc(data,size)
c
	implicit none
        integer size
	integer data(*)

  This allocates memory on the heap. This returns a FORTRAN index,
  relative to data(1) of the allocated memory. The data type is
  given by type.

  Input:
    data	The returned index is relative to data(1). That is, if
		this routine returns index "i", the allocated memory is
		at data(i).
    size        Number of integers to allocate.

  Output:
    mmAlloc	Index to the allocated data. If the allocation fails,
		an index of zero is returned.				*/

/*--                                                                    */
/*----------------------------------------------------------------------*/
{
  ptrdiff_t offset;
  fort_integer t;
  fort_integer *s;
  static int mm_checked = 0;
  static int mm_debug = 0;

#if defined(linux)
  if (!mm_checked) {
    mm_checked = 1;
    if(sizeof(void *)> sizeof(fort_integer)) {
	/* check for potential large location of data w.r.t. malloc() data */
	/* first allocate a small piece of memory and see where it landed  */
	s = (fort_integer *)malloc( (size_t)(base_unit) );
	if(s == (fort_integer *)NULL) return 0;
	offset = s-data.addr;
	t = (fort_integer)offset;
	if (t == offset) mallopt(M_MMAP_MAX,0);
	if (mm_debug) bugv_c('i',"mmAlloc(4) tst: d,s %p %p   o,t %p %p",data.addr,s,offset,t); 
    }
  }
#endif
  s = (fort_integer *)malloc( (size_t)(size.val * base_unit) );
  if(s == (fort_integer *)NULL) return 0;
  offset = s - data.addr;
  t = (fort_integer)offset;
  if (mm_debug) bugv_c('i',"mmAlloc(%d) run: d,s %p %p   o,t %p %p",size.val,data.addr,s,offset,t); 
  if(t != offset) bugv_c('f',"mmAlloc: odd form of rounding: f=%p, offset=%p in mmAlloc   s,d=%p,%p",t,offset,s,data.addr);

  struct mallinfo mi = mallinfo();
  if (mm_debug) bugv_c('i',"mallinfo: hblks(d):%d %d   %d %d %d %d %d",mi.hblks,mi.hblkhd,mi.uordblks,mi.fordblks,mi.keepcost,mi.arena,mi.ordblks);

  return t + 1;
}
/************************************************************************/
fortran subroutine mmfree(integer data)
/**mmfree -- Free a block of memory.					*/
/*&rjs                                                                  */
/*:miscellaneous                                                        */
/*+ FORTRAN call sequence:

        subroutine mmfree(data)
        integer data(*)

  This frees up a block of memory allocated with mmalloc.

  Input:
    data	Pointer to the block of memory to free.			*/

/*--                                                                    */
/*----------------------------------------------------------------------*/
{
  free((char *)(data.addr));
}
