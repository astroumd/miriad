/************************************************************************/
/*									*/
/*	This converts from a FORTRAN calling sequence into a C.		*/
/*									*/
/*  History:								*/
/*    rjs  Dark ages Original version.					*/
/*    rjs  23aug89   Change to calling sequence of hdprobe.		*/
/*    rjs   9oct89   Deleted bug,bugno,pack16,unpack16,delay from this	*/
/*		     file. Only file i/o in this file now.		*/
/*    rjs  18oct89   uvselect added.                                    */
/*    rjs  30oct89   PAD call in hisread fixed                          */
/*    rjs   1nov89   Fixed bug that had crept in during multiflow port.	*/
/*    rjs  15nov89   Added dexpand.					*/
/*    rjs  23apr90   Changed order of #include "io.h" and fortran.h,	*/
/*		     for UNICOS.					*/
/*    rjs  27apr90   Added hdelete.					*/
/*    rjs  17oct90   Fixed bug in hwritea.				*/
/*    rjs  22feb91   Added uvmark.					*/
/*    rjs  27mar91   Added uvwflgwr.					*/
/*    rjs  26mar92   Added uvsela.					*/
/*    rjs  24aug92   Deleted uvmark, added				*/
/*		     uvvarini,uvvarset,uvvarcpy,uvvarupd		*/
/*    rjs  21dec92   Rewritten using intf2c syntax.			*/
/*    rjs   3mar93   Add uvflush,hflush.				*/
/*    rjs  26aug93   Add hrm and habort.				*/
/*    rjs  30aug93   Add hseek and htell.				*/
/*    rjs   5jan94   Added hmode,hexists.				*/
/*    rjs   5nov94   Correct declaration of hexists, and get rid of	*/
/*		     casting int to char*.				*/
/*    rjs  27feb96   Added xyflush.					*/
/*    rjs  19mar97   Handle logical translation better. Tidying.	*/
/************************************************************************/
#include <string.h>
#include "miriad.h"
/*#include "sysdep.h"*/
#include "io.h"

/************************************************************************/
fortran integer function dexpand(character template,character output)
{
  int dexpand_c();
  return(dexpand_c(template.zterm,output.addr,output.len));
}
/************************************************************************/
fortran subroutine scropen(integer handle)
{
  scropen_c(handle.addr);
}
/************************************************************************/
fortran subroutine scrclose(integer handle)
{
  scrclose_c(handle.val);
}
/************************************************************************/
fortran subroutine scrread(integer handle,real buffer,
	integer offset,integer length)
{
  scrread_c(handle.val,buffer.addr,offset.val,length.val);
}
/************************************************************************/
fortran subroutine scrwrite(integer handle,real buffer,
	integer offset,integer length)
{
  scrwrite_c(handle.val,buffer.addr,offset.val,length.val);
}
/************************************************************************/
fortran subroutine uvopen(integer tno,character name,character status)
{
  uvopen_c(tno.addr,name.zterm,status.zterm);
}
/************************************************************************/
fortran subroutine uvtrack(integer tno,character name,character switches)
{
  uvtrack_c(tno.val,name.zterm,switches.zterm);
}
/************************************************************************/
fortran subroutine uvcopyvr(integer tin,integer tout)
{
  uvcopyvr_c(tin.val,tout.val);
}
/************************************************************************/
fortran subroutine uvvarini(integer tno,integer handle)
{
  uvvarini_c(tno.val,handle.addr);
}
/************************************************************************/
fortran subroutine uvvarset(integer handle,character name)
{
  uvvarset_c(handle.val,name.zterm);
}
/************************************************************************/
fortran subroutine uvvarcpy(integer handle,integer tout)
{
  uvvarcpy_c(handle.val,tout.val);
}
/************************************************************************/
fortran integer function uvvarupd(integer handle)
{
  return(uvvarupd_c(handle.val));
}
/************************************************************************/
fortran subroutine uvflush(integer tno)
{
  uvflush_c(tno.val);
}
/************************************************************************/
fortran subroutine uvclose(integer tno)
{
  uvclose_c(tno.val);
}
/************************************************************************/
fortran integer function uvupdate(integer tno)
{
  return(uvupdate_c(tno.val));
}
/************************************************************************/
fortran subroutine uvnext(integer tno)
{
  uvnext_c(tno.val);
}
/************************************************************************/
fortran integer function uvscan(integer tno,character var)
{
  return(uvscan_c(tno.val,var.zterm));
}
/************************************************************************/
fortran subroutine uvrewind(integer tno)
{
  uvrewind_c(tno.val);
}
/************************************************************************/
fortran subroutine uvread(integer tno,double preamble,
	complex data,logical flags,integer n,integer nread)
{
  uvread_c(tno.val,preamble.addr,data.addr,flags.addr,n.val,nread.addr);
}
/************************************************************************/
fortran subroutine uvwread(integer tno,
	complex data,logical flags,integer n,integer nread)
{
  uvwread_c(tno.val,data.addr,flags.addr,n.val,nread.addr);
}
/************************************************************************/
fortran subroutine uvflgwr(integer tno,logical flags)
{
  uvflgwr_c(tno.val,flags.addr);
}
/************************************************************************/
fortran subroutine uvwflgwr(integer tno,logical flags)
{
  uvwflgwr_c(tno.val,flags.addr);
}
/************************************************************************/
fortran subroutine uvset(integer tno,character object,character type,
	integer n,real p1,real p2,real p3)
{
  uvset_c(tno.val,object.zterm,type.zterm,n.val,
		(double)p1.val,(double)p2.val,(double)p3.val);
}
/************************************************************************/
fortran subroutine uvselect(integer tno,character object,
	double p1,double p2,logical datasel)
{
  int flag;
  flag = FORT_LOGICAL(datasel.val);
  uvselect_c(tno.val,object.zterm,p1.val,p2.val,flag);
}
/************************************************************************/
fortran subroutine uvsela(integer tno,character object,character string,
	logical datasel)
{
  int flag;
  flag = FORT_LOGICAL(datasel.val);
  uvsela_c(tno.val,object.zterm,string.zterm,flag);
}
/************************************************************************/
fortran subroutine uvinfo(integer tno,character object,double data)
{
  uvinfo_c(tno.val,object.zterm,data.addr);
}
/************************************************************************/
fortran subroutine uvwrite(integer tno,double preamble,
		complex data,logical flags,integer n)
{
  uvwrite_c(tno.val,preamble.addr,data.addr,flags.addr,n.val);
}
/************************************************************************/
fortran subroutine uvwwrite(integer tno,complex data,logical flags,integer n)
{
  uvwwrite_c(tno.val,data.addr,flags.addr,n.val);
}
/************************************************************************/
fortran subroutine uvprobvr(integer tno,character var,character type,
	integer length,logical updated)
{
  uvprobvr_c(tno.val,var.zterm,type.addr,length.addr,updated.addr);
}
/************************************************************************/
fortran subroutine uvrdvra(integer tno,character var,
	character data,character def)
{
  uvrdvr_c(tno.val,H_BYTE,var.zterm,data.addr,def.zterm,data.len);
  data.pad;
}  
/************************************************************************/
fortran subroutine uvrdvri(integer tno,character var,integer data,integer def)
{
  uvrdvr_c(tno.val,H_INT,var.zterm,(char *)data.addr,(char *)def.addr,1);
}
/************************************************************************/
fortran subroutine uvrdvrr(integer tno,character var,real data,real def)
{
  uvrdvr_c(tno.val,H_REAL,var.zterm,(char *)data.addr,(char *)def.addr,1);
}
/************************************************************************/
fortran subroutine uvrdvrd(integer tno,character var,double data,double def)
{
  uvrdvr_c(tno.val,H_DBLE,var.zterm,(char *)data.addr,(char *)def.addr,1);
}
/************************************************************************/
fortran subroutine uvrdvrc(integer tno,character var,complex data,complex def)
{
  uvrdvr_c(tno.val,H_CMPLX,var.zterm,(char *)data.addr,(char *)def.addr,1);
}
/************************************************************************/
fortran subroutine uvgetvra(integer tno,character var,character data)
{
  uvgetvr_c(tno.val,H_BYTE,var.zterm,data.addr,data.len);
  data.pad;
}  
/************************************************************************/
fortran subroutine uvgetvri(integer tno,character var,integer data,integer n)
{
  uvgetvr_c(tno.val,H_INT,var.zterm,(char *)data.addr,n.val);
}
/************************************************************************/
fortran subroutine uvgetvrj(integer tno,character var,integer data,integer n)
{
  uvgetvr_c(tno.val,H_INT2,var.zterm,(char *)data.addr,n.val);
}
/************************************************************************/
fortran subroutine uvgetvrr(integer tno,character var,real data,integer n)
{
  uvgetvr_c(tno.val,H_REAL,var.zterm,(char *)data.addr,n.val);
}
/************************************************************************/
fortran subroutine uvgetvrd(integer tno,character var,double data,integer n)
{
  uvgetvr_c(tno.val,H_DBLE,var.zterm,(char *)data.addr,n.val);
}
/************************************************************************/
fortran subroutine uvgetvrc(integer tno,character var,complex data,integer n)
{
  uvgetvr_c(tno.val,H_CMPLX,var.zterm,(char *)data.addr,n.val);
}
/************************************************************************/
fortran subroutine uvputvri(integer tno,character var,integer data,integer n)
{
  uvputvr_c(tno.val,H_INT,var.zterm,(char *)data.addr,n.val);
}
/************************************************************************/
fortran subroutine uvputvrr(integer tno,character var,real data,integer n)
{
  uvputvr_c(tno.val,H_REAL,var.zterm,(char *)data.addr,n.val);
}
/************************************************************************/
fortran subroutine uvputvrd(integer tno,character var,double data,integer n)
{
  uvputvr_c(tno.val,H_DBLE,var.zterm,(char *)data.addr,n.val);
}
/************************************************************************/
fortran subroutine uvputvrc(integer tno,character var,complex data,integer n)
{
  uvputvr_c(tno.val,H_CMPLX,var.zterm,(char *)data.addr,n.val);
}
/************************************************************************/
fortran subroutine uvputvra(integer tno,character var,character data)
{
  char *s;
  s = data.zterm;
  uvputvr_c(tno.val,H_BYTE,var.zterm,s,strlen(s));
}
/************************************************************************/
fortran subroutine hopen(integer tno,character name,character status,
	integer iostat)
{
  hopen_c(tno.addr,name.zterm,status.zterm,iostat.addr);
}
/************************************************************************/
fortran subroutine hclose(integer tno)
{
  hclose_c(tno.val);
}
/************************************************************************/
fortran subroutine hflush(integer tno,integer iostat)
{
  hflush_c(tno.val,iostat.addr);
}
/************************************************************************/
fortran subroutine habort()
{
  habort_c();
}
/************************************************************************/
fortran subroutine hrm(integer tno)
{
  hrm_c(tno.val);
}
/************************************************************************/
fortran subroutine hdelete(integer tno,character name,integer iostat)
{
  hdelete_c(tno.val,name.zterm,iostat.addr);
}
/************************************************************************/
fortran subroutine haccess(integer tno,integer item,
	character name,character status,integer iostat)
{
  haccess_c(tno.val,item.addr,name.zterm,status.zterm,iostat.addr);
}
/************************************************************************/
fortran subroutine hmode(integer tno,character mode)
{
  hmode_c(tno.val,mode.addr);
  mode.pad;
}
/************************************************************************/
fortran logical function hexists(integer tno,character item)
{
  return( hexists_c(tno.val,item.zterm) ? FORT_TRUE : FORT_FALSE);
}
/************************************************************************/
fortran subroutine hdaccess(integer item,integer iostat)
{
  hdaccess_c(item.val,iostat.addr);
}
/************************************************************************/
fortran integer function hsize(integer item)
{
  return(hsize_c(item.val));
}
/************************************************************************/
fortran integer function htell(integer item)
{
  return(htell_c(item.val));
}
/************************************************************************/
fortran subroutine hseek(integer item,integer offset)
{
  hseek_c(item.val,offset.val);
}
/************************************************************************/
fortran subroutine hreada(integer item,character line,integer iostat)
{
  hreada_c(item.val,line.addr,line.len,iostat.addr);
  if(!iostat.val)line.pad;
}
/************************************************************************/
fortran subroutine hwritea(integer item,character line,integer iostat)
{
  char *s;

  s = line.zterm;
  hwritea_c(item.val,s,strlen(s)+1,iostat.addr);
}
/************************************************************************/
fortran subroutine hreadb(integer item,character buffer,
	integer offset,integer length,integer iostat)
{
  hreadb_c(item.val,buffer.addr,offset.val,length.val,iostat.addr);
}
/************************************************************************/
fortran subroutine hwriteb(integer item,character buffer,
	integer offset,integer length,integer iostat)
{
  hwriteb_c(item.val,buffer.addr,offset.val,length.val,iostat.addr);
}
/************************************************************************/
fortran subroutine hreadj(integer item,integer buffer,
	integer offset,integer length,integer iostat)
{
  hreadj_c(item.val,buffer.addr,offset.val,length.val,iostat.addr);
}
/************************************************************************/
fortran subroutine hwritej(integer item,integer buffer,
	integer offset,integer length,integer iostat)
{
  hwritej_c(item.val,buffer.addr,offset.val,length.val,iostat.addr);
}
/************************************************************************/
fortran subroutine hreadi(integer item,integer buffer,
	integer offset,integer length,integer iostat)
{
  hreadi_c(item.val,buffer.addr,offset.val,length.val,iostat.addr);
}
/************************************************************************/
fortran subroutine hwritei(integer item,integer buffer,
	integer offset,integer length,integer iostat)
{
  hwritei_c(item.val,buffer.addr,offset.val,length.val,iostat.addr);
}
/************************************************************************/
fortran subroutine hreadr(integer item,real buffer,
	integer offset,integer length,integer iostat)
{
  hreadr_c(item.val,buffer.addr,offset.val,length.val,iostat.addr);
}
/************************************************************************/
fortran subroutine hwriter(integer item,real buffer,
	integer offset,integer length,integer iostat)
{
  hwriter_c(item.val,buffer.addr,offset.val,length.val,iostat.addr);
}
/************************************************************************/
fortran subroutine hreadd(integer item,double buffer,
	integer offset,integer length,integer iostat)
{
  hreadd_c(item.val,buffer.addr,offset.val,length.val,iostat.addr);
}
/************************************************************************/
fortran subroutine hwrited(integer item,double buffer,
	integer offset,integer length,integer iostat)
{
  hwrited_c(item.val,buffer.addr,offset.val,length.val,iostat.addr);
}
/************************************************************************/
fortran subroutine hisopen(integer tno,character status)
{
  hisopen_c(tno.val,status.zterm);
}
/************************************************************************/
fortran subroutine hisread(integer tno,character line,logical eof)
{
  hisread_c(tno.val,line.addr,line.len,eof.addr);
  if(eof.val != FORT_TRUE)line.pad;
}
/************************************************************************/
fortran subroutine hiswrite(integer tno,character line)
{
  hiswrite_c(tno.val,line.zterm);
}
/************************************************************************/
fortran subroutine hisclose(integer tno)
{
  hisclose_c(tno.val);
}
/************************************************************************/
fortran subroutine xyopen(integer tno,character name,character status,
	integer naxis,integer axes)
{
  xyopen_c(tno.addr,name.zterm,status.zterm,naxis.val,axes.addr);
}
/************************************************************************/
fortran subroutine xyflush(integer tno)
{
  xyflush_c(tno.val);
}
/************************************************************************/
fortran subroutine xyclose(integer tno)
{
  xyclose_c(tno.val);
}
/************************************************************************/
fortran subroutine xyread(integer tno,integer index,real buffer)
{
  xyread_c(tno.val,index.val,buffer.addr);
}
/************************************************************************/
fortran subroutine xywrite(integer tno,integer index,real buffer)
{
  xywrite_c(tno.val,index.val,buffer.addr);
}
/************************************************************************/
fortran subroutine xymkrd(integer tno,integer index,
	integer buffer,integer n,integer nread)
{
  xymkrd_c(tno.val,index.val,buffer.addr,n.val,nread.addr);
}
/************************************************************************/
fortran subroutine xymkwr(integer tno,integer index,integer buffer,integer n)
{
  xymkwr_c(tno.val,index.val,buffer.addr,n.val);
}
/************************************************************************/
fortran subroutine xyflgrd(integer tno,integer index,logical buffer)
{
  xyflgrd_c(tno.val,index.val,buffer.addr);
}
/************************************************************************/
fortran subroutine xyflgwr(integer tno,integer index,logical buffer)
{
  xyflgwr_c(tno.val,index.val,buffer.addr);
}
/************************************************************************/
fortran subroutine xysetpl(integer tno,integer naxis,integer axes)
{
  xysetpl_c(tno.val,naxis.val,axes.addr);
}
/************************************************************************/
fortran subroutine hdprobe(integer tno,character keyword,
	character descr,character type,integer n)
{
  hdprobe_c(tno.val,keyword.zterm,descr.addr,descr.len,type.addr,n.addr);
  descr.pad;
  type.pad;
}
/************************************************************************/
fortran subroutine rdhdr(integer tno,character keyword,
	real value,real defval)
{
  double dvalue,ddefval;

  ddefval = defval.val;
  rdhdd_c(tno.val,keyword.zterm,&dvalue,ddefval);
  *(value.addr) = dvalue;
}
/************************************************************************/
fortran subroutine rdhdi(integer tno,character keyword,
	integer value,integer defval)
{
  double dvalue,ddefval;

  ddefval = defval.val;
  rdhdd_c(tno.val,keyword.zterm,&dvalue,ddefval);
  *(value.addr) = dvalue;
}
/************************************************************************/
fortran subroutine rdhdd(integer tno,character keyword,
	double value,double defval)
{
  rdhdd_c(tno.val,keyword.zterm,value.addr,defval.val);
}
/************************************************************************/
fortran subroutine rdhda(integer tno,character keyword,
	character value,character defval)
{
  rdhda_c(tno.val,keyword.zterm,value.addr,defval.zterm,value.len);
  value.pad;
}
/************************************************************************/
fortran subroutine rdhdc(integer tno,character keyword,
	complex value,complex defval)
{
  rdhdc_c(tno.val,keyword.zterm,value.addr,defval.addr);
}
/************************************************************************/
fortran subroutine wrhdr(integer tno,character keyword,real value)
{
  wrhdr_c(tno.val,keyword.zterm,(double)value.val);
}
/************************************************************************/
fortran subroutine wrhdd(integer tno,character keyword,double value)
{
  wrhdd_c(tno.val,keyword.zterm,value.val);
}
/************************************************************************/
fortran subroutine wrhdi(integer tno,character keyword,integer value)
{
  wrhdi_c(tno.val,keyword.zterm,value.val);
}
/************************************************************************/
fortran subroutine wrhdc(integer tno,character keyword,complex value)
{
  wrhdc_c(tno.val,keyword.zterm,value.addr);
}
/************************************************************************/
fortran subroutine wrhda(integer tno,character keyword,character value)
{
  wrhda_c(tno.val,keyword.zterm,value.zterm);
}
/************************************************************************/
fortran subroutine hdcopy(integer tIn,integer tOut,character keyword)
{
  hdcopy_c(tIn.val,tOut.val,keyword.zterm);
}
/************************************************************************/
fortran logical function hdprsnt(integer tno,character keyword)
{
  return(hdprsnt_c(tno.val,keyword.zterm));
}
/************************************************************************/
/* jhz 2004-5-25 */

fortran subroutine jpllinerd(real fmx, real fmn, real strl, 
 integer nmol,
 integer moltag,
 integer mxnline,
 real freq, real intensity,
 integer uqst, integer lqst, integer mtag)
{
    jpllinerd_c(fmx.val, fmn.val, strl.val, nmol.val,moltag.addr, 
    (char *)mxnline.addr,
    freq.addr, intensity.addr, 
    uqst.addr, lqst.addr, mtag.addr);
}
fortran subroutine molselect(character jplpath, integer pathlen, 
        integer mtag, integer nmline, character mname)
{     molselect_c(jplpath.addr, pathlen.val, mtag.addr, 
           (char *)nmline.addr, mname.addr, mname.len);
}

fortran subroutine rsmirread(character datapath, integer jstat)
{
  rsmirread_c(datapath.zterm, (char *)jstat.addr);
}


fortran subroutine rsmiriadwrite(character datapath, integer jstat)
{
  rsmiriadwrite_c(datapath.zterm, (char *)jstat.addr);
}

fortran subroutine rssmaflush(logical mflag, logical scinit, integer tcorr,
    logical scbuf, logical xflag, logical yflag,
    integer maxif, integer maxant, integer scanskip,
    integer scanproc, integer sb, integer rxif)
{
   rssmaflush_c(mflag.addr, scinit.addr, tcorr.val,
              scbuf.addr, xflag.addr, yflag.addr,
              maxif.val, maxant.val, scanskip.val,
              scanproc.val, sb.val, rxif.val);
}

fortran subroutine rspokeinisma(integer tbd, integer tno1,
 logical dosam1, logical doxyp1, logical doop1,
 logical dohann1, logical birdie1, logical dowt1,
 logical dopmps1, logical dobary1, logical doif1,
 logical hires1, logical nopol1, logical oldpol1,
 double lat1, double long1, integer rsnchan1)
        {
      rspokeinisma_c((char *)tbd.addr, tno1.val,
          dosam1.addr, doxyp1.addr, doop1.addr, dohann1.addr,
          birdie1.addr, dowt1.addr, dopmps1.addr, dobary1.addr,
          doif1.addr, hires1.addr, nopol1.addr,
          oldpol1.addr, lat1.val, long1.val, rsnchan1.val);
        }

fortran subroutine rspokeflshsma(integer tbd)
        {
            rspokeflshsma_c((char *)tbd.addr);
        }

/************************************************************************/
fortran subroutine bugno(character severity,integer n)
{
  bugno_c(severity.val,n.val);
}
/************************************************************************/
fortran subroutine bug(character severity,character message)
{
  bug_c(severity.val,message.zterm);
}
/************************************************************************/
fortran subroutine buglabel(character name)
{
  buglabel_c(name.zterm);
}
/************************************************************************/
/*									*/
/*  A set of FORTRAN-callable routines to allocate and free memory.	*/
/*                                                                      */
/*  Strictly speaking this is machine specific, but it should work on   */
/*  most machines with fairly standard C support.			*/
/*                                                                      */
/*  History:                                                            */
/*    26mar92 rjs  Original version.                                    */
/*    27jul92 rjs  Significant changes, to support 'd','c' and 'l' data */
/*		   types.						*/
/*    23dec92 rjs  Use intf2c, to make it more system independent.	*/
/*     5nov94 rjs  Try to be a bit more pedantic.			*/
/*                                                                      */
/************************************************************************/

#include <stddef.h>
#include <stdlib.h>

/************************************************************************/
fortran integer function mmsize(integer type)
/**mmsize -- Determine the size of a data element in terms of "int"s.	*/
/*&rjs                                                                  */
/*:miscellaneous                                                        */
/*+ FORTRAN call sequence:

        integer function mmsize(type)
c
	implicit none
        integer type

  This returns the size of a data element in terms of a standard "int".

  Input:
    type	The data type. Possible values are:
		  ichar('i')	Normal integer.
		  ichar('r')	Real.
		  ichar('d')	Double precision.
		  ichar('l')    Logical.
		  ichar('c')    Complex.

  Output:
    mmsize	An integer giving the size in terms of ints.		*/

/*--                                                                    */
/*----------------------------------------------------------------------*/
{
  int size;
  switch(type.val){
    case 'i':	size = 1;					break;
    case 'r':	size = (sizeof(float)-1)/sizeof(int) + 1;	break;
    case 'd':	size = (sizeof(double)-1)/sizeof(int) + 1;	break;
    case 'l':	size = 1;		     			break;
    case 'c':	size = (2*sizeof(float)-1)/sizeof(int) + 1;	break;
    default:	bug_c('f',"Unrecognised data type, in mmSize");
  }
  return size;
}
/************************************************************************/
fortran integer function mmalloc(integer data,integer size)
/**mmalloc -- Allocate a block of memory.				*/
/*&rjs                                                                  */
/*:miscellaneous                                                        */
/*+ FORTRAN call sequence:

        integer function mmalloc(data,size)
c
	implicit none
        integer size
	integer data(*)

  This allocates memory on the heap. This returns a FORTRAN index,
  relative to data(1) of the allocated memory. The data type is
  given by type.

  Input:
    data	The returned index is relative to data(1). That is, if
		this routine returns index "i", the allocated memory is
		at data(i).
    size        Number of integers to allocate.

  Output:
    mmAlloc	Index to the allocated data. If the allocation fails,
		an index of zero is returned.				*/

/*--                                                                    */
/*----------------------------------------------------------------------*/
{
  ptrdiff_t offset;
  int t;
  int *s;

  s = (int *)malloc( (size_t)(size.val * sizeof(int)) );
  if(s == (int *)NULL) return 0;
  offset = s - data.addr;
  t = (int)offset;
  if(t != offset)bug_c('f',"Some odd form of rounding problem, in mmAlloc");

  return t + 1;
}
/************************************************************************/
fortran subroutine mmfree(integer data)
/**mmfree -- Free a block of memory.					*/
/*&rjs                                                                  */
/*:miscellaneous                                                        */
/*+ FORTRAN call sequence:

        subroutine mmfree(data)
        integer data(*)

  This frees up a block of memory allocated with mmalloc.

  Input:
    data	Pointer to the block of memory to free.			*/

/*--                                                                    */
/*----------------------------------------------------------------------*/
{
  free((char *)(data.addr));
}
/************************************************************************/
/*									*/
/*	System dependent routines.					*/
/*									*/
/*									*/
/* Some typical operating system (OS) dependant calls:			*/
/*									*/
/*  mitime			return current time (hour,min,sec)	*/
/*  midate			return current date (day,month,year)	*/
/*  rmdata(dataset)		delete a dataset			*/
/*  filedel(file)		delete a file (unlink/			*/
/*  command(cmd)		issue OS command (spawn/system/)	*/
/*  mgetenv(value,envname)	translate environment variables		*/
/*  delay(secs)			wait a while.				*/
/*									*/
/*  History:								*/
/*									*/
/*    00jan90  pjt  created						*/
/*    25jun91  pjt  added filedel() from filedel.for		 	*/
/*    23dec92  rjs  translate to "f2c", include delay.			*/
/*    25aug93  mjs  include 3rd arg to setitimer (ansi, for solaris).	*/
/*    30sep93  mjs  rename delay -> delayf				*/
/*    12mar94  mjs  elim unused subroutine (no compile on solaris)      */
/************************************************************************/

#define MAXLEN 128
#include <stddef.h>
#include <time.h>
#include <signal.h>
#include <stdlib.h>
#include <errno.h>
#ifdef trace
extern int errno;
#endif

/************************************************************************/
fortran subroutine mitime(integer data)
/** mitime -- return current time (hour,min,sec)			*/
/*& pjt									*/
/*: utilities								*/
/*+ FORTRAN call sequence
      SUBROUTINE mitime(array)
      INTEGER array(3)

  This returns the current time.

  Output:
    array  The current time. array(1) is hours (24 clock).
			     array(2)    minutes
			     array(3)    seconds			*/
/*--									*/
/*----------------------------------------------------------------------*/
{
  struct tm *t;
  time_t tt;

  tt = time(0);
  t = localtime(&tt);
  data.addr[0] = t->tm_hour;
  data.addr[1] = t->tm_min;
  data.addr[2] = t->tm_sec;
}
/************************************************************************/
fortran subroutine midate(integer data)
/** midate -- return current date (day,month,year)			*/
/*& pjt									*/
/*: utilities								*/
/*+ FORTRAN call sequence
      SUBROUTINE midate(array)
      INTEGER array(3)

  This returns the current date.

  Output:
    array  The current date. array(1) is day of the month.
			     array(2)    month (range 1 to 12)
			     array(3)    year (e.g. 1992).		*/
/*--									*/
/*----------------------------------------------------------------------*/
{
  struct tm *t;
  time_t tt;

  tt = time(0);
  t = localtime(&tt);
  data.addr[0] = t->tm_mday;
  data.addr[1] = t->tm_mon + 1;
  data.addr[2] = t->tm_year + 1900;
}
/************************************************************************/
fortran subroutine rmdata(character string)
/** rmdata -- delete a miriad dataset					*/
/*& pjt									*/
/*: utilities								*/
/*+ FORTRAN call sequence
      SUBROUTINE rmdata(fname)
      CHARACTER fname*(*)

  Delete a MIRIAD dataset:
  For UNIX:      /bin/rm -r dataset
  For VMS:       rmdir dataset 
		  (assuming this command procedure has been installed)	*/
/*--									*/
/*----------------------------------------------------------------------*/
{
  char out[MAXLEN];

#ifdef vms
  strcpy(out,"rmdir ");
#else
  strcpy(out,"rm -r ");
#endif
  strcat(out,string.zterm);
  (void)system(out);
}
/************************************************************************/
fortran subroutine filedel(character string,integer iostat)
/** filedel -- delete a file						*/
/*& pjt									*/
/*: utilities								*/
/*+ FORTRAN call sequence:
      SUBROUTINE filedel (name, iostat)

      CHARACTER*(*) name
      INTEGER       iostat

  Input:     
     name      Name of the file to be deleted
  Output:
     iostat    Error Status of filedel. Will be non-zero in case
               of an error.

  Filedel is implemented on most UNIX system by the unlink
  system call.								*/
/*--									*/
/*----------------------------------------------------------------------*/
{
#ifdef vms
  *(iostat.addr) = delete(string.zterm);
  if(iostat.val) *(iostat.addr) = vaxc$errno;
#else
  *(iostat.addr) = unlink(string.zterm);
  if(iostat.val) *(iostat.addr) = errno;
#endif
}
/************************************************************************/
fortran subroutine command(character string)
/** command - issue an operating system command				*/
/*& pjt									*/
/*: utilities								*/
/*+ FORTRAN call sequence
      SUBROUTINE command(cmd)

      CHARACTER cmd*(*)

 COMMAND issues an operating system command, as supplied by the input
 character string 'cmd'.

 Input:
     cmd       character string of the command to be performed		*/
/*--									*/
/*----------------------------------------------------------------------*/
{
  (void)system(string.zterm);
}
/************************************************************************/
fortran subroutine mgetenv(character out,character in)
/** mgetenv - Translate environment variable on any machine		*/
/*& pjt									*/
/*: utilities								*/
/*+ FORTRAN call sequence
      SUBROUTINE mgetenv( outval, envnam )
      CHARACTER*(*) envnam,outval

 As something as simple as the translation of an enviroment variable is
 done differently on different machines, this MIRIAD subroutine provides
 a simple way for MIRIAD programmers to pretend it is the same.

   Input:
      envnam      The environment variable to be translated
   Output:
      outval      It returns a translated character string.

 For VMS is simply returns the input envnam itself.
 For most normal UNIX implementations getenv(3) is called.		*/
/*--									*/
/* History:
   bpw  07may91  Created
   pjt  22may91  Asked permission to take over this subr from bpw
                 and messed with doc and upper case fortran code.
   rjs  23dec92  Change call sequence.					*/
/*----------------------------------------------------------------------*/
{
  char *s;
#ifdef vms
  s = in.zterm;
#else
  s = getenv(in.zterm);
#endif
  if(s == NULL)s = "";
  strcpy(out.addr,s);
  out.pad;
}
/************************************************************************/
fortran subroutine delayf(real seconds)
/** delay - Wait a number of seconds.					*/
/*& pjt									*/
/*: utilities								*/
/*+ FORTRAN call sequence
      SUBROUTINE delayf( seconds )
      REAL seconds

 This routine waits a certain period, before returning to the caller.

   Input:
      seconds     The number of seconds to wait.			*/
/*--									*/
/*----------------------------------------------------------------------*/
/* History:
    rjs  Dark-ages Original version.
    rjs   8oct89   Make it FORTRAN callable.
    rjs  23dec92   Included into oscalls.f2c.
------------------------------------------------------------------------*/
{
#ifdef vms
  lib$wait(seconds.addr);
#else
#ifdef unicos
  int secs;
  secs = seconds.val + 0.5;
  if(secs > 0)sleep(secs);
#else
#include <sys/time.h>
  int secs;
  struct itimerval timer;

  timer.it_interval.tv_sec = 0;
  timer.it_interval.tv_usec = 0;
  timer.it_value.tv_sec = seconds.val;
  timer.it_value.tv_usec = 1000000 * (seconds.val - timer.it_value.tv_sec);
  (void)signal(SIGALRM,SIG_IGN);
  (void)setitimer(ITIMER_REAL,&timer,NULL);
  secs = seconds.val + 2;
  sleep(secs);
#endif
#endif
}
