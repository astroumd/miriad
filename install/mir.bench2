#! /bin/csh -f
#
#  mir.bench2: benchmark sensitivity and cleaning on homogeneous arrays
#
#  this script has the option of manually/iteratively run clean
#  using niters for clean and kiters to repeatedly call clean
#
#
#  if you  'setenv TMPDIR /dev/shm'   on linux,you can get extra
#  improvement in the I/O portion of this benchmark. 
#  Be aware you have enough memory allocated to this!
#
set tmp=bench$$
mkdir $tmp
cd $tmp

#			default parameters
set nchan=1
set imsize=512
set cell=0.5
set clean=0
set interval=0.01
set device=/null
set noise=1


set niters=250
set kiters=1
set time=80JAN01.0

foreach a ($*)
  set $a
end

echo "MIRBENCH2: (2012-10-16) $tmp : nchan=$nchan imsize=$imsize"
echo hostname=`hostname` 
echo benchdir=$tmp
echo system=`uname -a`  
echo date=`date`
echo MIR=$MIR

echo "1,0,0,0,0,0,0,0,0" > point.source
#set corr=0,1,100.0,1000.0 
set corr=$nchan,1,100.0,500.0
set harange=-6,6,$interval
set gnoise=0.1
set pnoise=10,0,0,0
set systemp=75,290,0.15
set tpower=0,0
set jyperk=150
set ant=($MIRCAT/carma_C.ant)
#set ant=($MIRCAT/bima_b.ant)
set baseunit=-3.335668


if ($noise == 0) then
  set systemp=0
  set gnoise=0
  set pnoise=0,0,0,0
endif



# be careful, MIRIAD uses $TMPDIR, and better make sure this is a local disk
# alternatively, you can set:
# setenv TMPDIR /tmp

uvgen out=vis1 harange=$harange source=$MIRCAT/point.source time=$time \
 corr=$corr ant=$ant[1] baseunit=$baseunit telescop=carma \
 gnoise=$gnoise pnoise=$pnoise systemp=$systemp tpower=$tpower jyperk=$jyperk \
 > uvgen.log

uvplt vis=vis1 axis=uc,vc options=equal,nobase,nanosec device=$device

invert vis=vis1 map=map1 beam=beam1 imsize=$imsize cell=$cell > invert.log

# just for fun, using kiters>1 you can loop over clean, accumulating CC's into clean$k
set model=()
foreach k (`seq $kiters`)
  clean map=map1 beam=beam1 out=clean$k $model niters=$niters > clean_$k.log
  set model=(model=clean$k)
  restor model=clean$k beam=beam1 map=map1 out=cmap$k    > restor_$k.log  
  restor model=clean$k beam=beam1 map=map1 out=res$k mode=residual > restor2_$k.log
  histo in=cmap$k | grep Flux >> flux.log
end

set rms=(`histo in=res$kiters  | grep Rms | awk '{print $4}'`)
set max=(`histo in=cmap$kiters | grep Max | awk '{print $3}'`)
cat flux.log
echo Fidelity: `calc $max/$rms`


if ($clean) rm -rf $tmp.*
