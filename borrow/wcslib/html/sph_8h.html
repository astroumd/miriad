<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
<title>WCSLIB 4.6.3: sph.h File Reference</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
<link href="tabs.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div>
<div class="contents">
<h1>sph.h File Reference</h1>
<p>
<a href="sph_8h-source.html">Go to the source code of this file.</a><table border="0" cellpadding="0" cellspacing="0">
<tr><td></td></tr>
<tr><td colspan="2"><br><h2>Functions</h2></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph_8h.html#bcdbd119e57482315882d849f2b04e91">sphx2s</a> (const double eul[5], int nphi, int ntheta, int spt, int sxy, const double phi[], const double theta[], double lng[], double lat[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotation in the pixel-to-world direction.  <a href="#bcdbd119e57482315882d849f2b04e91"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph_8h.html#5c0783d56189d48d9f52af05b64a4df6">sphs2x</a> (const double eul[5], int nlng, int nlat, int sll, int spt, const double lng[], const double lat[], double phi[], double theta[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Rotation in the world-to-pixel direction.  <a href="#5c0783d56189d48d9f52af05b64a4df6"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph_8h.html#ec6222fe1e4d807c9b59980b8e548eb0">sphdpa</a> (int nfield, double lng0, double lat0, const double lng[], const double lat[], double dist[], double pa[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute angular distance and position angle.  <a href="#ec6222fe1e4d807c9b59980b8e548eb0"></a><br></td></tr>
<tr><td class="memItemLeft" nowrap align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="sph_8h.html#8ee2e117701f434f0bffbbe52f05d118">sphpad</a> (int nfield, double lng0, double lat0, const double dist[], const double pa[], double lng[], double lat[])</td></tr>

<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Compute field points offset from a given point.  <a href="#8ee2e117701f434f0bffbbe52f05d118"></a><br></td></tr>
</table>
<hr><a name="_details"></a><h2>Detailed Description</h2>
The WCS spherical coordinate transformations are implemented via separate functions, <a class="el" href="sph_8h.html#bcdbd119e57482315882d849f2b04e91" title="Rotation in the pixel-to-world direction.">sphx2s()</a> and <a class="el" href="sph_8h.html#5c0783d56189d48d9f52af05b64a4df6" title="Rotation in the world-to-pixel direction.">sphs2x()</a>, for the transformation in each direction.<p>
A utility function, <a class="el" href="sph_8h.html#ec6222fe1e4d807c9b59980b8e548eb0" title="Compute angular distance and position angle.">sphdpa()</a>, computes the angular distances and position angles from a given point on the sky to a number of other points. <a class="el" href="sph_8h.html#8ee2e117701f434f0bffbbe52f05d118" title="Compute field points offset from a given point.">sphpad()</a> does the complementary operation - computes the coordinates of points offset by the given angular distances and position angles from a given point on the sky. <hr><h2>Function Documentation</h2>
<a class="anchor" name="bcdbd119e57482315882d849f2b04e91"></a><!-- doxytag: member="sph.h::sphx2s" ref="bcdbd119e57482315882d849f2b04e91" args="(const double eul[5], int nphi, int ntheta, int spt, int sxy, const double phi[], const double theta[], double lng[], double lat[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sphx2s           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>eul</em>[5], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nphi</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>ntheta</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sxy</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>phi</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>theta</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lng</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lat</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>sphx2s</b>() transforms native coordinates of a projection to celestial coordinates.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>eul</em>&nbsp;</td><td>Euler angles for the transformation:<ul>
<li>0: Celestial longitude of the native pole [deg].</li><li>1: Celestial colatitude of the native pole, or native colatitude of the celestial pole [deg].</li><li>2: Native longitude of the celestial pole [deg].</li><li>3: <img class="formulaInl" alt="$cos$" src="form_46.png">(eul[1])</li><li>4: <img class="formulaInl" alt="$sin$" src="form_47.png">(eul[1]) </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nphi,ntheta</em>&nbsp;</td><td>Vector lengths. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>spt,sxy</em>&nbsp;</td><td>Vector strides. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>phi,theta</em>&nbsp;</td><td>Longitude and latitude in the native coordinate system of the projection [deg].</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>lng,lat</em>&nbsp;</td><td>Celestial longitude and latitude [deg]. These may refer to the same storage as <em>phi</em> and <em>theta</em> respectively.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status return value:<ul>
<li>0: Success. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="5c0783d56189d48d9f52af05b64a4df6"></a><!-- doxytag: member="sph.h::sphs2x" ref="5c0783d56189d48d9f52af05b64a4df6" args="(const double eul[5], int nlng, int nlat, int sll, int spt, const double lng[], const double lat[], double phi[], double theta[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sphs2x           </td>
          <td>(</td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>eul</em>[5], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nlng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nlat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>sll</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>spt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lng</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lat</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>phi</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>theta</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>sphs2x</b>() transforms celestial coordinates to the native coordinates of a projection.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>eul</em>&nbsp;</td><td>Euler angles for the transformation:<ul>
<li>0: Celestial longitude of the native pole [deg].</li><li>1: Celestial colatitude of the native pole, or native colatitude of the celestial pole [deg].</li><li>2: Native longitude of the celestial pole [deg].</li><li>3: <img class="formulaInl" alt="$cos$" src="form_46.png">(eul[1])</li><li>4: <img class="formulaInl" alt="$sin$" src="form_47.png">(eul[1]) </li></ul>
</td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nlng,nlat</em>&nbsp;</td><td>Vector lengths. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>sll,spt</em>&nbsp;</td><td>Vector strides. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lng,lat</em>&nbsp;</td><td>Celestial longitude and latitude [deg].</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>phi,theta</em>&nbsp;</td><td>Longitude and latitude in the native coordinate system of the projection [deg]. These may refer to the same storage as <em>lng</em> and <em>lat</em> respectively.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status return value:<ul>
<li>0: Success. </li></ul>
</dd></dl>

</div>
</div><p>
<a class="anchor" name="ec6222fe1e4d807c9b59980b8e548eb0"></a><!-- doxytag: member="sph.h::sphdpa" ref="ec6222fe1e4d807c9b59980b8e548eb0" args="(int nfield, double lng0, double lat0, const double lng[], const double lat[], double dist[], double pa[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sphdpa           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nfield</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lat0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lng</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>lat</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>dist</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>pa</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>sphdpa</b>() computes the angular distance and generalized position angle (see notes) from a "reference" point to a number of "field" points on the sphere. The points must be specified consistently in any spherical coordinate system.<p>
<b>sphdpa</b>() is complementary to <a class="el" href="sph_8h.html#8ee2e117701f434f0bffbbe52f05d118" title="Compute field points offset from a given point.">sphpad()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nfield</em>&nbsp;</td><td>The number of field points. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lng0,lat0</em>&nbsp;</td><td>Spherical coordinates of the reference point [deg]. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lng,lat</em>&nbsp;</td><td>Spherical coordinates of the field points [deg].</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>dist,pa</em>&nbsp;</td><td>Angular distances and position angles [deg]. These may refer to the same storage as <em>lng</em> and <em>lat</em> respectively.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status return value:<ul>
<li>0: Success.</li></ul>
</dd></dl>
<b>Notes:</b> <br>
 <b>sphdpa</b>() uses <a class="el" href="sph_8h.html#5c0783d56189d48d9f52af05b64a4df6" title="Rotation in the world-to-pixel direction.">sphs2x()</a> to rotate coordinates so that the reference point is at the north pole of the new system with the north pole of the old system at zero longitude in the new. The Euler angles required by <a class="el" href="sph_8h.html#5c0783d56189d48d9f52af05b64a4df6" title="Rotation in the world-to-pixel direction.">sphs2x()</a> for this rotation are <div class="fragment"><pre class="fragment">      eul[0] = lng0;
      eul[1] = 90.0 - lat0;
      eul[2] =  0.0;
</pre></div><p>
The angular distance and generalized position angle are readily obtained from the longitude and latitude of the field point in the new system. This applies even if the reference point is at one of the poles, in which case the "position angle" returned is as would be computed for a reference point at <img class="formulaInl" alt="$(\alpha_0,+90^\circ-\epsilon)$" src="form_48.png"> or <img class="formulaInl" alt="$(\alpha_0,-90^\circ+\epsilon)$" src="form_49.png">, in the limit as <img class="formulaInl" alt="$\epsilon$" src="form_43.png"> goes to zero.<p>
It is evident that the coordinate system in which the two points are expressed is irrelevant to the determination of the angular separation between the points. However, this is not true of the generalized position angle.<p>
The generalized position angle is here defined as the angle of intersection of the great circle containing the reference and field points with that containing the reference point and the pole. It has its normal meaning when the the reference and field points are specified in equatorial coordinates (right ascension and declination).<p>
Interchanging the reference and field points changes the position angle in a non-intuitive way (because the sum of the angles of a spherical triangle normally exceeds <img class="formulaInl" alt="$180^\circ$" src="form_50.png">).<p>
The position angle is undefined if the reference and field points are coincident or antipodal. This may be detected by checking for a distance of <img class="formulaInl" alt="$0^\circ$" src="form_51.png"> or <img class="formulaInl" alt="$180^\circ$" src="form_50.png"> (within rounding tolerance). <b>sphdpa</b>() will return an arbitrary position angle in such circumstances. 
</div>
</div><p>
<a class="anchor" name="8ee2e117701f434f0bffbbe52f05d118"></a><!-- doxytag: member="sph.h::sphpad" ref="8ee2e117701f434f0bffbbe52f05d118" args="(int nfield, double lng0, double lat0, const double dist[], const double pa[], double lng[], double lat[])" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int sphpad           </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>nfield</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lng0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lat0</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>dist</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&nbsp;</td>
          <td class="paramname"> <em>pa</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lng</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&nbsp;</td>
          <td class="paramname"> <em>lat</em>[]</td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>
<b>sphpad</b>() computes the coordinates of a set of points that are offset by the specified angular distances and position angles from a given "reference" point on the sky. The distances and position angles must be specified consistently in any spherical coordinate system.<p>
<b>sphpad</b>() is complementary to <a class="el" href="sph_8h.html#ec6222fe1e4d807c9b59980b8e548eb0" title="Compute angular distance and position angle.">sphdpa()</a>.<p>
<dl compact><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>nfield</em>&nbsp;</td><td>The number of field points. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>lng0,lat0</em>&nbsp;</td><td>Spherical coordinates of the reference point [deg]. </td></tr>
    <tr><td valign="top"><tt>[in]</tt>&nbsp;</td><td valign="top"><em>dist,pa</em>&nbsp;</td><td>Angular distances and position angles [deg].</td></tr>
    <tr><td valign="top"><tt>[out]</tt>&nbsp;</td><td valign="top"><em>lng,lat</em>&nbsp;</td><td>Spherical coordinates of the field points [deg]. These may refer to the same storage as <em>dist</em> and <em>pa</em> respectively.</td></tr>
  </table>
</dl>
<dl class="return" compact><dt><b>Returns:</b></dt><dd>Status return value:<ul>
<li>0: Success.</li></ul>
</dd></dl>
<b>Notes:</b> <br>
 <b>sphpad</b>() is implemented analogously to <a class="el" href="sph_8h.html#ec6222fe1e4d807c9b59980b8e548eb0" title="Compute angular distance and position angle.">sphdpa()</a> although using <a class="el" href="sph_8h.html#bcdbd119e57482315882d849f2b04e91" title="Rotation in the pixel-to-world direction.">sphx2s()</a> for the inverse transformation. In particular, when the reference point is at one of the poles, "position angle" is interpreted as though the reference point was at <img class="formulaInl" alt="$(\alpha_0,+90^\circ-\epsilon)$" src="form_48.png"> or <img class="formulaInl" alt="$(\alpha_0,-90^\circ+\epsilon)$" src="form_49.png">, in the limit as <img class="formulaInl" alt="$\epsilon$" src="form_43.png"> goes to zero.<p>
Applying <b>sphpad</b>() with the distances and position angles computed by <a class="el" href="sph_8h.html#ec6222fe1e4d807c9b59980b8e548eb0" title="Compute angular distance and position angle.">sphdpa()</a> should return the original field points. 
</div>
</div><p>
</div>
<hr size="1"><address style="text-align: right;"><small>Generated on Wed Nov 24 12:48:54 2010 for WCSLIB 4.6.3 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img src="doxygen.png" alt="doxygen" align="middle" border="0"></a> 1.5.6 </small></address>
</body>
</html>
